{"meta":{"version":1,"warehouse":"4.0.1"},"models":{"Asset":[{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/avatar.JPG","path":"img/avatar.JPG","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/hint/hint.min.css","path":"lib/hint/hint.min.css","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/Hello2017.md","hash":"fd69c2294b42007f0fae90fffb579a1de04dacbf","modified":1639319137197},{"_id":"source/_posts/Linux中用gdb 查看代码堆栈的信息.md","hash":"9ad37dc9de0b5830f582c27f1d1f986a2bbc1636","modified":1643464613860},{"_id":"source/_posts/Materialize.md","hash":"bec71baf74088be47a247f1d3a7f83d05c3eccf1","modified":1639319137269},{"_id":"source/_posts/PyMySQL.md","hash":"caeee2b886a90eb1ae9312ce399bc542ad3743cc","modified":1639319137561},{"_id":"source/_posts/Python解释执行原理及过程.md","hash":"aa5f8bd019929fb83b66da0e4cd02919c4946f81","modified":1639319137697},{"_id":"source/_posts/Tess of the D'Urbervilles.md","hash":"95436f63cff21317b31832be8b0a8c46b359000a","modified":1639319137897},{"_id":"source/_posts/UbuntuKylin13.10下安装配置Theano.md","hash":"17310a89dab702f3a8a11eb83d246ceab6fc5db3","modified":1639319138009},{"_id":"source/_posts/基于马尔可夫链的语义推导算法.md","hash":"89089c705fe3c3b926428af13af36eb560f388a5","modified":1639323781475},{"_id":"source/_posts/多轮对话交互系统文本预处理模块之基于条件随机场判断文本是否有下文.md","hash":"8396bb158a265e757a959c84bb7fa98fcf4150ab","modified":1640885019535},{"_id":"source/_posts/数学建模之预测模型总结.md","hash":"f4d6a62c2d2f9df45acfdf509870d692ed36d7d2","modified":1639319136965},{"_id":"source/_posts/看南飞的孤雁，过境处依旧是聚散人间.md","hash":"dc9e9fef2624182b1def7a41f1bac5979a5838c1","modified":1639319136861},{"_id":"source/_posts/语音特征参数MFCC提取过程详解.md","hash":"7a3b4841784132530f7421840c5cbf3e1d0720e4","modified":1639319137085},{"_id":"source/_posts/进击的Tensorflow.md","hash":"2a0b71f969366b1069119df9099c2a78c8516df4","modified":1639319136657},{"_id":"source/about/index.md","hash":"406b758e98b59efa7e9e9fce512bb9cc9c303495","modified":1637502500371},{"_id":"source/category/index.md","hash":"aa2e4f5c9ff32f31f35828979529ff6bc1b3a287","modified":1638804716447},{"_id":"source/tag/index.md","hash":"8fe06d7380dc04a2778b9d2658303dd4f7b3ee60","modified":1638804707167},{"_id":"themes/fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632303131000},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632303131000},{"_id":"themes/fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1632303131000},{"_id":"themes/fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1632303131000},{"_id":"themes/fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1632303131000},{"_id":"themes/fluid/.gitignore","hash":"bd095eee271360a38772ee1a42d4f000fb722e5f","modified":1632303131000},{"_id":"themes/fluid/LICENSE","hash":"df5b54be535593d5442cebafbea34eb9bd69b987","modified":1632303131000},{"_id":"themes/fluid/README.md","hash":"03cfa8e5f149514b57ef80dcb84eb7fea261370d","modified":1632303131000},{"_id":"themes/fluid/README_en.md","hash":"ca8fd19a4948de1f253616a62c0e8a7d81f692f5","modified":1632303131000},{"_id":"themes/fluid/_config.yml","hash":"67e3c4fe9f17e7a234896fac8b67e26147201c2d","modified":1643892364236},{"_id":"themes/fluid/package.json","hash":"18f04247801549fe78600c1ee9c601fcbea4cab3","modified":1632303131000},{"_id":"themes/fluid/languages/de.yml","hash":"13a6a799415fc2f6f69ebd1a399fb44426a5d641","modified":1632303131000},{"_id":"themes/fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":1632303131000},{"_id":"themes/fluid/languages/eo.yml","hash":"a0c7984495d4f2d33b64adfa33adebbf768a5ac3","modified":1632303131000},{"_id":"themes/fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":1632303131000},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":1632303131000},{"_id":"themes/fluid/languages/zh-TW.yml","hash":"1a6d415446da11dee5c5f400e7d67544fbe743ea","modified":1632303131000},{"_id":"themes/fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":1632303131000},{"_id":"themes/fluid/layout/about.ejs","hash":"ad6fed7b646d3ca961db83db0fbe020e3a5d42ad","modified":1632303131000},{"_id":"themes/fluid/layout/archive.ejs","hash":"472d0813ca5b88000a7bc6039f33b7e27b5a3216","modified":1632303131000},{"_id":"themes/fluid/layout/categories.ejs","hash":"20c2a195a109d2a263b5fa6e79cbcc62932508ad","modified":1632303131000},{"_id":"themes/fluid/layout/category.ejs","hash":"58291dfec65c36889dfce0ddc603540b67e4c598","modified":1632303131000},{"_id":"themes/fluid/layout/index.ejs","hash":"666476260a2cead2cc2928d51977c4a7ba8de6bb","modified":1632303131000},{"_id":"themes/fluid/layout/layout.ejs","hash":"7f566edf750241e62d7c54abfbb0c504fdab850a","modified":1632303131000},{"_id":"themes/fluid/layout/links.ejs","hash":"2a7b49f0f9aecf07550b5a0b99242aab5654cf2b","modified":1632303131000},{"_id":"themes/fluid/layout/page.ejs","hash":"1014b901d396f4fc445cb1ffc938d5380d894d71","modified":1632303131000},{"_id":"themes/fluid/layout/post.ejs","hash":"79e3679a7069351a6172c281b9d09f59d7580484","modified":1632303131000},{"_id":"themes/fluid/layout/tag.ejs","hash":"0ad89eb7c92a822980fa9a85285e6d94ad845d1d","modified":1632303131000},{"_id":"themes/fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1632303131000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"16d33eb89ecf90f4046720fde5395d972c7ba1fd","modified":1632303131000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"af977ed0792508bb0766ea8afe82d34ef1e8fb3c","modified":1632303131000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":1632303131000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":1632303131000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":1632303131000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":1632303131000},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/archive-list.ejs","hash":"53a4f6029373a40394a87aba9284696a71610f90","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/beian.ejs","hash":"58b4bbe36386de4305a8da5ffd7d56802df23049","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/css.ejs","hash":"c363829a4b80f74fc1c565e41f6dab41c95006ea","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/footer.ejs","hash":"a62278c38a310da495d96c39abacacef266945cb","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/head.ejs","hash":"7d0cf31f2595cfe6d5ad31d569654f21a00dfd77","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/nav.ejs","hash":"e71b3c4aa263163597d31b1f91e5a1a877084cfd","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/post-meta.ejs","hash":"32a17edadeed40da6db21d2d8031bd47d2fc9bf4","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/scripts.ejs","hash":"0ee838b6fcd895d21a29d9d67dbb99b752d623d1","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/toc.ejs","hash":"3d2fb5552f373e5a0c56bc356702d807bcbcb411","modified":1632303131000},{"_id":"themes/fluid/scripts/events/index.js","hash":"44faef3e77ab08b91e4c5c6f1cd9087a9faff443","modified":1632303131000},{"_id":"themes/fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1632303131000},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"6c37e9f1ac1d6d00b3c32794e02e244dba942cd9","modified":1632303131000},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1632303131000},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":1632303131000},{"_id":"themes/fluid/scripts/helpers/export-config.js","hash":"cde964c8cd3217268a231de5e018a62c53c2e047","modified":1632303131000},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1632303131000},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1632303131000},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"3aa5b4ea879cd34d3a32468d88da18d72cbcc8e0","modified":1632303131000},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"8e33f915028ac56258f6999d19b1ad8d800cecfe","modified":1632303131000},{"_id":"themes/fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1632303131000},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":1632303131000},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1632303131000},{"_id":"themes/fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1632303131000},{"_id":"themes/fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1632303131000},{"_id":"themes/fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":1632303131000},{"_id":"themes/fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1632303131000},{"_id":"themes/fluid/scripts/utils/object.js","hash":"649457796374c79e49a19bd541e4ad8e78fe8995","modified":1632303131000},{"_id":"themes/fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1632303131000},{"_id":"themes/fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1632303131000},{"_id":"themes/fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":1632303131000},{"_id":"themes/fluid/source/img/avatar.JPG","hash":"2264f48dc2cb260835af839969a3ab93ad5d3650","modified":1638897432869},{"_id":"themes/fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1632303131000},{"_id":"themes/fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1632303131000},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1632303131000},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1632303131000},{"_id":"themes/fluid/source/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":1632303131000},{"_id":"themes/fluid/source/js/color-schema.js","hash":"2520c6459b544a4e965b838f8095e2a84390a43c","modified":1632303131000},{"_id":"themes/fluid/source/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":1632303131000},{"_id":"themes/fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1632303131000},{"_id":"themes/fluid/source/js/leancloud.js","hash":"4a787cfce27045aa0a92ec22e84f2ccf30cabc4c","modified":1632303131000},{"_id":"themes/fluid/source/js/local-search.js","hash":"633f0142c657805359b0197f287e12ae4bcde731","modified":1632303131000},{"_id":"themes/fluid/source/js/plugins.js","hash":"d058f30bd09b28769c4d8313428ff23dfc8d52dd","modified":1632303131000},{"_id":"themes/fluid/source/js/utils.js","hash":"4a43f2700e91937650bef511fd438825b001c4c6","modified":1632303131000},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/comments/twikoo.ejs","hash":"1af53bc0be642610a3a4d4e7c05287854a821508","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/comments/utterances.ejs","hash":"e1ed6530dfd7310f91060a75766a93ac3c39be3a","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/comments/valine.ejs","hash":"4052ab2a8f78efa92f0fe17abe8f66135943390a","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/comments/waline.ejs","hash":"21e00443054802e893aac1f668b69d5bb4b39b3a","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/plugins/math.ejs","hash":"a7ed1d3079c32497c8955ca75f5fb6992e5ffb8b","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1632303131000},{"_id":"themes/fluid/layout/_partial/plugins/typed.ejs","hash":"ece659572cf4e12638a1607fca512c25098bbd82","modified":1632303131000},{"_id":"themes/fluid/scripts/events/lib/compatible-configs.js","hash":"b5fd5a2d9c463eb59318af0f47c591c485b6ad27","modified":1632303131000},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":1632303131000},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"28e186c32576eb3d5d923273471a001c47fe8071","modified":1632303131000},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"deed966f38cf0c8dee3f72e5b1f2e878510db0e1","modified":1632303131000},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1632303131000},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"c1db1a4f9eca6e36b660530641e3a4fb6a30c8d8","modified":1632303131000},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1632303131000},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1632303131000},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1632303131000},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"63aedd67d90d641cc672540db20ef615f528c9f1","modified":1632303131000},{"_id":"themes/fluid/source/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1632303131000},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1632303131000},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":1632303131000},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"cd55a2dce6b9d3e165a0a26d0b5bf7f649006bcd","modified":1632303131000},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"32fb938d72b2d86159cb315a98b086bd17fa4415","modified":1632303131000},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"d547ab0b91f84eb0acd0bc0c5d716ce17c30361a","modified":1632303131000},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1632303131000},{"_id":"themes/fluid/source/css/_pages/_base/rewrite.styl","hash":"c66e0da2c0d05e76a686a77ab4e74f0d2e89777d","modified":1632303131000},{"_id":"themes/fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":1632303131000},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"616c1f7147078c3d532dd1cfd2af09c0c3a816f0","modified":1632303131000},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"7e32a3268accf3d524209c213e15e2d5d5e2e1a6","modified":1632303131000},{"_id":"themes/fluid/source/css/_pages/_post/post.styl","hash":"3a6b4f8a29648d9d2c1e99b52a7b42df3f15cf62","modified":1632303131000},{"_id":"themes/fluid/source/css/_pages/_post/tag_plugin.styl","hash":"b89b96c8a6a433a6f372b42710554b05cab85a24","modified":1632303131000},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1632303131000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"30f8fab95a5214d79df0ccc02b937df8bd885676","modified":1632303131000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":1632303131000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"9f932ca3f9625c13aa5353f58319881e62c0c653","modified":1632303131000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"0ce7552dc4993926426019398d73e817cfd841a1","modified":1632303131000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1632303131000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"d8011325756eb6e4ce619b3e7b4d6d80c2de8a57","modified":1632303131000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1632303131000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"55e10a6965462f8f62f85e75fd5e143af02a4b44","modified":1632303131000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1632303131000},{"_id":"public/local-search.xml","hash":"608bf6c05073ed1f00fbfc23733c20be8b853108","modified":1652890932953},{"_id":"public/about/index.html","hash":"8c3a9e1b18fe084e40ca4e3875aca47f68e81311","modified":1652890932953},{"_id":"public/category/index.html","hash":"496ed15f9d68e30628c4e4709467308ff8501560","modified":1652890932953},{"_id":"public/tag/index.html","hash":"5a812c0657ebe467ef1b2de6c2b4a7b75fd314d2","modified":1652890932953},{"_id":"public/2021/12/30/多轮对话交互系统文本预处理模块之基于条件随机场判断文本是否有下文/index.html","hash":"3983ee15aaea1956ff03679b75cbb70098d8bf88","modified":1652890932953},{"_id":"public/2021/12/12/基于马尔可夫链的语义推导算法/index.html","hash":"38b126b8a2ed859bee3ea8e6328dd5688fff6662","modified":1652890932953},{"_id":"public/2017/05/02/Materialize/index.html","hash":"4a2e5518d017bca886cb51b38340cdf2c4d0ebd5","modified":1652890932953},{"_id":"public/2016/10/17/Tess of the D'Urbervilles/index.html","hash":"9f89ca1471238c1dd1f3b82b552913665fcb4748","modified":1652890932953},{"_id":"public/2016/03/13/数学建模之预测模型总结/index.html","hash":"9ed1920794d1936b0a3f53a9db3089a9de1d9a7f","modified":1652890932953},{"_id":"public/archives/index.html","hash":"23eedd58b8ac2cc4f146e1d0e23fbfecd3ae5ab6","modified":1652890932953},{"_id":"public/archives/page/2/index.html","hash":"e6bcd180097b1062796e88cb916d39ea16e3858b","modified":1652890932953},{"_id":"public/archives/2016/index.html","hash":"844a471063e820a8f0b6254c427b7ad528fa4e61","modified":1652890932953},{"_id":"public/archives/2016/03/index.html","hash":"5f848ea2ae1e38f8470eb5b8b7ee6d1a6c7b5548","modified":1652890932953},{"_id":"public/archives/2016/04/index.html","hash":"99e3574e11852d8b6a68e16a59b80f2648c99286","modified":1652890932953},{"_id":"public/archives/2016/05/index.html","hash":"3033b2cd8d1037e1578474bb75f9289cf5675eba","modified":1652890932953},{"_id":"public/archives/2016/09/index.html","hash":"ec4e72b44d21e5bf45500ac0f6ecfda28cfd6923","modified":1652890932953},{"_id":"public/archives/2016/10/index.html","hash":"69f9b1dc95690f5ab81e5cb5bf9fb2070b530ba1","modified":1652890932953},{"_id":"public/archives/2016/11/index.html","hash":"26e1f974cebd4f04c6b31e2f3ae41c27c3d42a25","modified":1652890932953},{"_id":"public/archives/2017/index.html","hash":"d3c6fa60f2f0d3b46db382f328f34dce06c6bae4","modified":1652890932953},{"_id":"public/archives/2017/01/index.html","hash":"052b57c2b46ffc33274331d2735ff9e003eac63d","modified":1652890932953},{"_id":"public/archives/2017/04/index.html","hash":"9f8eabc7828903efbad935972ad1278ea2bd3bcc","modified":1652890932953},{"_id":"public/archives/2017/05/index.html","hash":"96494f9dcb0b6b73fb419dd7c12e9693208a255c","modified":1652890932953},{"_id":"public/archives/2020/index.html","hash":"ced730f9ea9098bc6b8110596d79e3744ccd67ab","modified":1652890932953},{"_id":"public/archives/2020/12/index.html","hash":"2ecbe8b64dce4604033cb7af0d4ab70223d7b7cf","modified":1652890932953},{"_id":"public/archives/2021/index.html","hash":"0ff456c740184e9a5de6e547450fe8893d5b9e85","modified":1652890932953},{"_id":"public/archives/2021/12/index.html","hash":"6151c0358fbe85ff9dab0dc6bb4fcbeaf8764874","modified":1652890932953},{"_id":"public/categories/自言语/index.html","hash":"50a6962ce636e159e2a73dd4ae237455a3c4b95f","modified":1652890932953},{"_id":"public/categories/技术向/index.html","hash":"cfa713fe95ca73e04101f4a7065d5c8c69ddd65d","modified":1652890932953},{"_id":"public/categories/事件簿/index.html","hash":"c4a068a7d616994baaafd8e2c46661e0b7240268","modified":1652890932953},{"_id":"public/categories/分享集/index.html","hash":"7cc8c384b4eb080bd38881b66545eb5c30897c22","modified":1652890932953},{"_id":"public/page/2/index.html","hash":"42c5e89b298b3de6226cb832ab0b0851dea3c860","modified":1652890932953},{"_id":"public/404.html","hash":"18f2f48d30eca50e03dccdb4c3982f11dd3b3328","modified":1652890932953},{"_id":"public/tags/index.html","hash":"acce4ff09b1cbeb564353c3130a572f3782bf1f1","modified":1652890932953},{"_id":"public/categories/index.html","hash":"aac350546011f3c274186caee92b86f7a1989376","modified":1652890932953},{"_id":"public/links/index.html","hash":"887c195959e81ebab6b2791b199b2e6fabe00b43","modified":1652890932953},{"_id":"public/2020/12/30/Linux中用gdb 查看代码堆栈的信息/index.html","hash":"2d73eb4f8319d3deb65434560d07961f4e49187b","modified":1652890932953},{"_id":"public/2017/04/25/进击的Tensorflow/index.html","hash":"45f02d6712b8a5e03e017d9205c17b63971c099e","modified":1652890932953},{"_id":"public/2017/01/01/Hello2017/index.html","hash":"ec9c2b4d0af37358bb2c94cf57cf523656cbffce","modified":1652890932953},{"_id":"public/2016/11/18/PyMySQL/index.html","hash":"505db7cd44176893a1889443cf03708096dc4387","modified":1652890932953},{"_id":"public/2016/10/25/Python解释执行原理及过程/index.html","hash":"6b1064743ab5b62679698ffad7bc4c1130f1b2a3","modified":1652890932953},{"_id":"public/2016/09/19/语音特征参数MFCC提取过程详解/index.html","hash":"4ba854eb61a72ac95991717291f42ba38b7880a0","modified":1652890932953},{"_id":"public/2016/05/28/看南飞的孤雁，过境处依旧是聚散人间/index.html","hash":"4363efcb11ff05c12bfd27be9265292cb90b8b21","modified":1652890932953},{"_id":"public/2016/04/16/UbuntuKylin13.10下安装配置Theano/index.html","hash":"4872a6e83a234d9d12477c0406ca17db5f039c56","modified":1652890932953},{"_id":"public/index.html","hash":"d92e99f3657f9356efde126bb0b689395bafbef8","modified":1652890932953},{"_id":"public/img/avatar.JPG","hash":"2264f48dc2cb260835af839969a3ab93ad5d3650","modified":1652890932953},{"_id":"public/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1652890932953},{"_id":"public/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1652890932953},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1652890932953},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1652890932953},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1652890932953},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1652890932953},{"_id":"public/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":1652890932953},{"_id":"public/js/color-schema.js","hash":"2520c6459b544a4e965b838f8095e2a84390a43c","modified":1652890932953},{"_id":"public/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":1652890932953},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1652890932953},{"_id":"public/js/leancloud.js","hash":"4a787cfce27045aa0a92ec22e84f2ccf30cabc4c","modified":1652890932953},{"_id":"public/js/local-search.js","hash":"633f0142c657805359b0197f287e12ae4bcde731","modified":1652890932953},{"_id":"public/js/plugins.js","hash":"d058f30bd09b28769c4d8313428ff23dfc8d52dd","modified":1652890932953},{"_id":"public/js/utils.js","hash":"4a43f2700e91937650bef511fd438825b001c4c6","modified":1652890932953},{"_id":"public/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1652890932953},{"_id":"public/css/main.css","hash":"80b7c3dc3f47db8b700b4437bdf45706fe504f66","modified":1652890932953}],"Category":[{"name":"自言语","_id":"cl3bsl2ic00045awq4y5k45wg"},{"name":"技术向","_id":"cl3bsl2ii00095awqhvo038u8"},{"name":"事件簿","_id":"cl3bsl2ix000r5awqgirq0ga8"},{"name":"分享集","_id":"cl3bsl2iy000u5awq8suggwxb"}],"Data":[],"Page":[{"title":"about","date":"2021-11-21T13:47:32.000Z","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2021-11-21 21:47:32\nlayout: about\n---\n","updated":"2021-11-21T13:48:20.371Z","path":"about/index.html","comments":1,"_id":"cl3bsl2i000005awqf5r21w3c","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""},{"title":"category","date":"2021-12-06T15:31:56.000Z","_content":"","source":"category/index.md","raw":"---\ntitle: category\ndate: 2021-12-06 23:31:56\n---\n","updated":"2021-12-06T15:31:56.447Z","path":"category/index.html","comments":1,"layout":"page","_id":"cl3bsl2i900025awqhmk2aaya","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""},{"title":"tag","date":"2021-12-06T15:31:47.000Z","_content":"","source":"tag/index.md","raw":"---\ntitle: tag\ndate: 2021-12-06 23:31:47\n---\n","updated":"2021-12-06T15:31:47.167Z","path":"tag/index.html","comments":1,"layout":"page","_id":"cl3bsl2ie00055awq3pdccd9u","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""}],"Post":[{"title":"Hello 2017","date":"2017-01-01T15:55:47.000Z","thumbnail":"http://i2.muimg.com/567571/21b4d9a425855567.jpg","toc":null,"_content":"\n好久没写博客了，最近有点忙，无厘头的忙。趁着跨年之际，东想想，西写写。\n\n## 16年回顾与总结\n\n今年大学本科毕业了，以为会告别校园生活的我，结果又进入了另一个校园生活.无论如何开心生活就好。其实我也很羡慕那些已经入职后能财务自由的童鞋。一直觉得财务自由才能实现人格独立（虽然我现在人格也已经很独立了～但也还不够独立～）。读研这半年以来，感觉每一天都过一样，又感觉每一天都过得不一样。时间就给人这样一种感觉，你以为每一天都没变化，等你蓦然回首时，就发现一切都改变了。\n\n16年其实浓缩一下也就发生了两件事情，毕业＋升学。毕业给人的感觉一直是种感伤的存在，我到觉得这又何尝不是一个新的开始呢，挥一挥手，同过去的自己告别，开开心心的步入人生的下一阶段。其实这个一次次毕业，又何尝不是人生的一次次升华呢。从小学到高中，我在父母的羽翼下成长，也只活在社会一个一维平面里。大学接触了一些新的人和事，开始升华到二维的一个角度。大学毕业后就需要在这个立体的社会中开始打拼了。不论是否已经做好准备，都需要快速成长。正如那句话一样，＂剑未佩妥，出门已是江湖＂。在不舍昼夜的时间面前，即使再仓促，我们也必须手忙脚乱得要在这个社会中觅得一隅立足之地了。（p.s我在校园生活中的毕业还没彻底，等明年这个时间再回来补全感想～）\n\n然后，入学至今，已有半载。唯一的感觉就是知识面和看事物的角度扩宽了，也接触了一些本科阶段没有接触的新鲜事物。面对问题，也会先找找资料，归纳与探索下解决的方法，制定出解决问题的计划与步骤。而不是像以前一样，像无头苍蝇一样乱飞乱撞，靠运气解决问题是行不通的。感觉自己的心也能沉淀下来，做一些自己感兴趣的事情了。也一直觉得：人能做自己喜欢的事情是一种幸运，而喜欢自己做的事情才是一种幸福。自认为一个人一生的幸运值是有上限的，所以何不在幸运没有降临到自己头上时，也换个角度寻觅幸福呢？对于现在的研究方向，个人也觉得很新奇，有种接近科研的感觉［哈哈～］但其实我们两年时间也是比较鸡肋的，算了不管了，做好当下就好了。\n\n\n\n\n## 17年计划与展望\n\n17年其实也想做两件事就好，为毕业做好准备＋择一事以终老。首先得保证接下来这新的一年，能为毕业做好铺垫的。估计毕业论文也是在基于深度学习的语音处理领域，但是没能找准一个切入点进行深究，总是很被动，也总是在重复模仿别人的实验。纠结在那个几个网络模型之间。其实现在发觉数据预处理阶段还是蛮重要的，对于数据特征的提取是至关重要的。数据的特征能否很好的反应原始数据的特性，然后再选择合适的能映射到高层向量空间表示特征的网络模型，这将会直接影响最后的实验结果。\n任重而道远，上下求索吧。\n下半年就得找工作了，也是很重要的一个环节。相对于去年的这个时候，自己还是想找游戏开发岗来着，还学习了好一会儿Cocos2d。今年的自己有可能找PythonWeb开发了吧，最近也在学习Django，感觉有目标就是好，至少能够鞭策自己时刻努力着。但愿尘埃落定后的毕业去向，能够选择自己喜欢的一个行业与工种，就这样一直工作下去吧。不论辛劳与艰苦，我还是选择我喜欢的，也喜欢我所选择的。\nO(∩_∩)O哈哈~，希望自己在新的一年里天天开心，事事顺心~\n","source":"_posts/Hello2017.md","raw":"---\ntitle: Hello 2017\ndate: 2017-01-1 23:55:47\ncategories: 自言语\nthumbnail: http://i2.muimg.com/567571/21b4d9a425855567.jpg\ntoc:\n---\n\n好久没写博客了，最近有点忙，无厘头的忙。趁着跨年之际，东想想，西写写。\n\n## 16年回顾与总结\n\n今年大学本科毕业了，以为会告别校园生活的我，结果又进入了另一个校园生活.无论如何开心生活就好。其实我也很羡慕那些已经入职后能财务自由的童鞋。一直觉得财务自由才能实现人格独立（虽然我现在人格也已经很独立了～但也还不够独立～）。读研这半年以来，感觉每一天都过一样，又感觉每一天都过得不一样。时间就给人这样一种感觉，你以为每一天都没变化，等你蓦然回首时，就发现一切都改变了。\n\n16年其实浓缩一下也就发生了两件事情，毕业＋升学。毕业给人的感觉一直是种感伤的存在，我到觉得这又何尝不是一个新的开始呢，挥一挥手，同过去的自己告别，开开心心的步入人生的下一阶段。其实这个一次次毕业，又何尝不是人生的一次次升华呢。从小学到高中，我在父母的羽翼下成长，也只活在社会一个一维平面里。大学接触了一些新的人和事，开始升华到二维的一个角度。大学毕业后就需要在这个立体的社会中开始打拼了。不论是否已经做好准备，都需要快速成长。正如那句话一样，＂剑未佩妥，出门已是江湖＂。在不舍昼夜的时间面前，即使再仓促，我们也必须手忙脚乱得要在这个社会中觅得一隅立足之地了。（p.s我在校园生活中的毕业还没彻底，等明年这个时间再回来补全感想～）\n\n然后，入学至今，已有半载。唯一的感觉就是知识面和看事物的角度扩宽了，也接触了一些本科阶段没有接触的新鲜事物。面对问题，也会先找找资料，归纳与探索下解决的方法，制定出解决问题的计划与步骤。而不是像以前一样，像无头苍蝇一样乱飞乱撞，靠运气解决问题是行不通的。感觉自己的心也能沉淀下来，做一些自己感兴趣的事情了。也一直觉得：人能做自己喜欢的事情是一种幸运，而喜欢自己做的事情才是一种幸福。自认为一个人一生的幸运值是有上限的，所以何不在幸运没有降临到自己头上时，也换个角度寻觅幸福呢？对于现在的研究方向，个人也觉得很新奇，有种接近科研的感觉［哈哈～］但其实我们两年时间也是比较鸡肋的，算了不管了，做好当下就好了。\n\n\n\n\n## 17年计划与展望\n\n17年其实也想做两件事就好，为毕业做好准备＋择一事以终老。首先得保证接下来这新的一年，能为毕业做好铺垫的。估计毕业论文也是在基于深度学习的语音处理领域，但是没能找准一个切入点进行深究，总是很被动，也总是在重复模仿别人的实验。纠结在那个几个网络模型之间。其实现在发觉数据预处理阶段还是蛮重要的，对于数据特征的提取是至关重要的。数据的特征能否很好的反应原始数据的特性，然后再选择合适的能映射到高层向量空间表示特征的网络模型，这将会直接影响最后的实验结果。\n任重而道远，上下求索吧。\n下半年就得找工作了，也是很重要的一个环节。相对于去年的这个时候，自己还是想找游戏开发岗来着，还学习了好一会儿Cocos2d。今年的自己有可能找PythonWeb开发了吧，最近也在学习Django，感觉有目标就是好，至少能够鞭策自己时刻努力着。但愿尘埃落定后的毕业去向，能够选择自己喜欢的一个行业与工种，就这样一直工作下去吧。不论辛劳与艰苦，我还是选择我喜欢的，也喜欢我所选择的。\nO(∩_∩)O哈哈~，希望自己在新的一年里天天开心，事事顺心~\n","slug":"Hello2017","published":1,"updated":"2021-12-12T14:25:37.197Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3bsl2i500015awq96uf9d2e","content":"<p>好久没写博客了，最近有点忙，无厘头的忙。趁着跨年之际，东想想，西写写。</p>\n<h2 id=\"16年回顾与总结\"><a href=\"#16年回顾与总结\" class=\"headerlink\" title=\"16年回顾与总结\"></a>16年回顾与总结</h2><p>今年大学本科毕业了，以为会告别校园生活的我，结果又进入了另一个校园生活.无论如何开心生活就好。其实我也很羡慕那些已经入职后能财务自由的童鞋。一直觉得财务自由才能实现人格独立（虽然我现在人格也已经很独立了～但也还不够独立～）。读研这半年以来，感觉每一天都过一样，又感觉每一天都过得不一样。时间就给人这样一种感觉，你以为每一天都没变化，等你蓦然回首时，就发现一切都改变了。</p>\n<p>16年其实浓缩一下也就发生了两件事情，毕业＋升学。毕业给人的感觉一直是种感伤的存在，我到觉得这又何尝不是一个新的开始呢，挥一挥手，同过去的自己告别，开开心心的步入人生的下一阶段。其实这个一次次毕业，又何尝不是人生的一次次升华呢。从小学到高中，我在父母的羽翼下成长，也只活在社会一个一维平面里。大学接触了一些新的人和事，开始升华到二维的一个角度。大学毕业后就需要在这个立体的社会中开始打拼了。不论是否已经做好准备，都需要快速成长。正如那句话一样，＂剑未佩妥，出门已是江湖＂。在不舍昼夜的时间面前，即使再仓促，我们也必须手忙脚乱得要在这个社会中觅得一隅立足之地了。（p.s我在校园生活中的毕业还没彻底，等明年这个时间再回来补全感想～）</p>\n<p>然后，入学至今，已有半载。唯一的感觉就是知识面和看事物的角度扩宽了，也接触了一些本科阶段没有接触的新鲜事物。面对问题，也会先找找资料，归纳与探索下解决的方法，制定出解决问题的计划与步骤。而不是像以前一样，像无头苍蝇一样乱飞乱撞，靠运气解决问题是行不通的。感觉自己的心也能沉淀下来，做一些自己感兴趣的事情了。也一直觉得：人能做自己喜欢的事情是一种幸运，而喜欢自己做的事情才是一种幸福。自认为一个人一生的幸运值是有上限的，所以何不在幸运没有降临到自己头上时，也换个角度寻觅幸福呢？对于现在的研究方向，个人也觉得很新奇，有种接近科研的感觉［哈哈～］但其实我们两年时间也是比较鸡肋的，算了不管了，做好当下就好了。</p>\n<h2 id=\"17年计划与展望\"><a href=\"#17年计划与展望\" class=\"headerlink\" title=\"17年计划与展望\"></a>17年计划与展望</h2><p>17年其实也想做两件事就好，为毕业做好准备＋择一事以终老。首先得保证接下来这新的一年，能为毕业做好铺垫的。估计毕业论文也是在基于深度学习的语音处理领域，但是没能找准一个切入点进行深究，总是很被动，也总是在重复模仿别人的实验。纠结在那个几个网络模型之间。其实现在发觉数据预处理阶段还是蛮重要的，对于数据特征的提取是至关重要的。数据的特征能否很好的反应原始数据的特性，然后再选择合适的能映射到高层向量空间表示特征的网络模型，这将会直接影响最后的实验结果。<br>任重而道远，上下求索吧。<br>下半年就得找工作了，也是很重要的一个环节。相对于去年的这个时候，自己还是想找游戏开发岗来着，还学习了好一会儿Cocos2d。今年的自己有可能找PythonWeb开发了吧，最近也在学习Django，感觉有目标就是好，至少能够鞭策自己时刻努力着。但愿尘埃落定后的毕业去向，能够选择自己喜欢的一个行业与工种，就这样一直工作下去吧。不论辛劳与艰苦，我还是选择我喜欢的，也喜欢我所选择的。<br>O(∩_∩)O哈哈<del>，希望自己在新的一年里天天开心，事事顺心</del></p>\n","site":{"data":{}},"wordcount":1307,"excerpt":"","more":"<p>好久没写博客了，最近有点忙，无厘头的忙。趁着跨年之际，东想想，西写写。</p>\n<h2 id=\"16年回顾与总结\"><a href=\"#16年回顾与总结\" class=\"headerlink\" title=\"16年回顾与总结\"></a>16年回顾与总结</h2><p>今年大学本科毕业了，以为会告别校园生活的我，结果又进入了另一个校园生活.无论如何开心生活就好。其实我也很羡慕那些已经入职后能财务自由的童鞋。一直觉得财务自由才能实现人格独立（虽然我现在人格也已经很独立了～但也还不够独立～）。读研这半年以来，感觉每一天都过一样，又感觉每一天都过得不一样。时间就给人这样一种感觉，你以为每一天都没变化，等你蓦然回首时，就发现一切都改变了。</p>\n<p>16年其实浓缩一下也就发生了两件事情，毕业＋升学。毕业给人的感觉一直是种感伤的存在，我到觉得这又何尝不是一个新的开始呢，挥一挥手，同过去的自己告别，开开心心的步入人生的下一阶段。其实这个一次次毕业，又何尝不是人生的一次次升华呢。从小学到高中，我在父母的羽翼下成长，也只活在社会一个一维平面里。大学接触了一些新的人和事，开始升华到二维的一个角度。大学毕业后就需要在这个立体的社会中开始打拼了。不论是否已经做好准备，都需要快速成长。正如那句话一样，＂剑未佩妥，出门已是江湖＂。在不舍昼夜的时间面前，即使再仓促，我们也必须手忙脚乱得要在这个社会中觅得一隅立足之地了。（p.s我在校园生活中的毕业还没彻底，等明年这个时间再回来补全感想～）</p>\n<p>然后，入学至今，已有半载。唯一的感觉就是知识面和看事物的角度扩宽了，也接触了一些本科阶段没有接触的新鲜事物。面对问题，也会先找找资料，归纳与探索下解决的方法，制定出解决问题的计划与步骤。而不是像以前一样，像无头苍蝇一样乱飞乱撞，靠运气解决问题是行不通的。感觉自己的心也能沉淀下来，做一些自己感兴趣的事情了。也一直觉得：人能做自己喜欢的事情是一种幸运，而喜欢自己做的事情才是一种幸福。自认为一个人一生的幸运值是有上限的，所以何不在幸运没有降临到自己头上时，也换个角度寻觅幸福呢？对于现在的研究方向，个人也觉得很新奇，有种接近科研的感觉［哈哈～］但其实我们两年时间也是比较鸡肋的，算了不管了，做好当下就好了。</p>\n<h2 id=\"17年计划与展望\"><a href=\"#17年计划与展望\" class=\"headerlink\" title=\"17年计划与展望\"></a>17年计划与展望</h2><p>17年其实也想做两件事就好，为毕业做好准备＋择一事以终老。首先得保证接下来这新的一年，能为毕业做好铺垫的。估计毕业论文也是在基于深度学习的语音处理领域，但是没能找准一个切入点进行深究，总是很被动，也总是在重复模仿别人的实验。纠结在那个几个网络模型之间。其实现在发觉数据预处理阶段还是蛮重要的，对于数据特征的提取是至关重要的。数据的特征能否很好的反应原始数据的特性，然后再选择合适的能映射到高层向量空间表示特征的网络模型，这将会直接影响最后的实验结果。<br>任重而道远，上下求索吧。<br>下半年就得找工作了，也是很重要的一个环节。相对于去年的这个时候，自己还是想找游戏开发岗来着，还学习了好一会儿Cocos2d。今年的自己有可能找PythonWeb开发了吧，最近也在学习Django，感觉有目标就是好，至少能够鞭策自己时刻努力着。但愿尘埃落定后的毕业去向，能够选择自己喜欢的一个行业与工种，就这样一直工作下去吧。不论辛劳与艰苦，我还是选择我喜欢的，也喜欢我所选择的。<br>O(∩_∩)O哈哈<del>，希望自己在新的一年里天天开心，事事顺心</del></p>\n"},{"title":"Linux中用gdb 查看代码堆栈的信息","date":"2020-12-30T13:54:13.000Z","_content":"\n&emsp;&emsp;core dump 一般是在segmentation fault（段错误）的情况下产生的文件，需要通过ulimit来设置才会得到的。\n\n&emsp;&emsp;调试的话输入： gdb filename core\n\n&emsp;&emsp;其中，filename就是产生core文件的可执行文件，core就是产生的dump文件\n\n## 一、查看栈信息\n&emsp;&emsp;当程序被停住了，你需要做的第一件事就是查看程序是在哪里停住的。当你的程序调用了一个函数，函数的地址，函数参数，函数内的局部变量都会被压入“栈”（Stack）中。你可以用GDB命令来查看当前的栈中的信息。\n\n&emsp;&emsp;下面是一些查看函数调用栈信息的GDB命令：\n> backtrace/bt\n\n&emsp;&emsp;打印当前的函数调用栈的所有信息。如：\n```bash\n(gdb) bt\n#0 func (n=250) at tst.c:6\n#1 0x08048524 in main (argc=1, argv=0xbffff674) at tst.c:30\n#2 0x400409ed in __libc_start_main () from /lib/libc.so.6\n```\n\n&emsp;&emsp;从上可以看出函数的调用栈信息：__libc_start_main --> main()--> func()\n\n```bash\nbacktrace\n(bt)\nn是一个正整数，表示只打印栈顶上n层的栈信息。\n\nbacktrace <-n>\n\nbt <-n>\n\n-n表一个负整数，表示只打印栈底下n层的栈信息。\n```\n\n&emsp;&emsp;如果你要查看某一层的信息，你需要在切换当前的栈，一般来说，程序停止时，最顶层的栈就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是切换当前栈。\n\n```bash\nframe\nf\nn是一个从0开始的整数，是栈中的层编号。比如：frame 0，表示栈顶，frame 1，表示栈的第二层。\n\nup\n表示向栈的上面移动n层，可以不打n，表示向上移动一层。\n\ndown\n表示向栈的下面移动n层，可以不打n，表示向下移动一层。\n\n上面的命令，都会打印出移动到的栈层的信息。如果你不想让其打出信息。你可以使用这三个命令：\n\nselect-frame 对应于 frame 命令。\nup-silently 对应于 up 命令。\ndown-silently 对应于 down 命令。\n```\n\n\n&emsp;&emsp;查看当前栈层的信息，你可以用以下GDB命令：\n```bash\nframe 或 f\n会打印出这些信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。\n\ninfo frame\n\ninfo f\n\n这个命令会打印出更为详细的当前栈层的信息，只不过，大多数都是运行时的内内\n地址。比如：函数地址，调用函数的地址，被调用函数的地址，目前的函数是由什么\n样的程序语言写成的、函数参数地址及值、局部变量的地址等等。如：\n```\n\n```bash\n(gdb) info f\nStack level 0, frame at 0xbffff5d4:\neip = 0x804845d in func (tst.c:6); saved eip 0x8048524\ncalled by frame at 0xbffff60c\nsource language c.\nArglist at 0xbffff5d4, args: n=250\nLocals at 0xbffff5d4, Previous frame's sp is 0x0\nSaved registers:\nebp at 0xbffff5d4, eip at 0xbffff5d8\n```\n\n> info args  \n打印出当前函数的参数名及其值。\n\n> info locals  \n打印出当前函数中所有局部变量及其值。\n\n> info catch  \n打印出当前的函数中的异常处理信息。\n\n\n## 二、查看源程序\n\n### 2.1、显示源代码\n\n&emsp;&emsp;GDB 可以打印出所调试程序的源代码，当然，在程序编译时一定要加上-g的参数，把源程序信息编译到执行文件中。不然就看不到源程序了。当程序停下来以后，GDB会报告程序停在了那个文件的第几行上。你可以用list命令来打印程序的源代码。还是来看一看查看源代码的GDB命令吧。\n\n```bash\nlist\n显示程序第linenum行的周围的源程序。\n\nlist\n显示函数名为function的函数的源程序。\n\nlist\n显示当前行后面的源程序。\n\nlist -\n显示当前行前面的源程序。\n```\n\n&emsp;&emsp;一般是打印当前行的上5行和下5行，如果显示函数是是上2行下8行，默认是10行，当然，你也可以定制显示的范围，使用下面命令可以设置一次显示源程序的行数。\n```bash\nset listsize\n设置一次显示源代码的行数。\n\nshow listsize\n查看当前listsize的设置。\n\nlist命令还有下面的用法：\n\nlist ,\n显示从first行到last行之间的源代码。\n\nlist ,\n显示从当前行到last行之间的源代码。\n\nlist +\n往后显示源代码。\n```\n\n&emsp;&emsp;一般来说在list后面可以跟以下这们的参数：\n```bash\n行号。\n<+offset> 当前行号的正偏移量。\n<-offset> 当前行号的负偏移量。\n哪个文件的哪一行。\n函数名。\n哪个文件中的哪个函数。\n<*address> 程序运行时的语句在内存中的地址。\n```\n\n### 2.2、搜索源代码\n\n不仅如此，GDB还提供了源代码搜索的命令：\n\nforward-search\nsearch\n向前面搜索。\n\nreverse-search\n全部搜索。\n\n其中，就是正则表达式，也主一个字符串的匹配模式，关于正则表达式，我就不在这里讲了，还请各位查看相关资料。\n\n\n### 2.3、指定源文件的路径\n\n&emsp;&emsp;某些时候，用-g编译过后的执行程序中只是包括了源文件的名字，没有路径名。GDB提供了可以让你指定源文件的路径的命令，以便GDB进行搜索。\ndirectory\ndir\n加一个源文件路径到当前路径的前面。如果你要指定多个路径，UNIX下你可以使用“:”，Windows下你可以使用“;”。\ndirectory\n清除所有的自定义的源文件搜索路径信息。\n\nshow directories\n显示定义了的源文件搜索路径。\n\n### 2.4、源代码的内存\n\n&emsp;&emsp;你可以使用info line命令来查看源代码在内存中的地址。info line后面可以跟“行号”，“函数名”，“文件名:行号”，“文件名:函数名”，这个命令会打印出所指定的源码在运行时的内存地址，如：\n\n```bash\n(gdb) info line tst.c:func\nLine 5 of \"tst.c\" starts at address 0x8048456 and ends at 0x804845d.\n```\n\n&emsp;&emsp;还有一个命令（disassemble）你可以查看源程序的当前执行时的机器码，这个命令会把目前内存中的指令dump出来。如下面的示例表示查看函数func的汇编代码。\n\n```bash\n(gdb) disassemble func\nDump of assembler code for function func:\n0x8048450 : push %ebp\n0x8048451 : mov %esp,%ebp\n0x8048453 : sub $0x18,%esp\n0x8048456 : movl $0x0,0xfffffffc(%ebp)\n0x804845d : movl $0x1,0xfffffff8(%ebp)\n0x8048464 : mov 0xfffffff8(%ebp),%eax\n0x8048467 : cmp 0x8(%ebp),%eax\n0x804846a : jle 0x8048470\n0x804846c : jmp 0x8048480\n0x804846e : mov %esi,%esi\n0x8048470 : mov 0xfffffff8(%ebp),%eax\n0x8048473 : add %eax,0xfffffffc(%ebp)\n0x8048476 : incl 0xfffffff8(%ebp)\n0x8048479 : jmp 0x8048464\n0x804847b : nop\n0x804847c : lea 0x0(%esi,1),%esi\n0x8048480 : mov 0xfffffffc(%ebp),%edx\n0x8048483 : mov %edx,%eax\n0x8048485 : jmp 0x8048487\n0x8048487 : mov %ebp,%esp\n0x8048489 : pop %ebp\n0x804848a : ret\nEnd of assembler dump.\n```\n\n## 三、查看运行时数据\n&emsp;&emsp;在你调试程序时，当程序被停住时，你可以使用print命令（简写命令为p），或是同义命令inspect来查看当前程序的运行数据。print命令的格式是：\n\nprint\nprint /\n是表达式，是你所调试的程序的语言的表达式（GDB可以调试多种编程语言），是输出的格式，比如，如果要把表达式按16进制的格式输出，那么就是/x。\n\n\n### 3.1、表达式\n\n&emsp;&emsp;print和许多GDB的命令一样，可以接受一个表达式，GDB会根据当前的程序运行的数据来计算这个表达式，既然是表达式，那么就可以是当前程序运行中的const常量、变量、函数等内容。可惜的是GDB不能使用你在程序中所定义的宏。\n\n&emsp;&emsp;表达式的语法应该是当前所调试的语言的语法，由于C/C++是一种大众型的语言，所以，本文中的例子都是关于C/C++的。（而关于用GDB调试其它语言的章节，我将在后面介绍）\n\n&emsp;&emsp;在表达式中，有几种GDB所支持的操作符，它们可以用在任何一种语言中。\n```bash\n@\n是一个和数组有关的操作符，在后面会有更详细的说明。\n\n::\n指定一个在文件或是一个函数中的变量。\n\n{}\n表示一个指向内存地址的类型为type的一个对象。\n```\n\n\n### 3.2、程序变量\n\n&emsp;&emsp;在GDB中，你可以随时查看以下三种变量的值：\n- 1、全局变量（所有文件可见的）\n- 2、静态全局变量（当前文件可见的）\n- 3、局部变量（当前Scope可见的）\n\n&emsp;&emsp;如果你的局部变量和全局变量发生冲突（也就是重名），一般情况下是局部变量会隐藏全局变量，也就是说，如果一个全局变量和一个函数中的局部变量同名时，如果当前停止点在函数中，用print显示出的变量的值会是函数中的局部变量的值。如果此时你想查看全局变量的值时，你可以使用“::”操作符：\n\n```bash\nfile::variable\nfunction::variable\n可以通过这种形式指定你所想查看的变量，是哪个文件中的或是哪个函数中的。例如，查看文件f2.c中的全局变量x的值：\n\n(gdb) p 'f2.c'::x\n\n当然，“::”操作符会和C++中的发生冲突，GDB能自动识别“::”是否C++的操作符，所以你不必担心在调试C++程序时会出现异常。\n```\n\n&emsp;&emsp;另外，需要注意的是，如果你的程序编译时开启了优化选项，那么在用GDB调试被优化过的程序时，可能会发生某些变量不能访问，或是取值错误码的情况。这个是很正常的，因为优化程序会删改你的程序，整理你程序的语句顺序，剔除一些无意义的\n变量等，所以在GDB调试这种程序时，运行时的指令和你所编写指令就有不一样，也\n就会出现你所想象不到的结果。对付这种情况时，需要在编译程序时关闭编译优化。\n一般来说，几乎所有的编译器都支持编译优化的开关，例如，GNU 的C/C++编译器\nGCC，你可以使用“-gstabs”选项来解决这个问题。关于编译器的参数，还请查看编\n译器的使用说明文档。\n\n### 3.3、数组\n\n&emsp;&emsp;有时候，你需要查看一段连续的内存空间的值。比如数组的一段，或是动态分配的数据的大小。你可以使用GDB的“@”操作符，“@”的左边是第一个内存的地址的\n值，“@”的右边则你你想查看内存的长度。例如，你的程序中有这样的语句：\n```C\nint *array = (int *) malloc (len * sizeof (int));\n```\n\n&emsp;&emsp;于是，在GDB调试过程中，你可以以如下命令显示出这个动态数组的取值：\n```C\np *array@len\n```\n\n&emsp;&emsp;@的左边是数组的首地址的值，也就是变量array所指向的内容，右边则是数据的长度，其保存在变量len中，其输出结果，大约是下面这个样子的：\n```bash\n(gdb) p *array@len\n$1 = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32,34, 36, 38, 40}\n```\n\n&emsp;&emsp;如果是静态数组的话，可以直接用print数组名，就可以显示数组中所有数据的内容了。\n\n\n### 3.4、输出格式\n\n&emsp;&emsp;一般来说，GDB会根据变量的类型输出变量的值。但你也可以自定义GDB的输出的格式。例如，你想输出一个整数的十六进制，或是二进制来查看这个整型变量的中的\n位的情况。要做到这样，你可以使用GDB的数据显示格式：\n\nx 按十六进制格式显示变量。\nd 按十进制格式显示变量。\nu 按十六进制格式显示无符号整型。\no 按八进制格式显示变量。\nt 按二进制格式显示变量。\na 按十六进制格式显示变量。\nc 按字符格式显示变量。\nf 按浮点数格式显示变量。\n\n```bash\n(gdb) p i\n$21 = 101\n\n(gdb) p/a i\n$22 = 0x65\n\n(gdb) p/c i\n$23 = 101 'e'\n\n(gdb) p/f i\n$24 = 1.41531145e-43\n\n(gdb) p/x i\n$25 = 0x65\n\n(gdb) p/t i\n$26 = 1100101\n```\n\n### 3.5、查看内存\n\n&emsp;&emsp;你可以使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：\n```bash\nx/\n\nn、f、u是可选的参数。\n```\n\nn 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。\nf 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是指令地址，那么格式可以是i。\nu 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。\n \nu参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。\n\n&emsp;&emsp;当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。\n\n&emsp;&emsp;表示一个内存地址。\n\nn/f/u三个参数可以一起使用。例如：\n\n命令：x/3uh 0x54320表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。\n\n\n### 3.6、自动显示\n\n&emsp;&emsp;你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display。\n\n```bash\ndisplay\ndisplay/\ndisplay/\n```\n\nexpr是一个表达式，fmt表示显示的格式，addr表示内存地址，当你用display设定好了一个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值。\n\n格式i和s同样被display支持，一个非常有用的命令是：\n```bash\ndisplay/i $pc\n```\n\n$pc是GDB的环境变量，表示着指令的地址，/i则表示输出格式为机器指令码，也就是汇编。于是当程序停下后，就会出现源代码和机器指令码相对应的情形，这是一个很有意思的功能。\n\n下面是一些和display相关的GDB命令：\n\nundisplay\ndelete display\n删除自动显示，dnums意为所设置好了的自动显式的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5）\n\ndisable display\nenable display\ndisable和enalbe不删除自动显示的设置，而只是让其失效和恢复。\n\ninfo display\n查看display设置的自动显示的信息。GDB会打出一张表格，向你报告当然调试中设置了多少个自动显示设置，其中包括，设置的编号，表达式，是否enable。\n\n### 3.7、设置显示选项\n\n&emsp;&emsp;GDB中关于显示的选项比较多，这里我只例举大多数常用的选项。\n- set print address\n- set print address on\n  \n&emsp;&emsp;打开地址输出，当程序显示函数信息时，GDB会显出函数的参数地址。系统默认为打开的，如：\n```bash\n(gdb) f\n#0 set_quotes (lq=0x34c78 \"<<\",rq=0x34c88 \">>\")\nat input.c:530\n530 if (lquote != def_lquote)\n\n\nset print address off\n关闭函数的参数地址显示，如：\n\n(gdb) set print addr off\n(gdb) f\n#0 set_quotes (lq=\"<<\",rq=\">>\") at input.c:530\n530 if (lquote != def_lquote)\n\nshow print address\n查看当前地址显示选项是否打开。\n\nset print array\nset print array on\n打开数组显示，打开后当数组显示时，每个元素占一行，如果不打开的话，每个元素则以逗号分隔。这个选项默认是关闭的。与之相关的两个命令如下，我就不再多说了。\n\nset print array off\nshow print array\n\nset print elements\n这个选项主要是设置数组的，如果你的数组太大了，那么就可以指定一个来指定数据显示的最大长度，当到达这个长度时，GDB就不再往下显示了。如果设置为0，则表示不限制。\n\nshow print elements\n查看print elements的选项信息。\n\nset print null-stop\n如果打开了这个选项，那么当显示字符串时，遇到结束符则停止显示。这个选项默认为off。\n\nset print pretty on\n如果打开printf pretty这个选项，那么当GDB显示结构体时会比较漂亮。如：\n\n$1 = {\nnext = 0x0,\nflags = {\nsweet = 1,\nsour = 1\n},\nmeat = 0x54 \"Pork\"\n}\n\nset print pretty off\n关闭printf pretty这个选项，GDB显示结构体时会如下显示：\n\n$1 = {next = 0x0, flags = {sweet = 1, sour = 1}, meat = 0x54\"Pork\"}\n\nshow print pretty\n查看GDB是如何显示结构体的。\n\n\nset print sevenbit-strings\n设置字符显示，是否按“\\nnn”的格式显示，如果打开，则字符串或字符数据按\\nnn显示，如“\\065”。\n\nshow print sevenbit-strings\n查看字符显示开关是否打开。\n\nset print union\n设置显示结构体时，是否显式其内的联合体数据。例如有以下数据结构：\n\ntypedef enum {Tree, Bug} Species;\ntypedef enum {Big_tree, Acorn, Seedling} Tree_forms;\ntypedef enum {Caterpillar, Cocoon, Butterfly}\nBug_forms;\n\nstruct thing {\nSpecies it;\nunion {\nTree_forms tree;\nBug_forms bug;\n} form;\n};\n\nstruct thing foo = {Tree, {Acorn}};\n\n当打开这个开关时，执行 p foo 命令后，会如下显示：\n$1 = {it = Tree, form = {tree = Acorn, bug = Cocoon}}\n\n当关闭这个开关时，执行 p foo 命令后，会如下显示：\n$1 = {it = Tree, form = {...}}\n\nshow print union\n查看联合体数据的显示方式\n\nset print object\n在C++中，如果一个对象指针指向其派生类，如果打开这个选项，GDB会自动按照虚方法调用的规则显示输出，如果关闭这个选项的话，GDB就不管虚函数表了。这个选项默认是off。\n\nshow print object\n查看对象选项的设置。\n\nset print static-members\n这个选项表示，当显示一个C++对象中的内容是，是否显示其中的静态数据成员。默认是on。\n\nshow print static-members\n查看静态数据成员选项设置。\n\nset print vtbl\n当此选项打开时，GDB将用比较规整的格式来显示虚函数表时。其默认是关闭的。\n\nshow print vtbl\n查看虚函数显示格式的选项。\n```\n\n### 3.8、历史记录\n\n&emsp;&emsp;当你用GDB的print查看程序运行时的数据时，你每一个print都会被GDB记录下来。\n&emsp;&emsp;GDB会以$1, $2, $3 .....这样的方式为你每一个print命令编上号。于是，你可以使用这个编号访问以前的表达式，如$1。这个功能所带来的好处是，如果你先前输入了一个比较长的表达式，如果你还想查看这个表达式的值，你可以使用历史记录\n来访问，省去了重复输入。\n\n\n### 3.9、GDB环境变量\n\n&emsp;&emsp;你可以在GDB的调试环境中定义自己的变量，用来保存一些调试程序中的运行数据。要定义一个GDB的变量很简单只需。使用GDB的set命令。GDB的环境变量和UNIX一样，也是以$起头。如：\n\n> set $foo = *object_ptr\n\n&emsp;&emsp;使用环境变量时，GDB会在你第一次使用时创建这个变量，而在以后的使用中，则直接对其賦值。环境变量没有类型，你可以给环境变量定义任一的类型。包括结构体和数组。\n\n> show convenience  \n//该命令查看当前所设置的所有的环境变量。\n\n&emsp;&emsp;这是一个比较强大的功能，环境变量和程序变量的交互使用，将使得程序调试更为灵活便捷。例如：\n\n> set $i = 0\n> \n> print bar[$i++]->contents\n\n&emsp;&emsp;于是，当你就不必，print bar[0]->contents, printbar[1]->contents地输入命令了。输入这样的命令后，只用敲回车，重复执行上一条语句，环境变量会自动累加，从而完成逐个输出的功能。\n\n\n### 3.10、查看寄存器\n\n&emsp;&emsp;要查看寄存器的值，很简单，可以使用如下命令：\n\n> info registers  \n//查看寄存器的情况。（除了浮点寄存器）\n\n> info all-registers  \n查看所有寄存器的情况。（包括浮点寄存器）\n\n> info registers  \n查看所指定的寄存器的情况。\n\n&emsp;&emsp;寄存器中放置了程序运行时的数据，比如程序当前运行的指令地址（ip），程序的当前堆栈地址（sp）等等。你同样可以使用print命令来访问寄存器的情况，只需要在寄存器名字前加一个$符号就可以了。如：p $eip。\n\n## 四、改变程序的执行\n\n&emsp;&emsp;一旦使用GDB挂上被调试程序，当程序运行起来后，你可以根据自己的调试思路来动态地在GDB中更改当前被调试程序的运行线路或是其变量的值，这个强大的功能能够让你更好的调试你的程序，比如，你可以在程序的一次运行中走遍程序的所有分支。\n\n\n### 4.1、修改变量值\n\n&emsp;&emsp;修改被调试程序运行时的变量值，在GDB中很容易实现，使用GDB的print命令即可完成。如：\n\n```bash\n(gdb) print x=4\n\nx=4这个表达式是C/C++的语法，意为把变量x的值修改为4，如果你当前调试的语言是Pascal，那么你可以使用Pascal的语法：x:=4。\n\n在某些时候，很有可能你的变量和GDB中的参数冲突，如：\n\n(gdb) whatis width\ntype = double\n(gdb) p width\n$4 = 13\n(gdb) set width=47\nInvalid syntax in expression.\n\n因为，set width是GDB的命令，所以，出现了“Invalid syntax inexpression”的设置错误，此时，你可以使用setvar命令来告诉GDB，width不是你GDB的参数，而是程序的变量名，如：\n\n(gdb) set var width=47\n\n另外，还可能有些情况，GDB并不报告这种错误，所以保险起见，在你改变程序变量取值时，最好都使用setvar格式的GDB命令。\n```\n\n### 4.2、跳转执行\n\n&emsp;&emsp;一般来说，被调试程序会按照程序代码的运行顺序依次执行。GDB提供了乱序执行的功能，也就是说，GDB可以修改程序的执行顺序，可以让程序执行随意跳跃。这个功能可以由GDB的jump命令来完：\n\njump\n指定下一条语句的运行点。可以是文件的行号，可以是file:line格式，可以是+num这种偏移量格式。表式着下一条运行语句从哪里开始。\n\njump\n\n这里的是代码行的内存地址。\n\n&emsp;&emsp;注意，jump命令不会改变当前的程序栈中的内容，所以，当你从一个函数跳到另一个函数时，当函数运行完返回时进行弹栈操作时必然会发生错误，可能结果还是非常\n奇怪的，甚至于产生程序Core Dump。所以最好是同一个函数中进行跳转。\n\n&emsp;&emsp;熟悉汇编的人都知道，程序运行时，有一个寄存器用于保存当前代码所在的内存地址。所以，jump命令也就是改变了这个寄存器中的值。于是，你可以使用“set $pc”来更改跳转执行的地址。如：\n```bash\nset $pc = 0x485\n```\n\n\n### 4.3、产生信号量\n\n&emsp;&emsp;使用singal命令，可以产生一个信号量给被调试的程序。如：中断信号Ctrl+C。这非常方便于程序的调试，可以在程序运行的任意位置设置断点，并在该断点用GDB产生一个信号量，这种精确地在某处产生信号非常有利程序的调试。\n\n&emsp;&emsp;语法是：signal ，UNIX的系统信号量通常从1到15。所以取值也在这个范围。\n\n&emsp;&emsp;single命令和shell的kill命令不同，系统的kill命令发信号给被调试程序时，是由GDB截获的，而single命令所发出一信号则是直接发给被调试程序的。\n\n### 4.4、强制函数返回\n\n&emsp;&emsp;如果你的调试断点在某个函数中，并还有语句没有执行完。你可以使用return命令强制函数忽略还没有执行的语句并返回。\n\nreturn\nreturn\n&emsp;&emsp;使用return命令取消当前函数的执行，并立即返回，如果指定了，那么该表达式的值会被认作函数的返回值。\n\n\n### 4.5、强制调用函数\n```bash\ncall\n```\n\n&emsp;&emsp;表达式中可以一是函数，以此达到强制调用函数的目的。并显示函数的返回值，如果函数返回值是void，那么就不显示。\n\n&emsp;&emsp;另一个相似的命令也可以完成这一功能——print，print后面可以跟表达式，所以也可以用他来调用函数，print和call的不同是，如果函数返回void，call则不显示，print则显示函数返回值，并把该值存入历史数据中。\n\n## 五、在不同语言中使用GDB\n\n&emsp;&emsp;GDB支持下列语言：C, C++, Fortran, PASCAL, Java, Chill, assembly, 和Modula-2。一般说来，GDB会根据你所调试的程序来确定当然的调试语言，比如：发现文件名后缀为“.c”的，GDB会认为是C程序。文件名后缀为 “.C, .cc, .cp, .cpp, .cxx, .c++”的，GDB会认为是C++程序。而后缀是“.f, .F”的，GDB会认为是Fortran程序，还有，后缀为如果是“.s, .S”的会认为是汇编语言。\n\n&emsp;&emsp;也就是说，GDB会根据你所调试的程序的语言，来设置自己的语言环境，并让GDB的命令跟着语言环境的改变而改变。比如一些GDB命令需要用到表达式或变量时，这些\n表达式或变量的语法，完全是根据当前的语言环境而改变的。例如C/C++中对指针\n的语法是*p，而在Modula-2中则是p^。并且，如果你当前的程序是由几种不同语言\n一同编译成的，那到在调试过程中，GDB也能根据不同的语言自动地切换语言环境。\n这种跟着语言环境而改变的功能，真是体贴开发人员的一种设计。\n\n\n&emsp;&emsp;下面是几个相关于GDB语言环境的命令：\n\n```bash\nshow language\n查看当前的语言环境。如果GDB不能识为你所调试的编程语言，那么，C语言被认为是默认的环境。\n\ninfo frame\n查看当前函数的程序语言。\n\ninfo source\n查看当前文件的程序语言。\n```\n\n如果GDB没有检测出当前的程序语言，那么你也可以手动设置当前的程序语言。使用set language命令即可做到。\n\n当set language命令后什么也不跟的话，你可以查看GDB所支持的语言种类：\n```bash\n(gdb) set language\nThe currently understood settings are:\n\nlocal or auto Automatic setting based on source file\nc Use the C language\nc++ Use the C++ language\nasm Use the Asm language\nchill Use the Chill language\nfortran Use the Fortran language\njava Use the Java language\nmodula-2 Use the Modula-2 language\npascal Use the Pascal language\nscheme Use the Scheme language\n```\n\n&emsp;&emsp;于是你可以在set language后跟上被列出来的程序语言名，来设置当前的语言环境。\n","source":"_posts/Linux中用gdb 查看代码堆栈的信息.md","raw":"---\ntitle: Linux中用gdb 查看代码堆栈的信息\ndate: 2020-12-30 21:54:13\ntags:\ncategories: 技术向\n---\n\n&emsp;&emsp;core dump 一般是在segmentation fault（段错误）的情况下产生的文件，需要通过ulimit来设置才会得到的。\n\n&emsp;&emsp;调试的话输入： gdb filename core\n\n&emsp;&emsp;其中，filename就是产生core文件的可执行文件，core就是产生的dump文件\n\n## 一、查看栈信息\n&emsp;&emsp;当程序被停住了，你需要做的第一件事就是查看程序是在哪里停住的。当你的程序调用了一个函数，函数的地址，函数参数，函数内的局部变量都会被压入“栈”（Stack）中。你可以用GDB命令来查看当前的栈中的信息。\n\n&emsp;&emsp;下面是一些查看函数调用栈信息的GDB命令：\n> backtrace/bt\n\n&emsp;&emsp;打印当前的函数调用栈的所有信息。如：\n```bash\n(gdb) bt\n#0 func (n=250) at tst.c:6\n#1 0x08048524 in main (argc=1, argv=0xbffff674) at tst.c:30\n#2 0x400409ed in __libc_start_main () from /lib/libc.so.6\n```\n\n&emsp;&emsp;从上可以看出函数的调用栈信息：__libc_start_main --> main()--> func()\n\n```bash\nbacktrace\n(bt)\nn是一个正整数，表示只打印栈顶上n层的栈信息。\n\nbacktrace <-n>\n\nbt <-n>\n\n-n表一个负整数，表示只打印栈底下n层的栈信息。\n```\n\n&emsp;&emsp;如果你要查看某一层的信息，你需要在切换当前的栈，一般来说，程序停止时，最顶层的栈就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是切换当前栈。\n\n```bash\nframe\nf\nn是一个从0开始的整数，是栈中的层编号。比如：frame 0，表示栈顶，frame 1，表示栈的第二层。\n\nup\n表示向栈的上面移动n层，可以不打n，表示向上移动一层。\n\ndown\n表示向栈的下面移动n层，可以不打n，表示向下移动一层。\n\n上面的命令，都会打印出移动到的栈层的信息。如果你不想让其打出信息。你可以使用这三个命令：\n\nselect-frame 对应于 frame 命令。\nup-silently 对应于 up 命令。\ndown-silently 对应于 down 命令。\n```\n\n\n&emsp;&emsp;查看当前栈层的信息，你可以用以下GDB命令：\n```bash\nframe 或 f\n会打印出这些信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。\n\ninfo frame\n\ninfo f\n\n这个命令会打印出更为详细的当前栈层的信息，只不过，大多数都是运行时的内内\n地址。比如：函数地址，调用函数的地址，被调用函数的地址，目前的函数是由什么\n样的程序语言写成的、函数参数地址及值、局部变量的地址等等。如：\n```\n\n```bash\n(gdb) info f\nStack level 0, frame at 0xbffff5d4:\neip = 0x804845d in func (tst.c:6); saved eip 0x8048524\ncalled by frame at 0xbffff60c\nsource language c.\nArglist at 0xbffff5d4, args: n=250\nLocals at 0xbffff5d4, Previous frame's sp is 0x0\nSaved registers:\nebp at 0xbffff5d4, eip at 0xbffff5d8\n```\n\n> info args  \n打印出当前函数的参数名及其值。\n\n> info locals  \n打印出当前函数中所有局部变量及其值。\n\n> info catch  \n打印出当前的函数中的异常处理信息。\n\n\n## 二、查看源程序\n\n### 2.1、显示源代码\n\n&emsp;&emsp;GDB 可以打印出所调试程序的源代码，当然，在程序编译时一定要加上-g的参数，把源程序信息编译到执行文件中。不然就看不到源程序了。当程序停下来以后，GDB会报告程序停在了那个文件的第几行上。你可以用list命令来打印程序的源代码。还是来看一看查看源代码的GDB命令吧。\n\n```bash\nlist\n显示程序第linenum行的周围的源程序。\n\nlist\n显示函数名为function的函数的源程序。\n\nlist\n显示当前行后面的源程序。\n\nlist -\n显示当前行前面的源程序。\n```\n\n&emsp;&emsp;一般是打印当前行的上5行和下5行，如果显示函数是是上2行下8行，默认是10行，当然，你也可以定制显示的范围，使用下面命令可以设置一次显示源程序的行数。\n```bash\nset listsize\n设置一次显示源代码的行数。\n\nshow listsize\n查看当前listsize的设置。\n\nlist命令还有下面的用法：\n\nlist ,\n显示从first行到last行之间的源代码。\n\nlist ,\n显示从当前行到last行之间的源代码。\n\nlist +\n往后显示源代码。\n```\n\n&emsp;&emsp;一般来说在list后面可以跟以下这们的参数：\n```bash\n行号。\n<+offset> 当前行号的正偏移量。\n<-offset> 当前行号的负偏移量。\n哪个文件的哪一行。\n函数名。\n哪个文件中的哪个函数。\n<*address> 程序运行时的语句在内存中的地址。\n```\n\n### 2.2、搜索源代码\n\n不仅如此，GDB还提供了源代码搜索的命令：\n\nforward-search\nsearch\n向前面搜索。\n\nreverse-search\n全部搜索。\n\n其中，就是正则表达式，也主一个字符串的匹配模式，关于正则表达式，我就不在这里讲了，还请各位查看相关资料。\n\n\n### 2.3、指定源文件的路径\n\n&emsp;&emsp;某些时候，用-g编译过后的执行程序中只是包括了源文件的名字，没有路径名。GDB提供了可以让你指定源文件的路径的命令，以便GDB进行搜索。\ndirectory\ndir\n加一个源文件路径到当前路径的前面。如果你要指定多个路径，UNIX下你可以使用“:”，Windows下你可以使用“;”。\ndirectory\n清除所有的自定义的源文件搜索路径信息。\n\nshow directories\n显示定义了的源文件搜索路径。\n\n### 2.4、源代码的内存\n\n&emsp;&emsp;你可以使用info line命令来查看源代码在内存中的地址。info line后面可以跟“行号”，“函数名”，“文件名:行号”，“文件名:函数名”，这个命令会打印出所指定的源码在运行时的内存地址，如：\n\n```bash\n(gdb) info line tst.c:func\nLine 5 of \"tst.c\" starts at address 0x8048456 and ends at 0x804845d.\n```\n\n&emsp;&emsp;还有一个命令（disassemble）你可以查看源程序的当前执行时的机器码，这个命令会把目前内存中的指令dump出来。如下面的示例表示查看函数func的汇编代码。\n\n```bash\n(gdb) disassemble func\nDump of assembler code for function func:\n0x8048450 : push %ebp\n0x8048451 : mov %esp,%ebp\n0x8048453 : sub $0x18,%esp\n0x8048456 : movl $0x0,0xfffffffc(%ebp)\n0x804845d : movl $0x1,0xfffffff8(%ebp)\n0x8048464 : mov 0xfffffff8(%ebp),%eax\n0x8048467 : cmp 0x8(%ebp),%eax\n0x804846a : jle 0x8048470\n0x804846c : jmp 0x8048480\n0x804846e : mov %esi,%esi\n0x8048470 : mov 0xfffffff8(%ebp),%eax\n0x8048473 : add %eax,0xfffffffc(%ebp)\n0x8048476 : incl 0xfffffff8(%ebp)\n0x8048479 : jmp 0x8048464\n0x804847b : nop\n0x804847c : lea 0x0(%esi,1),%esi\n0x8048480 : mov 0xfffffffc(%ebp),%edx\n0x8048483 : mov %edx,%eax\n0x8048485 : jmp 0x8048487\n0x8048487 : mov %ebp,%esp\n0x8048489 : pop %ebp\n0x804848a : ret\nEnd of assembler dump.\n```\n\n## 三、查看运行时数据\n&emsp;&emsp;在你调试程序时，当程序被停住时，你可以使用print命令（简写命令为p），或是同义命令inspect来查看当前程序的运行数据。print命令的格式是：\n\nprint\nprint /\n是表达式，是你所调试的程序的语言的表达式（GDB可以调试多种编程语言），是输出的格式，比如，如果要把表达式按16进制的格式输出，那么就是/x。\n\n\n### 3.1、表达式\n\n&emsp;&emsp;print和许多GDB的命令一样，可以接受一个表达式，GDB会根据当前的程序运行的数据来计算这个表达式，既然是表达式，那么就可以是当前程序运行中的const常量、变量、函数等内容。可惜的是GDB不能使用你在程序中所定义的宏。\n\n&emsp;&emsp;表达式的语法应该是当前所调试的语言的语法，由于C/C++是一种大众型的语言，所以，本文中的例子都是关于C/C++的。（而关于用GDB调试其它语言的章节，我将在后面介绍）\n\n&emsp;&emsp;在表达式中，有几种GDB所支持的操作符，它们可以用在任何一种语言中。\n```bash\n@\n是一个和数组有关的操作符，在后面会有更详细的说明。\n\n::\n指定一个在文件或是一个函数中的变量。\n\n{}\n表示一个指向内存地址的类型为type的一个对象。\n```\n\n\n### 3.2、程序变量\n\n&emsp;&emsp;在GDB中，你可以随时查看以下三种变量的值：\n- 1、全局变量（所有文件可见的）\n- 2、静态全局变量（当前文件可见的）\n- 3、局部变量（当前Scope可见的）\n\n&emsp;&emsp;如果你的局部变量和全局变量发生冲突（也就是重名），一般情况下是局部变量会隐藏全局变量，也就是说，如果一个全局变量和一个函数中的局部变量同名时，如果当前停止点在函数中，用print显示出的变量的值会是函数中的局部变量的值。如果此时你想查看全局变量的值时，你可以使用“::”操作符：\n\n```bash\nfile::variable\nfunction::variable\n可以通过这种形式指定你所想查看的变量，是哪个文件中的或是哪个函数中的。例如，查看文件f2.c中的全局变量x的值：\n\n(gdb) p 'f2.c'::x\n\n当然，“::”操作符会和C++中的发生冲突，GDB能自动识别“::”是否C++的操作符，所以你不必担心在调试C++程序时会出现异常。\n```\n\n&emsp;&emsp;另外，需要注意的是，如果你的程序编译时开启了优化选项，那么在用GDB调试被优化过的程序时，可能会发生某些变量不能访问，或是取值错误码的情况。这个是很正常的，因为优化程序会删改你的程序，整理你程序的语句顺序，剔除一些无意义的\n变量等，所以在GDB调试这种程序时，运行时的指令和你所编写指令就有不一样，也\n就会出现你所想象不到的结果。对付这种情况时，需要在编译程序时关闭编译优化。\n一般来说，几乎所有的编译器都支持编译优化的开关，例如，GNU 的C/C++编译器\nGCC，你可以使用“-gstabs”选项来解决这个问题。关于编译器的参数，还请查看编\n译器的使用说明文档。\n\n### 3.3、数组\n\n&emsp;&emsp;有时候，你需要查看一段连续的内存空间的值。比如数组的一段，或是动态分配的数据的大小。你可以使用GDB的“@”操作符，“@”的左边是第一个内存的地址的\n值，“@”的右边则你你想查看内存的长度。例如，你的程序中有这样的语句：\n```C\nint *array = (int *) malloc (len * sizeof (int));\n```\n\n&emsp;&emsp;于是，在GDB调试过程中，你可以以如下命令显示出这个动态数组的取值：\n```C\np *array@len\n```\n\n&emsp;&emsp;@的左边是数组的首地址的值，也就是变量array所指向的内容，右边则是数据的长度，其保存在变量len中，其输出结果，大约是下面这个样子的：\n```bash\n(gdb) p *array@len\n$1 = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32,34, 36, 38, 40}\n```\n\n&emsp;&emsp;如果是静态数组的话，可以直接用print数组名，就可以显示数组中所有数据的内容了。\n\n\n### 3.4、输出格式\n\n&emsp;&emsp;一般来说，GDB会根据变量的类型输出变量的值。但你也可以自定义GDB的输出的格式。例如，你想输出一个整数的十六进制，或是二进制来查看这个整型变量的中的\n位的情况。要做到这样，你可以使用GDB的数据显示格式：\n\nx 按十六进制格式显示变量。\nd 按十进制格式显示变量。\nu 按十六进制格式显示无符号整型。\no 按八进制格式显示变量。\nt 按二进制格式显示变量。\na 按十六进制格式显示变量。\nc 按字符格式显示变量。\nf 按浮点数格式显示变量。\n\n```bash\n(gdb) p i\n$21 = 101\n\n(gdb) p/a i\n$22 = 0x65\n\n(gdb) p/c i\n$23 = 101 'e'\n\n(gdb) p/f i\n$24 = 1.41531145e-43\n\n(gdb) p/x i\n$25 = 0x65\n\n(gdb) p/t i\n$26 = 1100101\n```\n\n### 3.5、查看内存\n\n&emsp;&emsp;你可以使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：\n```bash\nx/\n\nn、f、u是可选的参数。\n```\n\nn 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。\nf 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是指令地址，那么格式可以是i。\nu 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。\n \nu参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。\n\n&emsp;&emsp;当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。\n\n&emsp;&emsp;表示一个内存地址。\n\nn/f/u三个参数可以一起使用。例如：\n\n命令：x/3uh 0x54320表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。\n\n\n### 3.6、自动显示\n\n&emsp;&emsp;你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display。\n\n```bash\ndisplay\ndisplay/\ndisplay/\n```\n\nexpr是一个表达式，fmt表示显示的格式，addr表示内存地址，当你用display设定好了一个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值。\n\n格式i和s同样被display支持，一个非常有用的命令是：\n```bash\ndisplay/i $pc\n```\n\n$pc是GDB的环境变量，表示着指令的地址，/i则表示输出格式为机器指令码，也就是汇编。于是当程序停下后，就会出现源代码和机器指令码相对应的情形，这是一个很有意思的功能。\n\n下面是一些和display相关的GDB命令：\n\nundisplay\ndelete display\n删除自动显示，dnums意为所设置好了的自动显式的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5）\n\ndisable display\nenable display\ndisable和enalbe不删除自动显示的设置，而只是让其失效和恢复。\n\ninfo display\n查看display设置的自动显示的信息。GDB会打出一张表格，向你报告当然调试中设置了多少个自动显示设置，其中包括，设置的编号，表达式，是否enable。\n\n### 3.7、设置显示选项\n\n&emsp;&emsp;GDB中关于显示的选项比较多，这里我只例举大多数常用的选项。\n- set print address\n- set print address on\n  \n&emsp;&emsp;打开地址输出，当程序显示函数信息时，GDB会显出函数的参数地址。系统默认为打开的，如：\n```bash\n(gdb) f\n#0 set_quotes (lq=0x34c78 \"<<\",rq=0x34c88 \">>\")\nat input.c:530\n530 if (lquote != def_lquote)\n\n\nset print address off\n关闭函数的参数地址显示，如：\n\n(gdb) set print addr off\n(gdb) f\n#0 set_quotes (lq=\"<<\",rq=\">>\") at input.c:530\n530 if (lquote != def_lquote)\n\nshow print address\n查看当前地址显示选项是否打开。\n\nset print array\nset print array on\n打开数组显示，打开后当数组显示时，每个元素占一行，如果不打开的话，每个元素则以逗号分隔。这个选项默认是关闭的。与之相关的两个命令如下，我就不再多说了。\n\nset print array off\nshow print array\n\nset print elements\n这个选项主要是设置数组的，如果你的数组太大了，那么就可以指定一个来指定数据显示的最大长度，当到达这个长度时，GDB就不再往下显示了。如果设置为0，则表示不限制。\n\nshow print elements\n查看print elements的选项信息。\n\nset print null-stop\n如果打开了这个选项，那么当显示字符串时，遇到结束符则停止显示。这个选项默认为off。\n\nset print pretty on\n如果打开printf pretty这个选项，那么当GDB显示结构体时会比较漂亮。如：\n\n$1 = {\nnext = 0x0,\nflags = {\nsweet = 1,\nsour = 1\n},\nmeat = 0x54 \"Pork\"\n}\n\nset print pretty off\n关闭printf pretty这个选项，GDB显示结构体时会如下显示：\n\n$1 = {next = 0x0, flags = {sweet = 1, sour = 1}, meat = 0x54\"Pork\"}\n\nshow print pretty\n查看GDB是如何显示结构体的。\n\n\nset print sevenbit-strings\n设置字符显示，是否按“\\nnn”的格式显示，如果打开，则字符串或字符数据按\\nnn显示，如“\\065”。\n\nshow print sevenbit-strings\n查看字符显示开关是否打开。\n\nset print union\n设置显示结构体时，是否显式其内的联合体数据。例如有以下数据结构：\n\ntypedef enum {Tree, Bug} Species;\ntypedef enum {Big_tree, Acorn, Seedling} Tree_forms;\ntypedef enum {Caterpillar, Cocoon, Butterfly}\nBug_forms;\n\nstruct thing {\nSpecies it;\nunion {\nTree_forms tree;\nBug_forms bug;\n} form;\n};\n\nstruct thing foo = {Tree, {Acorn}};\n\n当打开这个开关时，执行 p foo 命令后，会如下显示：\n$1 = {it = Tree, form = {tree = Acorn, bug = Cocoon}}\n\n当关闭这个开关时，执行 p foo 命令后，会如下显示：\n$1 = {it = Tree, form = {...}}\n\nshow print union\n查看联合体数据的显示方式\n\nset print object\n在C++中，如果一个对象指针指向其派生类，如果打开这个选项，GDB会自动按照虚方法调用的规则显示输出，如果关闭这个选项的话，GDB就不管虚函数表了。这个选项默认是off。\n\nshow print object\n查看对象选项的设置。\n\nset print static-members\n这个选项表示，当显示一个C++对象中的内容是，是否显示其中的静态数据成员。默认是on。\n\nshow print static-members\n查看静态数据成员选项设置。\n\nset print vtbl\n当此选项打开时，GDB将用比较规整的格式来显示虚函数表时。其默认是关闭的。\n\nshow print vtbl\n查看虚函数显示格式的选项。\n```\n\n### 3.8、历史记录\n\n&emsp;&emsp;当你用GDB的print查看程序运行时的数据时，你每一个print都会被GDB记录下来。\n&emsp;&emsp;GDB会以$1, $2, $3 .....这样的方式为你每一个print命令编上号。于是，你可以使用这个编号访问以前的表达式，如$1。这个功能所带来的好处是，如果你先前输入了一个比较长的表达式，如果你还想查看这个表达式的值，你可以使用历史记录\n来访问，省去了重复输入。\n\n\n### 3.9、GDB环境变量\n\n&emsp;&emsp;你可以在GDB的调试环境中定义自己的变量，用来保存一些调试程序中的运行数据。要定义一个GDB的变量很简单只需。使用GDB的set命令。GDB的环境变量和UNIX一样，也是以$起头。如：\n\n> set $foo = *object_ptr\n\n&emsp;&emsp;使用环境变量时，GDB会在你第一次使用时创建这个变量，而在以后的使用中，则直接对其賦值。环境变量没有类型，你可以给环境变量定义任一的类型。包括结构体和数组。\n\n> show convenience  \n//该命令查看当前所设置的所有的环境变量。\n\n&emsp;&emsp;这是一个比较强大的功能，环境变量和程序变量的交互使用，将使得程序调试更为灵活便捷。例如：\n\n> set $i = 0\n> \n> print bar[$i++]->contents\n\n&emsp;&emsp;于是，当你就不必，print bar[0]->contents, printbar[1]->contents地输入命令了。输入这样的命令后，只用敲回车，重复执行上一条语句，环境变量会自动累加，从而完成逐个输出的功能。\n\n\n### 3.10、查看寄存器\n\n&emsp;&emsp;要查看寄存器的值，很简单，可以使用如下命令：\n\n> info registers  \n//查看寄存器的情况。（除了浮点寄存器）\n\n> info all-registers  \n查看所有寄存器的情况。（包括浮点寄存器）\n\n> info registers  \n查看所指定的寄存器的情况。\n\n&emsp;&emsp;寄存器中放置了程序运行时的数据，比如程序当前运行的指令地址（ip），程序的当前堆栈地址（sp）等等。你同样可以使用print命令来访问寄存器的情况，只需要在寄存器名字前加一个$符号就可以了。如：p $eip。\n\n## 四、改变程序的执行\n\n&emsp;&emsp;一旦使用GDB挂上被调试程序，当程序运行起来后，你可以根据自己的调试思路来动态地在GDB中更改当前被调试程序的运行线路或是其变量的值，这个强大的功能能够让你更好的调试你的程序，比如，你可以在程序的一次运行中走遍程序的所有分支。\n\n\n### 4.1、修改变量值\n\n&emsp;&emsp;修改被调试程序运行时的变量值，在GDB中很容易实现，使用GDB的print命令即可完成。如：\n\n```bash\n(gdb) print x=4\n\nx=4这个表达式是C/C++的语法，意为把变量x的值修改为4，如果你当前调试的语言是Pascal，那么你可以使用Pascal的语法：x:=4。\n\n在某些时候，很有可能你的变量和GDB中的参数冲突，如：\n\n(gdb) whatis width\ntype = double\n(gdb) p width\n$4 = 13\n(gdb) set width=47\nInvalid syntax in expression.\n\n因为，set width是GDB的命令，所以，出现了“Invalid syntax inexpression”的设置错误，此时，你可以使用setvar命令来告诉GDB，width不是你GDB的参数，而是程序的变量名，如：\n\n(gdb) set var width=47\n\n另外，还可能有些情况，GDB并不报告这种错误，所以保险起见，在你改变程序变量取值时，最好都使用setvar格式的GDB命令。\n```\n\n### 4.2、跳转执行\n\n&emsp;&emsp;一般来说，被调试程序会按照程序代码的运行顺序依次执行。GDB提供了乱序执行的功能，也就是说，GDB可以修改程序的执行顺序，可以让程序执行随意跳跃。这个功能可以由GDB的jump命令来完：\n\njump\n指定下一条语句的运行点。可以是文件的行号，可以是file:line格式，可以是+num这种偏移量格式。表式着下一条运行语句从哪里开始。\n\njump\n\n这里的是代码行的内存地址。\n\n&emsp;&emsp;注意，jump命令不会改变当前的程序栈中的内容，所以，当你从一个函数跳到另一个函数时，当函数运行完返回时进行弹栈操作时必然会发生错误，可能结果还是非常\n奇怪的，甚至于产生程序Core Dump。所以最好是同一个函数中进行跳转。\n\n&emsp;&emsp;熟悉汇编的人都知道，程序运行时，有一个寄存器用于保存当前代码所在的内存地址。所以，jump命令也就是改变了这个寄存器中的值。于是，你可以使用“set $pc”来更改跳转执行的地址。如：\n```bash\nset $pc = 0x485\n```\n\n\n### 4.3、产生信号量\n\n&emsp;&emsp;使用singal命令，可以产生一个信号量给被调试的程序。如：中断信号Ctrl+C。这非常方便于程序的调试，可以在程序运行的任意位置设置断点，并在该断点用GDB产生一个信号量，这种精确地在某处产生信号非常有利程序的调试。\n\n&emsp;&emsp;语法是：signal ，UNIX的系统信号量通常从1到15。所以取值也在这个范围。\n\n&emsp;&emsp;single命令和shell的kill命令不同，系统的kill命令发信号给被调试程序时，是由GDB截获的，而single命令所发出一信号则是直接发给被调试程序的。\n\n### 4.4、强制函数返回\n\n&emsp;&emsp;如果你的调试断点在某个函数中，并还有语句没有执行完。你可以使用return命令强制函数忽略还没有执行的语句并返回。\n\nreturn\nreturn\n&emsp;&emsp;使用return命令取消当前函数的执行，并立即返回，如果指定了，那么该表达式的值会被认作函数的返回值。\n\n\n### 4.5、强制调用函数\n```bash\ncall\n```\n\n&emsp;&emsp;表达式中可以一是函数，以此达到强制调用函数的目的。并显示函数的返回值，如果函数返回值是void，那么就不显示。\n\n&emsp;&emsp;另一个相似的命令也可以完成这一功能——print，print后面可以跟表达式，所以也可以用他来调用函数，print和call的不同是，如果函数返回void，call则不显示，print则显示函数返回值，并把该值存入历史数据中。\n\n## 五、在不同语言中使用GDB\n\n&emsp;&emsp;GDB支持下列语言：C, C++, Fortran, PASCAL, Java, Chill, assembly, 和Modula-2。一般说来，GDB会根据你所调试的程序来确定当然的调试语言，比如：发现文件名后缀为“.c”的，GDB会认为是C程序。文件名后缀为 “.C, .cc, .cp, .cpp, .cxx, .c++”的，GDB会认为是C++程序。而后缀是“.f, .F”的，GDB会认为是Fortran程序，还有，后缀为如果是“.s, .S”的会认为是汇编语言。\n\n&emsp;&emsp;也就是说，GDB会根据你所调试的程序的语言，来设置自己的语言环境，并让GDB的命令跟着语言环境的改变而改变。比如一些GDB命令需要用到表达式或变量时，这些\n表达式或变量的语法，完全是根据当前的语言环境而改变的。例如C/C++中对指针\n的语法是*p，而在Modula-2中则是p^。并且，如果你当前的程序是由几种不同语言\n一同编译成的，那到在调试过程中，GDB也能根据不同的语言自动地切换语言环境。\n这种跟着语言环境而改变的功能，真是体贴开发人员的一种设计。\n\n\n&emsp;&emsp;下面是几个相关于GDB语言环境的命令：\n\n```bash\nshow language\n查看当前的语言环境。如果GDB不能识为你所调试的编程语言，那么，C语言被认为是默认的环境。\n\ninfo frame\n查看当前函数的程序语言。\n\ninfo source\n查看当前文件的程序语言。\n```\n\n如果GDB没有检测出当前的程序语言，那么你也可以手动设置当前的程序语言。使用set language命令即可做到。\n\n当set language命令后什么也不跟的话，你可以查看GDB所支持的语言种类：\n```bash\n(gdb) set language\nThe currently understood settings are:\n\nlocal or auto Automatic setting based on source file\nc Use the C language\nc++ Use the C++ language\nasm Use the Asm language\nchill Use the Chill language\nfortran Use the Fortran language\njava Use the Java language\nmodula-2 Use the Modula-2 language\npascal Use the Pascal language\nscheme Use the Scheme language\n```\n\n&emsp;&emsp;于是你可以在set language后跟上被列出来的程序语言名，来设置当前的语言环境。\n","slug":"Linux中用gdb 查看代码堆栈的信息","published":1,"updated":"2022-01-29T13:56:53.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3bsl2ia00035awq2dv2g3lw","content":"<p>&amp;emsp;&amp;emsp;core dump 一般是在segmentation fault（段错误）的情况下产生的文件，需要通过ulimit来设置才会得到的。</p>\n<p>&amp;emsp;&amp;emsp;调试的话输入： gdb filename core</p>\n<p>&amp;emsp;&amp;emsp;其中，filename就是产生core文件的可执行文件，core就是产生的dump文件</p>\n<h2 id=\"一、查看栈信息\"><a href=\"#一、查看栈信息\" class=\"headerlink\" title=\"一、查看栈信息\"></a>一、查看栈信息</h2><p>&amp;emsp;&amp;emsp;当程序被停住了，你需要做的第一件事就是查看程序是在哪里停住的。当你的程序调用了一个函数，函数的地址，函数参数，函数内的局部变量都会被压入“栈”（Stack）中。你可以用GDB命令来查看当前的栈中的信息。</p>\n<p>&amp;emsp;&amp;emsp;下面是一些查看函数调用栈信息的GDB命令：</p>\n<blockquote>\n<p>backtrace&#x2F;bt</p>\n</blockquote>\n<p>&amp;emsp;&amp;emsp;打印当前的函数调用栈的所有信息。如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">(gdb) bt<br><span class=\"hljs-comment\">#0 func (n=250) at tst.c:6</span><br><span class=\"hljs-comment\">#1 0x08048524 in main (argc=1, argv=0xbffff674) at tst.c:30</span><br><span class=\"hljs-comment\">#2 0x400409ed in __libc_start_main () from /lib/libc.so.6</span><br></code></pre></td></tr></table></figure>\n\n<p>&amp;emsp;&amp;emsp;从上可以看出函数的调用栈信息：__libc_start_main –&gt; main()–&gt; func()</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">backtrace<br>(bt)<br>n是一个正整数，表示只打印栈顶上n层的栈信息。<br><br>backtrace &lt;-n&gt;<br><br>bt &lt;-n&gt;<br><br>-n表一个负整数，表示只打印栈底下n层的栈信息。<br></code></pre></td></tr></table></figure>\n\n<p>&amp;emsp;&amp;emsp;如果你要查看某一层的信息，你需要在切换当前的栈，一般来说，程序停止时，最顶层的栈就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是切换当前栈。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">frame<br>f<br>n是一个从0开始的整数，是栈中的层编号。比如：frame 0，表示栈顶，frame 1，表示栈的第二层。<br><br>up<br>表示向栈的上面移动n层，可以不打n，表示向上移动一层。<br><br>down<br>表示向栈的下面移动n层，可以不打n，表示向下移动一层。<br><br>上面的命令，都会打印出移动到的栈层的信息。如果你不想让其打出信息。你可以使用这三个命令：<br><br>select-frame 对应于 frame 命令。<br>up-silently 对应于 up 命令。<br>down-silently 对应于 down 命令。<br></code></pre></td></tr></table></figure>\n\n\n<p>&amp;emsp;&amp;emsp;查看当前栈层的信息，你可以用以下GDB命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">frame 或 f<br>会打印出这些信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。<br><br>info frame<br><br>info f<br><br>这个命令会打印出更为详细的当前栈层的信息，只不过，大多数都是运行时的内内<br>地址。比如：函数地址，调用函数的地址，被调用函数的地址，目前的函数是由什么<br>样的程序语言写成的、函数参数地址及值、局部变量的地址等等。如：<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">(gdb) info f<br>Stack level 0, frame at 0xbffff5d4:<br>eip = 0x804845d <span class=\"hljs-keyword\">in</span> func (tst.c:6); saved eip 0x8048524<br>called by frame at 0xbffff60c<br><span class=\"hljs-built_in\">source</span> language c.<br>Arglist at 0xbffff5d4, args: n=250<br>Locals at 0xbffff5d4, Previous frame<span class=\"hljs-string\">&#x27;s sp is 0x0</span><br><span class=\"hljs-string\">Saved registers:</span><br><span class=\"hljs-string\">ebp at 0xbffff5d4, eip at 0xbffff5d8</span><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>info args<br>打印出当前函数的参数名及其值。</p>\n</blockquote>\n<blockquote>\n<p>info locals<br>打印出当前函数中所有局部变量及其值。</p>\n</blockquote>\n<blockquote>\n<p>info catch<br>打印出当前的函数中的异常处理信息。</p>\n</blockquote>\n<h2 id=\"二、查看源程序\"><a href=\"#二、查看源程序\" class=\"headerlink\" title=\"二、查看源程序\"></a>二、查看源程序</h2><h3 id=\"2-1、显示源代码\"><a href=\"#2-1、显示源代码\" class=\"headerlink\" title=\"2.1、显示源代码\"></a>2.1、显示源代码</h3><p>&amp;emsp;&amp;emsp;GDB 可以打印出所调试程序的源代码，当然，在程序编译时一定要加上-g的参数，把源程序信息编译到执行文件中。不然就看不到源程序了。当程序停下来以后，GDB会报告程序停在了那个文件的第几行上。你可以用list命令来打印程序的源代码。还是来看一看查看源代码的GDB命令吧。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">list<br>显示程序第linenum行的周围的源程序。<br><br>list<br>显示函数名为<span class=\"hljs-keyword\">function</span>的函数的源程序。<br><br>list<br>显示当前行后面的源程序。<br><br>list -<br>显示当前行前面的源程序。<br></code></pre></td></tr></table></figure>\n\n<p>&amp;emsp;&amp;emsp;一般是打印当前行的上5行和下5行，如果显示函数是是上2行下8行，默认是10行，当然，你也可以定制显示的范围，使用下面命令可以设置一次显示源程序的行数。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">set</span> listsize<br>设置一次显示源代码的行数。<br><br>show listsize<br>查看当前listsize的设置。<br><br>list命令还有下面的用法：<br><br>list ,<br>显示从first行到last行之间的源代码。<br><br>list ,<br>显示从当前行到last行之间的源代码。<br><br>list +<br>往后显示源代码。<br></code></pre></td></tr></table></figure>\n\n<p>&amp;emsp;&amp;emsp;一般来说在list后面可以跟以下这们的参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">行号。<br>&lt;+offset&gt; 当前行号的正偏移量。<br>&lt;-offset&gt; 当前行号的负偏移量。<br>哪个文件的哪一行。<br>函数名。<br>哪个文件中的哪个函数。<br>&lt;*address&gt; 程序运行时的语句在内存中的地址。<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-2、搜索源代码\"><a href=\"#2-2、搜索源代码\" class=\"headerlink\" title=\"2.2、搜索源代码\"></a>2.2、搜索源代码</h3><p>不仅如此，GDB还提供了源代码搜索的命令：</p>\n<p>forward-search<br>search<br>向前面搜索。</p>\n<p>reverse-search<br>全部搜索。</p>\n<p>其中，就是正则表达式，也主一个字符串的匹配模式，关于正则表达式，我就不在这里讲了，还请各位查看相关资料。</p>\n<h3 id=\"2-3、指定源文件的路径\"><a href=\"#2-3、指定源文件的路径\" class=\"headerlink\" title=\"2.3、指定源文件的路径\"></a>2.3、指定源文件的路径</h3><p>&amp;emsp;&amp;emsp;某些时候，用-g编译过后的执行程序中只是包括了源文件的名字，没有路径名。GDB提供了可以让你指定源文件的路径的命令，以便GDB进行搜索。<br>directory<br>dir<br>加一个源文件路径到当前路径的前面。如果你要指定多个路径，UNIX下你可以使用“:”，Windows下你可以使用“;”。<br>directory<br>清除所有的自定义的源文件搜索路径信息。</p>\n<p>show directories<br>显示定义了的源文件搜索路径。</p>\n<h3 id=\"2-4、源代码的内存\"><a href=\"#2-4、源代码的内存\" class=\"headerlink\" title=\"2.4、源代码的内存\"></a>2.4、源代码的内存</h3><p>&amp;emsp;&amp;emsp;你可以使用info line命令来查看源代码在内存中的地址。info line后面可以跟“行号”，“函数名”，“文件名:行号”，“文件名:函数名”，这个命令会打印出所指定的源码在运行时的内存地址，如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">(gdb) info line tst.c:func<br>Line 5 of <span class=\"hljs-string\">&quot;tst.c&quot;</span> starts at address 0x8048456 and ends at 0x804845d.<br></code></pre></td></tr></table></figure>\n\n<p>&amp;emsp;&amp;emsp;还有一个命令（disassemble）你可以查看源程序的当前执行时的机器码，这个命令会把目前内存中的指令dump出来。如下面的示例表示查看函数func的汇编代码。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">(gdb) disassemble func<br>Dump of assembler code <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">function</span> func:<br>0x8048450 : push %ebp<br>0x8048451 : mov %esp,%ebp<br>0x8048453 : sub <span class=\"hljs-variable\">$0x18</span>,%esp<br>0x8048456 : movl <span class=\"hljs-variable\">$0x0</span>,0xfffffffc(%ebp)<br>0x804845d : movl <span class=\"hljs-variable\">$0x1</span>,0xfffffff8(%ebp)<br>0x8048464 : mov 0xfffffff8(%ebp),%eax<br>0x8048467 : cmp 0x8(%ebp),%eax<br>0x804846a : jle 0x8048470<br>0x804846c : jmp 0x8048480<br>0x804846e : mov %esi,%esi<br>0x8048470 : mov 0xfffffff8(%ebp),%eax<br>0x8048473 : add %eax,0xfffffffc(%ebp)<br>0x8048476 : incl 0xfffffff8(%ebp)<br>0x8048479 : jmp 0x8048464<br>0x804847b : nop<br>0x804847c : lea 0x0(%esi,1),%esi<br>0x8048480 : mov 0xfffffffc(%ebp),%edx<br>0x8048483 : mov %edx,%eax<br>0x8048485 : jmp 0x8048487<br>0x8048487 : mov %ebp,%esp<br>0x8048489 : pop %ebp<br>0x804848a : ret<br>End of assembler dump.<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、查看运行时数据\"><a href=\"#三、查看运行时数据\" class=\"headerlink\" title=\"三、查看运行时数据\"></a>三、查看运行时数据</h2><p>&amp;emsp;&amp;emsp;在你调试程序时，当程序被停住时，你可以使用print命令（简写命令为p），或是同义命令inspect来查看当前程序的运行数据。print命令的格式是：</p>\n<p>print<br>print &#x2F;<br>是表达式，是你所调试的程序的语言的表达式（GDB可以调试多种编程语言），是输出的格式，比如，如果要把表达式按16进制的格式输出，那么就是&#x2F;x。</p>\n<h3 id=\"3-1、表达式\"><a href=\"#3-1、表达式\" class=\"headerlink\" title=\"3.1、表达式\"></a>3.1、表达式</h3><p>&amp;emsp;&amp;emsp;print和许多GDB的命令一样，可以接受一个表达式，GDB会根据当前的程序运行的数据来计算这个表达式，既然是表达式，那么就可以是当前程序运行中的const常量、变量、函数等内容。可惜的是GDB不能使用你在程序中所定义的宏。</p>\n<p>&amp;emsp;&amp;emsp;表达式的语法应该是当前所调试的语言的语法，由于C&#x2F;C++是一种大众型的语言，所以，本文中的例子都是关于C&#x2F;C++的。（而关于用GDB调试其它语言的章节，我将在后面介绍）</p>\n<p>&amp;emsp;&amp;emsp;在表达式中，有几种GDB所支持的操作符，它们可以用在任何一种语言中。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">@<br>是一个和数组有关的操作符，在后面会有更详细的说明。<br><br>::<br>指定一个在文件或是一个函数中的变量。<br><br>&#123;&#125;<br>表示一个指向内存地址的类型为<span class=\"hljs-built_in\">type</span>的一个对象。<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"3-2、程序变量\"><a href=\"#3-2、程序变量\" class=\"headerlink\" title=\"3.2、程序变量\"></a>3.2、程序变量</h3><p>&amp;emsp;&amp;emsp;在GDB中，你可以随时查看以下三种变量的值：</p>\n<ul>\n<li>1、全局变量（所有文件可见的）</li>\n<li>2、静态全局变量（当前文件可见的）</li>\n<li>3、局部变量（当前Scope可见的）</li>\n</ul>\n<p>&amp;emsp;&amp;emsp;如果你的局部变量和全局变量发生冲突（也就是重名），一般情况下是局部变量会隐藏全局变量，也就是说，如果一个全局变量和一个函数中的局部变量同名时，如果当前停止点在函数中，用print显示出的变量的值会是函数中的局部变量的值。如果此时你想查看全局变量的值时，你可以使用“::”操作符：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">file::variable<br><span class=\"hljs-keyword\">function</span>::variable<br>可以通过这种形式指定你所想查看的变量，是哪个文件中的或是哪个函数中的。例如，查看文件f2.c中的全局变量x的值：<br><br>(gdb) p <span class=\"hljs-string\">&#x27;f2.c&#x27;</span>::x<br><br>当然，“::”操作符会和C++中的发生冲突，GDB能自动识别“::”是否C++的操作符，所以你不必担心在调试C++程序时会出现异常。<br></code></pre></td></tr></table></figure>\n\n<p>&amp;emsp;&amp;emsp;另外，需要注意的是，如果你的程序编译时开启了优化选项，那么在用GDB调试被优化过的程序时，可能会发生某些变量不能访问，或是取值错误码的情况。这个是很正常的，因为优化程序会删改你的程序，整理你程序的语句顺序，剔除一些无意义的<br>变量等，所以在GDB调试这种程序时，运行时的指令和你所编写指令就有不一样，也<br>就会出现你所想象不到的结果。对付这种情况时，需要在编译程序时关闭编译优化。<br>一般来说，几乎所有的编译器都支持编译优化的开关，例如，GNU 的C&#x2F;C++编译器<br>GCC，你可以使用“-gstabs”选项来解决这个问题。关于编译器的参数，还请查看编<br>译器的使用说明文档。</p>\n<h3 id=\"3-3、数组\"><a href=\"#3-3、数组\" class=\"headerlink\" title=\"3.3、数组\"></a>3.3、数组</h3><p>&amp;emsp;&amp;emsp;有时候，你需要查看一段连续的内存空间的值。比如数组的一段，或是动态分配的数据的大小。你可以使用GDB的“@”操作符，“@”的左边是第一个内存的地址的<br>值，“@”的右边则你你想查看内存的长度。例如，你的程序中有这样的语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-type\">int</span> *<span class=\"hljs-built_in\">array</span> = (<span class=\"hljs-type\">int</span> *) <span class=\"hljs-built_in\">malloc</span> (len * <span class=\"hljs-keyword\">sizeof</span> (<span class=\"hljs-type\">int</span>));<br></code></pre></td></tr></table></figure>\n\n<p>&amp;emsp;&amp;emsp;于是，在GDB调试过程中，你可以以如下命令显示出这个动态数组的取值：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\">p *<span class=\"hljs-built_in\">array</span>@len<br></code></pre></td></tr></table></figure>\n\n<p>&amp;emsp;&amp;emsp;@的左边是数组的首地址的值，也就是变量array所指向的内容，右边则是数据的长度，其保存在变量len中，其输出结果，大约是下面这个样子的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">(gdb) p *array@len<br><span class=\"hljs-variable\">$1</span> = &#123;2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32,34, 36, 38, 40&#125;<br></code></pre></td></tr></table></figure>\n\n<p>&amp;emsp;&amp;emsp;如果是静态数组的话，可以直接用print数组名，就可以显示数组中所有数据的内容了。</p>\n<h3 id=\"3-4、输出格式\"><a href=\"#3-4、输出格式\" class=\"headerlink\" title=\"3.4、输出格式\"></a>3.4、输出格式</h3><p>&amp;emsp;&amp;emsp;一般来说，GDB会根据变量的类型输出变量的值。但你也可以自定义GDB的输出的格式。例如，你想输出一个整数的十六进制，或是二进制来查看这个整型变量的中的<br>位的情况。要做到这样，你可以使用GDB的数据显示格式：</p>\n<p>x 按十六进制格式显示变量。<br>d 按十进制格式显示变量。<br>u 按十六进制格式显示无符号整型。<br>o 按八进制格式显示变量。<br>t 按二进制格式显示变量。<br>a 按十六进制格式显示变量。<br>c 按字符格式显示变量。<br>f 按浮点数格式显示变量。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">(gdb) p i<br><span class=\"hljs-variable\">$21</span> = 101<br><br>(gdb) p/a i<br><span class=\"hljs-variable\">$22</span> = 0x65<br><br>(gdb) p/c i<br><span class=\"hljs-variable\">$23</span> = 101 <span class=\"hljs-string\">&#x27;e&#x27;</span><br><br>(gdb) p/f i<br><span class=\"hljs-variable\">$24</span> = 1.41531145e-43<br><br>(gdb) p/x i<br><span class=\"hljs-variable\">$25</span> = 0x65<br><br>(gdb) p/t i<br><span class=\"hljs-variable\">$26</span> = 1100101<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-5、查看内存\"><a href=\"#3-5、查看内存\" class=\"headerlink\" title=\"3.5、查看内存\"></a>3.5、查看内存</h3><p>&amp;emsp;&amp;emsp;你可以使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">x/<br><br>n、f、u是可选的参数。<br></code></pre></td></tr></table></figure>\n\n<p>n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。<br>f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是指令地址，那么格式可以是i。<br>u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。</p>\n<p>u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。</p>\n<p>&amp;emsp;&amp;emsp;当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。</p>\n<p>&amp;emsp;&amp;emsp;表示一个内存地址。</p>\n<p>n&#x2F;f&#x2F;u三个参数可以一起使用。例如：</p>\n<p>命令：x&#x2F;3uh 0x54320表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。</p>\n<h3 id=\"3-6、自动显示\"><a href=\"#3-6、自动显示\" class=\"headerlink\" title=\"3.6、自动显示\"></a>3.6、自动显示</h3><p>&amp;emsp;&amp;emsp;你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">display<br>display/<br>display/<br></code></pre></td></tr></table></figure>\n\n<p>expr是一个表达式，fmt表示显示的格式，addr表示内存地址，当你用display设定好了一个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值。</p>\n<p>格式i和s同样被display支持，一个非常有用的命令是：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">display/i <span class=\"hljs-variable\">$pc</span><br></code></pre></td></tr></table></figure>\n\n<p>$pc是GDB的环境变量，表示着指令的地址，&#x2F;i则表示输出格式为机器指令码，也就是汇编。于是当程序停下后，就会出现源代码和机器指令码相对应的情形，这是一个很有意思的功能。</p>\n<p>下面是一些和display相关的GDB命令：</p>\n<p>undisplay<br>delete display<br>删除自动显示，dnums意为所设置好了的自动显式的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5）</p>\n<p>disable display<br>enable display<br>disable和enalbe不删除自动显示的设置，而只是让其失效和恢复。</p>\n<p>info display<br>查看display设置的自动显示的信息。GDB会打出一张表格，向你报告当然调试中设置了多少个自动显示设置，其中包括，设置的编号，表达式，是否enable。</p>\n<h3 id=\"3-7、设置显示选项\"><a href=\"#3-7、设置显示选项\" class=\"headerlink\" title=\"3.7、设置显示选项\"></a>3.7、设置显示选项</h3><p>&amp;emsp;&amp;emsp;GDB中关于显示的选项比较多，这里我只例举大多数常用的选项。</p>\n<ul>\n<li>set print address</li>\n<li>set print address on</li>\n</ul>\n<p>&amp;emsp;&amp;emsp;打开地址输出，当程序显示函数信息时，GDB会显出函数的参数地址。系统默认为打开的，如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">(gdb) f<br><span class=\"hljs-comment\">#0 set_quotes (lq=0x34c78 &quot;&lt;&lt;&quot;,rq=0x34c88 &quot;&gt;&gt;&quot;)</span><br>at input.c:530<br>530 <span class=\"hljs-keyword\">if</span> (lquote != def_lquote)<br><br><br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> address off<br>关闭函数的参数地址显示，如：<br><br>(gdb) <span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> addr off<br>(gdb) f<br><span class=\"hljs-comment\">#0 set_quotes (lq=&quot;&lt;&lt;&quot;,rq=&quot;&gt;&gt;&quot;) at input.c:530</span><br>530 <span class=\"hljs-keyword\">if</span> (lquote != def_lquote)<br><br>show <span class=\"hljs-built_in\">print</span> address<br>查看当前地址显示选项是否打开。<br><br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> array<br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> array on<br>打开数组显示，打开后当数组显示时，每个元素占一行，如果不打开的话，每个元素则以逗号分隔。这个选项默认是关闭的。与之相关的两个命令如下，我就不再多说了。<br><br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> array off<br>show <span class=\"hljs-built_in\">print</span> array<br><br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> elements<br>这个选项主要是设置数组的，如果你的数组太大了，那么就可以指定一个来指定数据显示的最大长度，当到达这个长度时，GDB就不再往下显示了。如果设置为0，则表示不限制。<br><br>show <span class=\"hljs-built_in\">print</span> elements<br>查看<span class=\"hljs-built_in\">print</span> elements的选项信息。<br><br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> null-stop<br>如果打开了这个选项，那么当显示字符串时，遇到结束符则停止显示。这个选项默认为off。<br><br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> pretty on<br>如果打开<span class=\"hljs-built_in\">printf</span> pretty这个选项，那么当GDB显示结构体时会比较漂亮。如：<br><br><span class=\"hljs-variable\">$1</span> = &#123;<br>next = 0x0,<br>flags = &#123;<br>sweet = 1,<br>sour = 1<br>&#125;,<br>meat = 0x54 <span class=\"hljs-string\">&quot;Pork&quot;</span><br>&#125;<br><br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> pretty off<br>关闭<span class=\"hljs-built_in\">printf</span> pretty这个选项，GDB显示结构体时会如下显示：<br><br><span class=\"hljs-variable\">$1</span> = &#123;next = 0x0, flags = &#123;sweet = 1, sour = 1&#125;, meat = 0x54<span class=\"hljs-string\">&quot;Pork&quot;</span>&#125;<br><br>show <span class=\"hljs-built_in\">print</span> pretty<br>查看GDB是如何显示结构体的。<br><br><br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> sevenbit-strings<br>设置字符显示，是否按“\\nnn”的格式显示，如果打开，则字符串或字符数据按\\nnn显示，如“\\065”。<br><br>show <span class=\"hljs-built_in\">print</span> sevenbit-strings<br>查看字符显示开关是否打开。<br><br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> union<br>设置显示结构体时，是否显式其内的联合体数据。例如有以下数据结构：<br><br>typedef enum &#123;Tree, Bug&#125; Species;<br>typedef enum &#123;Big_tree, Acorn, Seedling&#125; Tree_forms;<br>typedef enum &#123;Caterpillar, Cocoon, Butterfly&#125;<br>Bug_forms;<br><br>struct thing &#123;<br>Species it;<br>union &#123;<br>Tree_forms tree;<br>Bug_forms bug;<br>&#125; form;<br>&#125;;<br><br>struct thing foo = &#123;Tree, &#123;Acorn&#125;&#125;;<br><br>当打开这个开关时，执行 p foo 命令后，会如下显示：<br><span class=\"hljs-variable\">$1</span> = &#123;it = Tree, form = &#123;tree = Acorn, bug = Cocoon&#125;&#125;<br><br>当关闭这个开关时，执行 p foo 命令后，会如下显示：<br><span class=\"hljs-variable\">$1</span> = &#123;it = Tree, form = &#123;...&#125;&#125;<br><br>show <span class=\"hljs-built_in\">print</span> union<br>查看联合体数据的显示方式<br><br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> object<br>在C++中，如果一个对象指针指向其派生类，如果打开这个选项，GDB会自动按照虚方法调用的规则显示输出，如果关闭这个选项的话，GDB就不管虚函数表了。这个选项默认是off。<br><br>show <span class=\"hljs-built_in\">print</span> object<br>查看对象选项的设置。<br><br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> static-members<br>这个选项表示，当显示一个C++对象中的内容是，是否显示其中的静态数据成员。默认是on。<br><br>show <span class=\"hljs-built_in\">print</span> static-members<br>查看静态数据成员选项设置。<br><br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> vtbl<br>当此选项打开时，GDB将用比较规整的格式来显示虚函数表时。其默认是关闭的。<br><br>show <span class=\"hljs-built_in\">print</span> vtbl<br>查看虚函数显示格式的选项。<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-8、历史记录\"><a href=\"#3-8、历史记录\" class=\"headerlink\" title=\"3.8、历史记录\"></a>3.8、历史记录</h3><p>&amp;emsp;&amp;emsp;当你用GDB的print查看程序运行时的数据时，你每一个print都会被GDB记录下来。<br>&amp;emsp;&amp;emsp;GDB会以$1, $2, $3 …..这样的方式为你每一个print命令编上号。于是，你可以使用这个编号访问以前的表达式，如$1。这个功能所带来的好处是，如果你先前输入了一个比较长的表达式，如果你还想查看这个表达式的值，你可以使用历史记录<br>来访问，省去了重复输入。</p>\n<h3 id=\"3-9、GDB环境变量\"><a href=\"#3-9、GDB环境变量\" class=\"headerlink\" title=\"3.9、GDB环境变量\"></a>3.9、GDB环境变量</h3><p>&amp;emsp;&amp;emsp;你可以在GDB的调试环境中定义自己的变量，用来保存一些调试程序中的运行数据。要定义一个GDB的变量很简单只需。使用GDB的set命令。GDB的环境变量和UNIX一样，也是以$起头。如：</p>\n<blockquote>\n<p>set $foo &#x3D; *object_ptr</p>\n</blockquote>\n<p>&amp;emsp;&amp;emsp;使用环境变量时，GDB会在你第一次使用时创建这个变量，而在以后的使用中，则直接对其賦值。环境变量没有类型，你可以给环境变量定义任一的类型。包括结构体和数组。</p>\n<blockquote>\n<p>show convenience<br>&#x2F;&#x2F;该命令查看当前所设置的所有的环境变量。</p>\n</blockquote>\n<p>&amp;emsp;&amp;emsp;这是一个比较强大的功能，环境变量和程序变量的交互使用，将使得程序调试更为灵活便捷。例如：</p>\n<blockquote>\n<p>set $i &#x3D; 0</p>\n<p>print bar[$i++]-&gt;contents</p>\n</blockquote>\n<p>&amp;emsp;&amp;emsp;于是，当你就不必，print bar[0]-&gt;contents, printbar[1]-&gt;contents地输入命令了。输入这样的命令后，只用敲回车，重复执行上一条语句，环境变量会自动累加，从而完成逐个输出的功能。</p>\n<h3 id=\"3-10、查看寄存器\"><a href=\"#3-10、查看寄存器\" class=\"headerlink\" title=\"3.10、查看寄存器\"></a>3.10、查看寄存器</h3><p>&amp;emsp;&amp;emsp;要查看寄存器的值，很简单，可以使用如下命令：</p>\n<blockquote>\n<p>info registers<br>&#x2F;&#x2F;查看寄存器的情况。（除了浮点寄存器）</p>\n</blockquote>\n<blockquote>\n<p>info all-registers<br>查看所有寄存器的情况。（包括浮点寄存器）</p>\n</blockquote>\n<blockquote>\n<p>info registers<br>查看所指定的寄存器的情况。</p>\n</blockquote>\n<p>&amp;emsp;&amp;emsp;寄存器中放置了程序运行时的数据，比如程序当前运行的指令地址（ip），程序的当前堆栈地址（sp）等等。你同样可以使用print命令来访问寄存器的情况，只需要在寄存器名字前加一个$符号就可以了。如：p $eip。</p>\n<h2 id=\"四、改变程序的执行\"><a href=\"#四、改变程序的执行\" class=\"headerlink\" title=\"四、改变程序的执行\"></a>四、改变程序的执行</h2><p>&amp;emsp;&amp;emsp;一旦使用GDB挂上被调试程序，当程序运行起来后，你可以根据自己的调试思路来动态地在GDB中更改当前被调试程序的运行线路或是其变量的值，这个强大的功能能够让你更好的调试你的程序，比如，你可以在程序的一次运行中走遍程序的所有分支。</p>\n<h3 id=\"4-1、修改变量值\"><a href=\"#4-1、修改变量值\" class=\"headerlink\" title=\"4.1、修改变量值\"></a>4.1、修改变量值</h3><p>&amp;emsp;&amp;emsp;修改被调试程序运行时的变量值，在GDB中很容易实现，使用GDB的print命令即可完成。如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">(gdb) <span class=\"hljs-built_in\">print</span> x=4<br><br>x=4这个表达式是C/C++的语法，意为把变量x的值修改为4，如果你当前调试的语言是Pascal，那么你可以使用Pascal的语法：x:=4。<br><br>在某些时候，很有可能你的变量和GDB中的参数冲突，如：<br><br>(gdb) whatis width<br><span class=\"hljs-built_in\">type</span> = double<br>(gdb) p width<br><span class=\"hljs-variable\">$4</span> = 13<br>(gdb) <span class=\"hljs-built_in\">set</span> width=47<br>Invalid syntax <span class=\"hljs-keyword\">in</span> expression.<br><br>因为，<span class=\"hljs-built_in\">set</span> width是GDB的命令，所以，出现了“Invalid syntax inexpression”的设置错误，此时，你可以使用setvar命令来告诉GDB，width不是你GDB的参数，而是程序的变量名，如：<br><br>(gdb) <span class=\"hljs-built_in\">set</span> var width=47<br><br>另外，还可能有些情况，GDB并不报告这种错误，所以保险起见，在你改变程序变量取值时，最好都使用setvar格式的GDB命令。<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-2、跳转执行\"><a href=\"#4-2、跳转执行\" class=\"headerlink\" title=\"4.2、跳转执行\"></a>4.2、跳转执行</h3><p>&amp;emsp;&amp;emsp;一般来说，被调试程序会按照程序代码的运行顺序依次执行。GDB提供了乱序执行的功能，也就是说，GDB可以修改程序的执行顺序，可以让程序执行随意跳跃。这个功能可以由GDB的jump命令来完：</p>\n<p>jump<br>指定下一条语句的运行点。可以是文件的行号，可以是file:line格式，可以是+num这种偏移量格式。表式着下一条运行语句从哪里开始。</p>\n<p>jump</p>\n<p>这里的是代码行的内存地址。</p>\n<p>&amp;emsp;&amp;emsp;注意，jump命令不会改变当前的程序栈中的内容，所以，当你从一个函数跳到另一个函数时，当函数运行完返回时进行弹栈操作时必然会发生错误，可能结果还是非常<br>奇怪的，甚至于产生程序Core Dump。所以最好是同一个函数中进行跳转。</p>\n<p>&amp;emsp;&amp;emsp;熟悉汇编的人都知道，程序运行时，有一个寄存器用于保存当前代码所在的内存地址。所以，jump命令也就是改变了这个寄存器中的值。于是，你可以使用“set $pc”来更改跳转执行的地址。如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">set</span> <span class=\"hljs-variable\">$pc</span> = 0x485<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"4-3、产生信号量\"><a href=\"#4-3、产生信号量\" class=\"headerlink\" title=\"4.3、产生信号量\"></a>4.3、产生信号量</h3><p>&amp;emsp;&amp;emsp;使用singal命令，可以产生一个信号量给被调试的程序。如：中断信号Ctrl+C。这非常方便于程序的调试，可以在程序运行的任意位置设置断点，并在该断点用GDB产生一个信号量，这种精确地在某处产生信号非常有利程序的调试。</p>\n<p>&amp;emsp;&amp;emsp;语法是：signal ，UNIX的系统信号量通常从1到15。所以取值也在这个范围。</p>\n<p>&amp;emsp;&amp;emsp;single命令和shell的kill命令不同，系统的kill命令发信号给被调试程序时，是由GDB截获的，而single命令所发出一信号则是直接发给被调试程序的。</p>\n<h3 id=\"4-4、强制函数返回\"><a href=\"#4-4、强制函数返回\" class=\"headerlink\" title=\"4.4、强制函数返回\"></a>4.4、强制函数返回</h3><p>&amp;emsp;&amp;emsp;如果你的调试断点在某个函数中，并还有语句没有执行完。你可以使用return命令强制函数忽略还没有执行的语句并返回。</p>\n<p>return<br>return<br>&amp;emsp;&amp;emsp;使用return命令取消当前函数的执行，并立即返回，如果指定了，那么该表达式的值会被认作函数的返回值。</p>\n<h3 id=\"4-5、强制调用函数\"><a href=\"#4-5、强制调用函数\" class=\"headerlink\" title=\"4.5、强制调用函数\"></a>4.5、强制调用函数</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">call<br></code></pre></td></tr></table></figure>\n\n<p>&amp;emsp;&amp;emsp;表达式中可以一是函数，以此达到强制调用函数的目的。并显示函数的返回值，如果函数返回值是void，那么就不显示。</p>\n<p>&amp;emsp;&amp;emsp;另一个相似的命令也可以完成这一功能——print，print后面可以跟表达式，所以也可以用他来调用函数，print和call的不同是，如果函数返回void，call则不显示，print则显示函数返回值，并把该值存入历史数据中。</p>\n<h2 id=\"五、在不同语言中使用GDB\"><a href=\"#五、在不同语言中使用GDB\" class=\"headerlink\" title=\"五、在不同语言中使用GDB\"></a>五、在不同语言中使用GDB</h2><p>&amp;emsp;&amp;emsp;GDB支持下列语言：C, C++, Fortran, PASCAL, Java, Chill, assembly, 和Modula-2。一般说来，GDB会根据你所调试的程序来确定当然的调试语言，比如：发现文件名后缀为“.c”的，GDB会认为是C程序。文件名后缀为 “.C, .cc, .cp, .cpp, .cxx, .c++”的，GDB会认为是C++程序。而后缀是“.f, .F”的，GDB会认为是Fortran程序，还有，后缀为如果是“.s, .S”的会认为是汇编语言。</p>\n<p>&amp;emsp;&amp;emsp;也就是说，GDB会根据你所调试的程序的语言，来设置自己的语言环境，并让GDB的命令跟着语言环境的改变而改变。比如一些GDB命令需要用到表达式或变量时，这些<br>表达式或变量的语法，完全是根据当前的语言环境而改变的。例如C&#x2F;C++中对指针<br>的语法是*p，而在Modula-2中则是p^。并且，如果你当前的程序是由几种不同语言<br>一同编译成的，那到在调试过程中，GDB也能根据不同的语言自动地切换语言环境。<br>这种跟着语言环境而改变的功能，真是体贴开发人员的一种设计。</p>\n<p>&amp;emsp;&amp;emsp;下面是几个相关于GDB语言环境的命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">show language<br>查看当前的语言环境。如果GDB不能识为你所调试的编程语言，那么，C语言被认为是默认的环境。<br><br>info frame<br>查看当前函数的程序语言。<br><br>info <span class=\"hljs-built_in\">source</span><br>查看当前文件的程序语言。<br></code></pre></td></tr></table></figure>\n\n<p>如果GDB没有检测出当前的程序语言，那么你也可以手动设置当前的程序语言。使用set language命令即可做到。</p>\n<p>当set language命令后什么也不跟的话，你可以查看GDB所支持的语言种类：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">(gdb) <span class=\"hljs-built_in\">set</span> language<br>The currently understood settings are:<br><br><span class=\"hljs-built_in\">local</span> or auto Automatic setting based on <span class=\"hljs-built_in\">source</span> file<br>c Use the C language<br>c++ Use the C++ language<br>asm Use the Asm language<br>chill Use the Chill language<br>fortran Use the Fortran language<br>java Use the Java language<br>modula-2 Use the Modula-2 language<br>pascal Use the Pascal language<br>scheme Use the Scheme language<br></code></pre></td></tr></table></figure>\n\n<p>&amp;emsp;&amp;emsp;于是你可以在set language后跟上被列出来的程序语言名，来设置当前的语言环境。</p>\n","site":{"data":{}},"wordcount":13069,"excerpt":"","more":"<p>&amp;emsp;&amp;emsp;core dump 一般是在segmentation fault（段错误）的情况下产生的文件，需要通过ulimit来设置才会得到的。</p>\n<p>&amp;emsp;&amp;emsp;调试的话输入： gdb filename core</p>\n<p>&amp;emsp;&amp;emsp;其中，filename就是产生core文件的可执行文件，core就是产生的dump文件</p>\n<h2 id=\"一、查看栈信息\"><a href=\"#一、查看栈信息\" class=\"headerlink\" title=\"一、查看栈信息\"></a>一、查看栈信息</h2><p>&amp;emsp;&amp;emsp;当程序被停住了，你需要做的第一件事就是查看程序是在哪里停住的。当你的程序调用了一个函数，函数的地址，函数参数，函数内的局部变量都会被压入“栈”（Stack）中。你可以用GDB命令来查看当前的栈中的信息。</p>\n<p>&amp;emsp;&amp;emsp;下面是一些查看函数调用栈信息的GDB命令：</p>\n<blockquote>\n<p>backtrace&#x2F;bt</p>\n</blockquote>\n<p>&amp;emsp;&amp;emsp;打印当前的函数调用栈的所有信息。如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">(gdb) bt<br><span class=\"hljs-comment\">#0 func (n=250) at tst.c:6</span><br><span class=\"hljs-comment\">#1 0x08048524 in main (argc=1, argv=0xbffff674) at tst.c:30</span><br><span class=\"hljs-comment\">#2 0x400409ed in __libc_start_main () from /lib/libc.so.6</span><br></code></pre></td></tr></table></figure>\n\n<p>&amp;emsp;&amp;emsp;从上可以看出函数的调用栈信息：__libc_start_main –&gt; main()–&gt; func()</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">backtrace<br>(bt)<br>n是一个正整数，表示只打印栈顶上n层的栈信息。<br><br>backtrace &lt;-n&gt;<br><br>bt &lt;-n&gt;<br><br>-n表一个负整数，表示只打印栈底下n层的栈信息。<br></code></pre></td></tr></table></figure>\n\n<p>&amp;emsp;&amp;emsp;如果你要查看某一层的信息，你需要在切换当前的栈，一般来说，程序停止时，最顶层的栈就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是切换当前栈。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">frame<br>f<br>n是一个从0开始的整数，是栈中的层编号。比如：frame 0，表示栈顶，frame 1，表示栈的第二层。<br><br>up<br>表示向栈的上面移动n层，可以不打n，表示向上移动一层。<br><br>down<br>表示向栈的下面移动n层，可以不打n，表示向下移动一层。<br><br>上面的命令，都会打印出移动到的栈层的信息。如果你不想让其打出信息。你可以使用这三个命令：<br><br>select-frame 对应于 frame 命令。<br>up-silently 对应于 up 命令。<br>down-silently 对应于 down 命令。<br></code></pre></td></tr></table></figure>\n\n\n<p>&amp;emsp;&amp;emsp;查看当前栈层的信息，你可以用以下GDB命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">frame 或 f<br>会打印出这些信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。<br><br>info frame<br><br>info f<br><br>这个命令会打印出更为详细的当前栈层的信息，只不过，大多数都是运行时的内内<br>地址。比如：函数地址，调用函数的地址，被调用函数的地址，目前的函数是由什么<br>样的程序语言写成的、函数参数地址及值、局部变量的地址等等。如：<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">(gdb) info f<br>Stack level 0, frame at 0xbffff5d4:<br>eip = 0x804845d <span class=\"hljs-keyword\">in</span> func (tst.c:6); saved eip 0x8048524<br>called by frame at 0xbffff60c<br><span class=\"hljs-built_in\">source</span> language c.<br>Arglist at 0xbffff5d4, args: n=250<br>Locals at 0xbffff5d4, Previous frame<span class=\"hljs-string\">&#x27;s sp is 0x0</span><br><span class=\"hljs-string\">Saved registers:</span><br><span class=\"hljs-string\">ebp at 0xbffff5d4, eip at 0xbffff5d8</span><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>info args<br>打印出当前函数的参数名及其值。</p>\n</blockquote>\n<blockquote>\n<p>info locals<br>打印出当前函数中所有局部变量及其值。</p>\n</blockquote>\n<blockquote>\n<p>info catch<br>打印出当前的函数中的异常处理信息。</p>\n</blockquote>\n<h2 id=\"二、查看源程序\"><a href=\"#二、查看源程序\" class=\"headerlink\" title=\"二、查看源程序\"></a>二、查看源程序</h2><h3 id=\"2-1、显示源代码\"><a href=\"#2-1、显示源代码\" class=\"headerlink\" title=\"2.1、显示源代码\"></a>2.1、显示源代码</h3><p>&amp;emsp;&amp;emsp;GDB 可以打印出所调试程序的源代码，当然，在程序编译时一定要加上-g的参数，把源程序信息编译到执行文件中。不然就看不到源程序了。当程序停下来以后，GDB会报告程序停在了那个文件的第几行上。你可以用list命令来打印程序的源代码。还是来看一看查看源代码的GDB命令吧。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">list<br>显示程序第linenum行的周围的源程序。<br><br>list<br>显示函数名为<span class=\"hljs-keyword\">function</span>的函数的源程序。<br><br>list<br>显示当前行后面的源程序。<br><br>list -<br>显示当前行前面的源程序。<br></code></pre></td></tr></table></figure>\n\n<p>&amp;emsp;&amp;emsp;一般是打印当前行的上5行和下5行，如果显示函数是是上2行下8行，默认是10行，当然，你也可以定制显示的范围，使用下面命令可以设置一次显示源程序的行数。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">set</span> listsize<br>设置一次显示源代码的行数。<br><br>show listsize<br>查看当前listsize的设置。<br><br>list命令还有下面的用法：<br><br>list ,<br>显示从first行到last行之间的源代码。<br><br>list ,<br>显示从当前行到last行之间的源代码。<br><br>list +<br>往后显示源代码。<br></code></pre></td></tr></table></figure>\n\n<p>&amp;emsp;&amp;emsp;一般来说在list后面可以跟以下这们的参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">行号。<br>&lt;+offset&gt; 当前行号的正偏移量。<br>&lt;-offset&gt; 当前行号的负偏移量。<br>哪个文件的哪一行。<br>函数名。<br>哪个文件中的哪个函数。<br>&lt;*address&gt; 程序运行时的语句在内存中的地址。<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-2、搜索源代码\"><a href=\"#2-2、搜索源代码\" class=\"headerlink\" title=\"2.2、搜索源代码\"></a>2.2、搜索源代码</h3><p>不仅如此，GDB还提供了源代码搜索的命令：</p>\n<p>forward-search<br>search<br>向前面搜索。</p>\n<p>reverse-search<br>全部搜索。</p>\n<p>其中，就是正则表达式，也主一个字符串的匹配模式，关于正则表达式，我就不在这里讲了，还请各位查看相关资料。</p>\n<h3 id=\"2-3、指定源文件的路径\"><a href=\"#2-3、指定源文件的路径\" class=\"headerlink\" title=\"2.3、指定源文件的路径\"></a>2.3、指定源文件的路径</h3><p>&amp;emsp;&amp;emsp;某些时候，用-g编译过后的执行程序中只是包括了源文件的名字，没有路径名。GDB提供了可以让你指定源文件的路径的命令，以便GDB进行搜索。<br>directory<br>dir<br>加一个源文件路径到当前路径的前面。如果你要指定多个路径，UNIX下你可以使用“:”，Windows下你可以使用“;”。<br>directory<br>清除所有的自定义的源文件搜索路径信息。</p>\n<p>show directories<br>显示定义了的源文件搜索路径。</p>\n<h3 id=\"2-4、源代码的内存\"><a href=\"#2-4、源代码的内存\" class=\"headerlink\" title=\"2.4、源代码的内存\"></a>2.4、源代码的内存</h3><p>&amp;emsp;&amp;emsp;你可以使用info line命令来查看源代码在内存中的地址。info line后面可以跟“行号”，“函数名”，“文件名:行号”，“文件名:函数名”，这个命令会打印出所指定的源码在运行时的内存地址，如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">(gdb) info line tst.c:func<br>Line 5 of <span class=\"hljs-string\">&quot;tst.c&quot;</span> starts at address 0x8048456 and ends at 0x804845d.<br></code></pre></td></tr></table></figure>\n\n<p>&amp;emsp;&amp;emsp;还有一个命令（disassemble）你可以查看源程序的当前执行时的机器码，这个命令会把目前内存中的指令dump出来。如下面的示例表示查看函数func的汇编代码。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">(gdb) disassemble func<br>Dump of assembler code <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">function</span> func:<br>0x8048450 : push %ebp<br>0x8048451 : mov %esp,%ebp<br>0x8048453 : sub <span class=\"hljs-variable\">$0x18</span>,%esp<br>0x8048456 : movl <span class=\"hljs-variable\">$0x0</span>,0xfffffffc(%ebp)<br>0x804845d : movl <span class=\"hljs-variable\">$0x1</span>,0xfffffff8(%ebp)<br>0x8048464 : mov 0xfffffff8(%ebp),%eax<br>0x8048467 : cmp 0x8(%ebp),%eax<br>0x804846a : jle 0x8048470<br>0x804846c : jmp 0x8048480<br>0x804846e : mov %esi,%esi<br>0x8048470 : mov 0xfffffff8(%ebp),%eax<br>0x8048473 : add %eax,0xfffffffc(%ebp)<br>0x8048476 : incl 0xfffffff8(%ebp)<br>0x8048479 : jmp 0x8048464<br>0x804847b : nop<br>0x804847c : lea 0x0(%esi,1),%esi<br>0x8048480 : mov 0xfffffffc(%ebp),%edx<br>0x8048483 : mov %edx,%eax<br>0x8048485 : jmp 0x8048487<br>0x8048487 : mov %ebp,%esp<br>0x8048489 : pop %ebp<br>0x804848a : ret<br>End of assembler dump.<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、查看运行时数据\"><a href=\"#三、查看运行时数据\" class=\"headerlink\" title=\"三、查看运行时数据\"></a>三、查看运行时数据</h2><p>&amp;emsp;&amp;emsp;在你调试程序时，当程序被停住时，你可以使用print命令（简写命令为p），或是同义命令inspect来查看当前程序的运行数据。print命令的格式是：</p>\n<p>print<br>print &#x2F;<br>是表达式，是你所调试的程序的语言的表达式（GDB可以调试多种编程语言），是输出的格式，比如，如果要把表达式按16进制的格式输出，那么就是&#x2F;x。</p>\n<h3 id=\"3-1、表达式\"><a href=\"#3-1、表达式\" class=\"headerlink\" title=\"3.1、表达式\"></a>3.1、表达式</h3><p>&amp;emsp;&amp;emsp;print和许多GDB的命令一样，可以接受一个表达式，GDB会根据当前的程序运行的数据来计算这个表达式，既然是表达式，那么就可以是当前程序运行中的const常量、变量、函数等内容。可惜的是GDB不能使用你在程序中所定义的宏。</p>\n<p>&amp;emsp;&amp;emsp;表达式的语法应该是当前所调试的语言的语法，由于C&#x2F;C++是一种大众型的语言，所以，本文中的例子都是关于C&#x2F;C++的。（而关于用GDB调试其它语言的章节，我将在后面介绍）</p>\n<p>&amp;emsp;&amp;emsp;在表达式中，有几种GDB所支持的操作符，它们可以用在任何一种语言中。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">@<br>是一个和数组有关的操作符，在后面会有更详细的说明。<br><br>::<br>指定一个在文件或是一个函数中的变量。<br><br>&#123;&#125;<br>表示一个指向内存地址的类型为<span class=\"hljs-built_in\">type</span>的一个对象。<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"3-2、程序变量\"><a href=\"#3-2、程序变量\" class=\"headerlink\" title=\"3.2、程序变量\"></a>3.2、程序变量</h3><p>&amp;emsp;&amp;emsp;在GDB中，你可以随时查看以下三种变量的值：</p>\n<ul>\n<li>1、全局变量（所有文件可见的）</li>\n<li>2、静态全局变量（当前文件可见的）</li>\n<li>3、局部变量（当前Scope可见的）</li>\n</ul>\n<p>&amp;emsp;&amp;emsp;如果你的局部变量和全局变量发生冲突（也就是重名），一般情况下是局部变量会隐藏全局变量，也就是说，如果一个全局变量和一个函数中的局部变量同名时，如果当前停止点在函数中，用print显示出的变量的值会是函数中的局部变量的值。如果此时你想查看全局变量的值时，你可以使用“::”操作符：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">file::variable<br><span class=\"hljs-keyword\">function</span>::variable<br>可以通过这种形式指定你所想查看的变量，是哪个文件中的或是哪个函数中的。例如，查看文件f2.c中的全局变量x的值：<br><br>(gdb) p <span class=\"hljs-string\">&#x27;f2.c&#x27;</span>::x<br><br>当然，“::”操作符会和C++中的发生冲突，GDB能自动识别“::”是否C++的操作符，所以你不必担心在调试C++程序时会出现异常。<br></code></pre></td></tr></table></figure>\n\n<p>&amp;emsp;&amp;emsp;另外，需要注意的是，如果你的程序编译时开启了优化选项，那么在用GDB调试被优化过的程序时，可能会发生某些变量不能访问，或是取值错误码的情况。这个是很正常的，因为优化程序会删改你的程序，整理你程序的语句顺序，剔除一些无意义的<br>变量等，所以在GDB调试这种程序时，运行时的指令和你所编写指令就有不一样，也<br>就会出现你所想象不到的结果。对付这种情况时，需要在编译程序时关闭编译优化。<br>一般来说，几乎所有的编译器都支持编译优化的开关，例如，GNU 的C&#x2F;C++编译器<br>GCC，你可以使用“-gstabs”选项来解决这个问题。关于编译器的参数，还请查看编<br>译器的使用说明文档。</p>\n<h3 id=\"3-3、数组\"><a href=\"#3-3、数组\" class=\"headerlink\" title=\"3.3、数组\"></a>3.3、数组</h3><p>&amp;emsp;&amp;emsp;有时候，你需要查看一段连续的内存空间的值。比如数组的一段，或是动态分配的数据的大小。你可以使用GDB的“@”操作符，“@”的左边是第一个内存的地址的<br>值，“@”的右边则你你想查看内存的长度。例如，你的程序中有这样的语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-type\">int</span> *<span class=\"hljs-built_in\">array</span> = (<span class=\"hljs-type\">int</span> *) <span class=\"hljs-built_in\">malloc</span> (len * <span class=\"hljs-keyword\">sizeof</span> (<span class=\"hljs-type\">int</span>));<br></code></pre></td></tr></table></figure>\n\n<p>&amp;emsp;&amp;emsp;于是，在GDB调试过程中，你可以以如下命令显示出这个动态数组的取值：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\">p *<span class=\"hljs-built_in\">array</span>@len<br></code></pre></td></tr></table></figure>\n\n<p>&amp;emsp;&amp;emsp;@的左边是数组的首地址的值，也就是变量array所指向的内容，右边则是数据的长度，其保存在变量len中，其输出结果，大约是下面这个样子的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">(gdb) p *array@len<br><span class=\"hljs-variable\">$1</span> = &#123;2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32,34, 36, 38, 40&#125;<br></code></pre></td></tr></table></figure>\n\n<p>&amp;emsp;&amp;emsp;如果是静态数组的话，可以直接用print数组名，就可以显示数组中所有数据的内容了。</p>\n<h3 id=\"3-4、输出格式\"><a href=\"#3-4、输出格式\" class=\"headerlink\" title=\"3.4、输出格式\"></a>3.4、输出格式</h3><p>&amp;emsp;&amp;emsp;一般来说，GDB会根据变量的类型输出变量的值。但你也可以自定义GDB的输出的格式。例如，你想输出一个整数的十六进制，或是二进制来查看这个整型变量的中的<br>位的情况。要做到这样，你可以使用GDB的数据显示格式：</p>\n<p>x 按十六进制格式显示变量。<br>d 按十进制格式显示变量。<br>u 按十六进制格式显示无符号整型。<br>o 按八进制格式显示变量。<br>t 按二进制格式显示变量。<br>a 按十六进制格式显示变量。<br>c 按字符格式显示变量。<br>f 按浮点数格式显示变量。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">(gdb) p i<br><span class=\"hljs-variable\">$21</span> = 101<br><br>(gdb) p/a i<br><span class=\"hljs-variable\">$22</span> = 0x65<br><br>(gdb) p/c i<br><span class=\"hljs-variable\">$23</span> = 101 <span class=\"hljs-string\">&#x27;e&#x27;</span><br><br>(gdb) p/f i<br><span class=\"hljs-variable\">$24</span> = 1.41531145e-43<br><br>(gdb) p/x i<br><span class=\"hljs-variable\">$25</span> = 0x65<br><br>(gdb) p/t i<br><span class=\"hljs-variable\">$26</span> = 1100101<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-5、查看内存\"><a href=\"#3-5、查看内存\" class=\"headerlink\" title=\"3.5、查看内存\"></a>3.5、查看内存</h3><p>&amp;emsp;&amp;emsp;你可以使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">x/<br><br>n、f、u是可选的参数。<br></code></pre></td></tr></table></figure>\n\n<p>n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。<br>f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是指令地址，那么格式可以是i。<br>u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。</p>\n<p>u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。</p>\n<p>&amp;emsp;&amp;emsp;当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。</p>\n<p>&amp;emsp;&amp;emsp;表示一个内存地址。</p>\n<p>n&#x2F;f&#x2F;u三个参数可以一起使用。例如：</p>\n<p>命令：x&#x2F;3uh 0x54320表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。</p>\n<h3 id=\"3-6、自动显示\"><a href=\"#3-6、自动显示\" class=\"headerlink\" title=\"3.6、自动显示\"></a>3.6、自动显示</h3><p>&amp;emsp;&amp;emsp;你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">display<br>display/<br>display/<br></code></pre></td></tr></table></figure>\n\n<p>expr是一个表达式，fmt表示显示的格式，addr表示内存地址，当你用display设定好了一个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值。</p>\n<p>格式i和s同样被display支持，一个非常有用的命令是：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">display/i <span class=\"hljs-variable\">$pc</span><br></code></pre></td></tr></table></figure>\n\n<p>$pc是GDB的环境变量，表示着指令的地址，&#x2F;i则表示输出格式为机器指令码，也就是汇编。于是当程序停下后，就会出现源代码和机器指令码相对应的情形，这是一个很有意思的功能。</p>\n<p>下面是一些和display相关的GDB命令：</p>\n<p>undisplay<br>delete display<br>删除自动显示，dnums意为所设置好了的自动显式的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5）</p>\n<p>disable display<br>enable display<br>disable和enalbe不删除自动显示的设置，而只是让其失效和恢复。</p>\n<p>info display<br>查看display设置的自动显示的信息。GDB会打出一张表格，向你报告当然调试中设置了多少个自动显示设置，其中包括，设置的编号，表达式，是否enable。</p>\n<h3 id=\"3-7、设置显示选项\"><a href=\"#3-7、设置显示选项\" class=\"headerlink\" title=\"3.7、设置显示选项\"></a>3.7、设置显示选项</h3><p>&amp;emsp;&amp;emsp;GDB中关于显示的选项比较多，这里我只例举大多数常用的选项。</p>\n<ul>\n<li>set print address</li>\n<li>set print address on</li>\n</ul>\n<p>&amp;emsp;&amp;emsp;打开地址输出，当程序显示函数信息时，GDB会显出函数的参数地址。系统默认为打开的，如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">(gdb) f<br><span class=\"hljs-comment\">#0 set_quotes (lq=0x34c78 &quot;&lt;&lt;&quot;,rq=0x34c88 &quot;&gt;&gt;&quot;)</span><br>at input.c:530<br>530 <span class=\"hljs-keyword\">if</span> (lquote != def_lquote)<br><br><br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> address off<br>关闭函数的参数地址显示，如：<br><br>(gdb) <span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> addr off<br>(gdb) f<br><span class=\"hljs-comment\">#0 set_quotes (lq=&quot;&lt;&lt;&quot;,rq=&quot;&gt;&gt;&quot;) at input.c:530</span><br>530 <span class=\"hljs-keyword\">if</span> (lquote != def_lquote)<br><br>show <span class=\"hljs-built_in\">print</span> address<br>查看当前地址显示选项是否打开。<br><br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> array<br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> array on<br>打开数组显示，打开后当数组显示时，每个元素占一行，如果不打开的话，每个元素则以逗号分隔。这个选项默认是关闭的。与之相关的两个命令如下，我就不再多说了。<br><br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> array off<br>show <span class=\"hljs-built_in\">print</span> array<br><br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> elements<br>这个选项主要是设置数组的，如果你的数组太大了，那么就可以指定一个来指定数据显示的最大长度，当到达这个长度时，GDB就不再往下显示了。如果设置为0，则表示不限制。<br><br>show <span class=\"hljs-built_in\">print</span> elements<br>查看<span class=\"hljs-built_in\">print</span> elements的选项信息。<br><br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> null-stop<br>如果打开了这个选项，那么当显示字符串时，遇到结束符则停止显示。这个选项默认为off。<br><br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> pretty on<br>如果打开<span class=\"hljs-built_in\">printf</span> pretty这个选项，那么当GDB显示结构体时会比较漂亮。如：<br><br><span class=\"hljs-variable\">$1</span> = &#123;<br>next = 0x0,<br>flags = &#123;<br>sweet = 1,<br>sour = 1<br>&#125;,<br>meat = 0x54 <span class=\"hljs-string\">&quot;Pork&quot;</span><br>&#125;<br><br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> pretty off<br>关闭<span class=\"hljs-built_in\">printf</span> pretty这个选项，GDB显示结构体时会如下显示：<br><br><span class=\"hljs-variable\">$1</span> = &#123;next = 0x0, flags = &#123;sweet = 1, sour = 1&#125;, meat = 0x54<span class=\"hljs-string\">&quot;Pork&quot;</span>&#125;<br><br>show <span class=\"hljs-built_in\">print</span> pretty<br>查看GDB是如何显示结构体的。<br><br><br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> sevenbit-strings<br>设置字符显示，是否按“\\nnn”的格式显示，如果打开，则字符串或字符数据按\\nnn显示，如“\\065”。<br><br>show <span class=\"hljs-built_in\">print</span> sevenbit-strings<br>查看字符显示开关是否打开。<br><br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> union<br>设置显示结构体时，是否显式其内的联合体数据。例如有以下数据结构：<br><br>typedef enum &#123;Tree, Bug&#125; Species;<br>typedef enum &#123;Big_tree, Acorn, Seedling&#125; Tree_forms;<br>typedef enum &#123;Caterpillar, Cocoon, Butterfly&#125;<br>Bug_forms;<br><br>struct thing &#123;<br>Species it;<br>union &#123;<br>Tree_forms tree;<br>Bug_forms bug;<br>&#125; form;<br>&#125;;<br><br>struct thing foo = &#123;Tree, &#123;Acorn&#125;&#125;;<br><br>当打开这个开关时，执行 p foo 命令后，会如下显示：<br><span class=\"hljs-variable\">$1</span> = &#123;it = Tree, form = &#123;tree = Acorn, bug = Cocoon&#125;&#125;<br><br>当关闭这个开关时，执行 p foo 命令后，会如下显示：<br><span class=\"hljs-variable\">$1</span> = &#123;it = Tree, form = &#123;...&#125;&#125;<br><br>show <span class=\"hljs-built_in\">print</span> union<br>查看联合体数据的显示方式<br><br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> object<br>在C++中，如果一个对象指针指向其派生类，如果打开这个选项，GDB会自动按照虚方法调用的规则显示输出，如果关闭这个选项的话，GDB就不管虚函数表了。这个选项默认是off。<br><br>show <span class=\"hljs-built_in\">print</span> object<br>查看对象选项的设置。<br><br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> static-members<br>这个选项表示，当显示一个C++对象中的内容是，是否显示其中的静态数据成员。默认是on。<br><br>show <span class=\"hljs-built_in\">print</span> static-members<br>查看静态数据成员选项设置。<br><br><span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">print</span> vtbl<br>当此选项打开时，GDB将用比较规整的格式来显示虚函数表时。其默认是关闭的。<br><br>show <span class=\"hljs-built_in\">print</span> vtbl<br>查看虚函数显示格式的选项。<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-8、历史记录\"><a href=\"#3-8、历史记录\" class=\"headerlink\" title=\"3.8、历史记录\"></a>3.8、历史记录</h3><p>&amp;emsp;&amp;emsp;当你用GDB的print查看程序运行时的数据时，你每一个print都会被GDB记录下来。<br>&amp;emsp;&amp;emsp;GDB会以$1, $2, $3 …..这样的方式为你每一个print命令编上号。于是，你可以使用这个编号访问以前的表达式，如$1。这个功能所带来的好处是，如果你先前输入了一个比较长的表达式，如果你还想查看这个表达式的值，你可以使用历史记录<br>来访问，省去了重复输入。</p>\n<h3 id=\"3-9、GDB环境变量\"><a href=\"#3-9、GDB环境变量\" class=\"headerlink\" title=\"3.9、GDB环境变量\"></a>3.9、GDB环境变量</h3><p>&amp;emsp;&amp;emsp;你可以在GDB的调试环境中定义自己的变量，用来保存一些调试程序中的运行数据。要定义一个GDB的变量很简单只需。使用GDB的set命令。GDB的环境变量和UNIX一样，也是以$起头。如：</p>\n<blockquote>\n<p>set $foo &#x3D; *object_ptr</p>\n</blockquote>\n<p>&amp;emsp;&amp;emsp;使用环境变量时，GDB会在你第一次使用时创建这个变量，而在以后的使用中，则直接对其賦值。环境变量没有类型，你可以给环境变量定义任一的类型。包括结构体和数组。</p>\n<blockquote>\n<p>show convenience<br>&#x2F;&#x2F;该命令查看当前所设置的所有的环境变量。</p>\n</blockquote>\n<p>&amp;emsp;&amp;emsp;这是一个比较强大的功能，环境变量和程序变量的交互使用，将使得程序调试更为灵活便捷。例如：</p>\n<blockquote>\n<p>set $i &#x3D; 0</p>\n<p>print bar[$i++]-&gt;contents</p>\n</blockquote>\n<p>&amp;emsp;&amp;emsp;于是，当你就不必，print bar[0]-&gt;contents, printbar[1]-&gt;contents地输入命令了。输入这样的命令后，只用敲回车，重复执行上一条语句，环境变量会自动累加，从而完成逐个输出的功能。</p>\n<h3 id=\"3-10、查看寄存器\"><a href=\"#3-10、查看寄存器\" class=\"headerlink\" title=\"3.10、查看寄存器\"></a>3.10、查看寄存器</h3><p>&amp;emsp;&amp;emsp;要查看寄存器的值，很简单，可以使用如下命令：</p>\n<blockquote>\n<p>info registers<br>&#x2F;&#x2F;查看寄存器的情况。（除了浮点寄存器）</p>\n</blockquote>\n<blockquote>\n<p>info all-registers<br>查看所有寄存器的情况。（包括浮点寄存器）</p>\n</blockquote>\n<blockquote>\n<p>info registers<br>查看所指定的寄存器的情况。</p>\n</blockquote>\n<p>&amp;emsp;&amp;emsp;寄存器中放置了程序运行时的数据，比如程序当前运行的指令地址（ip），程序的当前堆栈地址（sp）等等。你同样可以使用print命令来访问寄存器的情况，只需要在寄存器名字前加一个$符号就可以了。如：p $eip。</p>\n<h2 id=\"四、改变程序的执行\"><a href=\"#四、改变程序的执行\" class=\"headerlink\" title=\"四、改变程序的执行\"></a>四、改变程序的执行</h2><p>&amp;emsp;&amp;emsp;一旦使用GDB挂上被调试程序，当程序运行起来后，你可以根据自己的调试思路来动态地在GDB中更改当前被调试程序的运行线路或是其变量的值，这个强大的功能能够让你更好的调试你的程序，比如，你可以在程序的一次运行中走遍程序的所有分支。</p>\n<h3 id=\"4-1、修改变量值\"><a href=\"#4-1、修改变量值\" class=\"headerlink\" title=\"4.1、修改变量值\"></a>4.1、修改变量值</h3><p>&amp;emsp;&amp;emsp;修改被调试程序运行时的变量值，在GDB中很容易实现，使用GDB的print命令即可完成。如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">(gdb) <span class=\"hljs-built_in\">print</span> x=4<br><br>x=4这个表达式是C/C++的语法，意为把变量x的值修改为4，如果你当前调试的语言是Pascal，那么你可以使用Pascal的语法：x:=4。<br><br>在某些时候，很有可能你的变量和GDB中的参数冲突，如：<br><br>(gdb) whatis width<br><span class=\"hljs-built_in\">type</span> = double<br>(gdb) p width<br><span class=\"hljs-variable\">$4</span> = 13<br>(gdb) <span class=\"hljs-built_in\">set</span> width=47<br>Invalid syntax <span class=\"hljs-keyword\">in</span> expression.<br><br>因为，<span class=\"hljs-built_in\">set</span> width是GDB的命令，所以，出现了“Invalid syntax inexpression”的设置错误，此时，你可以使用setvar命令来告诉GDB，width不是你GDB的参数，而是程序的变量名，如：<br><br>(gdb) <span class=\"hljs-built_in\">set</span> var width=47<br><br>另外，还可能有些情况，GDB并不报告这种错误，所以保险起见，在你改变程序变量取值时，最好都使用setvar格式的GDB命令。<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-2、跳转执行\"><a href=\"#4-2、跳转执行\" class=\"headerlink\" title=\"4.2、跳转执行\"></a>4.2、跳转执行</h3><p>&amp;emsp;&amp;emsp;一般来说，被调试程序会按照程序代码的运行顺序依次执行。GDB提供了乱序执行的功能，也就是说，GDB可以修改程序的执行顺序，可以让程序执行随意跳跃。这个功能可以由GDB的jump命令来完：</p>\n<p>jump<br>指定下一条语句的运行点。可以是文件的行号，可以是file:line格式，可以是+num这种偏移量格式。表式着下一条运行语句从哪里开始。</p>\n<p>jump</p>\n<p>这里的是代码行的内存地址。</p>\n<p>&amp;emsp;&amp;emsp;注意，jump命令不会改变当前的程序栈中的内容，所以，当你从一个函数跳到另一个函数时，当函数运行完返回时进行弹栈操作时必然会发生错误，可能结果还是非常<br>奇怪的，甚至于产生程序Core Dump。所以最好是同一个函数中进行跳转。</p>\n<p>&amp;emsp;&amp;emsp;熟悉汇编的人都知道，程序运行时，有一个寄存器用于保存当前代码所在的内存地址。所以，jump命令也就是改变了这个寄存器中的值。于是，你可以使用“set $pc”来更改跳转执行的地址。如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">set</span> <span class=\"hljs-variable\">$pc</span> = 0x485<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"4-3、产生信号量\"><a href=\"#4-3、产生信号量\" class=\"headerlink\" title=\"4.3、产生信号量\"></a>4.3、产生信号量</h3><p>&amp;emsp;&amp;emsp;使用singal命令，可以产生一个信号量给被调试的程序。如：中断信号Ctrl+C。这非常方便于程序的调试，可以在程序运行的任意位置设置断点，并在该断点用GDB产生一个信号量，这种精确地在某处产生信号非常有利程序的调试。</p>\n<p>&amp;emsp;&amp;emsp;语法是：signal ，UNIX的系统信号量通常从1到15。所以取值也在这个范围。</p>\n<p>&amp;emsp;&amp;emsp;single命令和shell的kill命令不同，系统的kill命令发信号给被调试程序时，是由GDB截获的，而single命令所发出一信号则是直接发给被调试程序的。</p>\n<h3 id=\"4-4、强制函数返回\"><a href=\"#4-4、强制函数返回\" class=\"headerlink\" title=\"4.4、强制函数返回\"></a>4.4、强制函数返回</h3><p>&amp;emsp;&amp;emsp;如果你的调试断点在某个函数中，并还有语句没有执行完。你可以使用return命令强制函数忽略还没有执行的语句并返回。</p>\n<p>return<br>return<br>&amp;emsp;&amp;emsp;使用return命令取消当前函数的执行，并立即返回，如果指定了，那么该表达式的值会被认作函数的返回值。</p>\n<h3 id=\"4-5、强制调用函数\"><a href=\"#4-5、强制调用函数\" class=\"headerlink\" title=\"4.5、强制调用函数\"></a>4.5、强制调用函数</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">call<br></code></pre></td></tr></table></figure>\n\n<p>&amp;emsp;&amp;emsp;表达式中可以一是函数，以此达到强制调用函数的目的。并显示函数的返回值，如果函数返回值是void，那么就不显示。</p>\n<p>&amp;emsp;&amp;emsp;另一个相似的命令也可以完成这一功能——print，print后面可以跟表达式，所以也可以用他来调用函数，print和call的不同是，如果函数返回void，call则不显示，print则显示函数返回值，并把该值存入历史数据中。</p>\n<h2 id=\"五、在不同语言中使用GDB\"><a href=\"#五、在不同语言中使用GDB\" class=\"headerlink\" title=\"五、在不同语言中使用GDB\"></a>五、在不同语言中使用GDB</h2><p>&amp;emsp;&amp;emsp;GDB支持下列语言：C, C++, Fortran, PASCAL, Java, Chill, assembly, 和Modula-2。一般说来，GDB会根据你所调试的程序来确定当然的调试语言，比如：发现文件名后缀为“.c”的，GDB会认为是C程序。文件名后缀为 “.C, .cc, .cp, .cpp, .cxx, .c++”的，GDB会认为是C++程序。而后缀是“.f, .F”的，GDB会认为是Fortran程序，还有，后缀为如果是“.s, .S”的会认为是汇编语言。</p>\n<p>&amp;emsp;&amp;emsp;也就是说，GDB会根据你所调试的程序的语言，来设置自己的语言环境，并让GDB的命令跟着语言环境的改变而改变。比如一些GDB命令需要用到表达式或变量时，这些<br>表达式或变量的语法，完全是根据当前的语言环境而改变的。例如C&#x2F;C++中对指针<br>的语法是*p，而在Modula-2中则是p^。并且，如果你当前的程序是由几种不同语言<br>一同编译成的，那到在调试过程中，GDB也能根据不同的语言自动地切换语言环境。<br>这种跟着语言环境而改变的功能，真是体贴开发人员的一种设计。</p>\n<p>&amp;emsp;&amp;emsp;下面是几个相关于GDB语言环境的命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">show language<br>查看当前的语言环境。如果GDB不能识为你所调试的编程语言，那么，C语言被认为是默认的环境。<br><br>info frame<br>查看当前函数的程序语言。<br><br>info <span class=\"hljs-built_in\">source</span><br>查看当前文件的程序语言。<br></code></pre></td></tr></table></figure>\n\n<p>如果GDB没有检测出当前的程序语言，那么你也可以手动设置当前的程序语言。使用set language命令即可做到。</p>\n<p>当set language命令后什么也不跟的话，你可以查看GDB所支持的语言种类：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">(gdb) <span class=\"hljs-built_in\">set</span> language<br>The currently understood settings are:<br><br><span class=\"hljs-built_in\">local</span> or auto Automatic setting based on <span class=\"hljs-built_in\">source</span> file<br>c Use the C language<br>c++ Use the C++ language<br>asm Use the Asm language<br>chill Use the Chill language<br>fortran Use the Fortran language<br>java Use the Java language<br>modula-2 Use the Modula-2 language<br>pascal Use the Pascal language<br>scheme Use the Scheme language<br></code></pre></td></tr></table></figure>\n\n<p>&amp;emsp;&amp;emsp;于是你可以在set language后跟上被列出来的程序语言名，来设置当前的语言环境。</p>\n"},{"title":"Materialize","date":"2017-05-02T14:09:56.000Z","thumbnail":null,"_content":"\n基于Material Design的现代响应式前端框架\n\n## 开始使用\n\n## 后端部署配置ss-panel教程\n","source":"_posts/Materialize.md","raw":"---\ntitle: Materialize\ndate: 2017-05-02 22:09:56\ntags:\ncategories: 技术向\nthumbnail: \n---\n\n基于Material Design的现代响应式前端框架\n\n## 开始使用\n\n## 后端部署配置ss-panel教程\n","slug":"Materialize","published":1,"updated":"2021-12-12T14:25:37.269Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3bsl2ie00065awqh3401u48","content":"<p>基于Material Design的现代响应式前端框架</p>\n<h2 id=\"开始使用\"><a href=\"#开始使用\" class=\"headerlink\" title=\"开始使用\"></a>开始使用</h2><h2 id=\"后端部署配置ss-panel教程\"><a href=\"#后端部署配置ss-panel教程\" class=\"headerlink\" title=\"后端部署配置ss-panel教程\"></a>后端部署配置ss-panel教程</h2>","site":{"data":{}},"wordcount":46,"excerpt":"","more":"<p>基于Material Design的现代响应式前端框架</p>\n<h2 id=\"开始使用\"><a href=\"#开始使用\" class=\"headerlink\" title=\"开始使用\"></a>开始使用</h2><h2 id=\"后端部署配置ss-panel教程\"><a href=\"#后端部署配置ss-panel教程\" class=\"headerlink\" title=\"后端部署配置ss-panel教程\"></a>后端部署配置ss-panel教程</h2>"},{"title":"PyMySQL","date":"2016-11-18T09:15:28.000Z","thumbnail":null,"_content":"\npymsql是Python中操作MySQL的模块，其使用方法和MySQLdb几乎相同。但目前pymysql支持python3.x而后者不支持3.x版本。\n\n## 前言\n\n本文测试python版本：2.7.11。mysql版本：5.6.24\n\n## 安装\n``` bash\n$ pip3 install pymysql\n```\n## 使用操作\n\n### 执行SQL\n``` bash\n$ #!/usr/bin/env pytho\n$ # -*- coding:utf-8 -*-\n$ import pymysql\n  \n$ # 创建连接\n$ conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1', $ charset='utf8')\n$ # 创建游标\ncursor = conn.cursor()\n  \n$ # 执行SQL，并返回收影响行数\n$ effect_row = cursor.execute(\"select * from tb7\")\n  \n$ # 执行SQL，并返回受影响行数\n$ #effect_row = cursor.execute(\"update tb7 set pass = '123' where nid = %s\", (11,))\n  \n$ # 执行SQL，并返回受影响行数,执行多次\n$ #effect_row = cursor.executemany(\"insert into tb7(user,pass,licnese)values(%s,%s,%s)\", [(\"u1\",\"u1pass\",\"11111\"),(\"u2\",\"u2pass\",\"22222\")])\n\n  \n$ # 提交，不然无法保存新建或者修改的数据\n$ conn.commit()\n  \n$ # 关闭游标\n$ cursor.close()\n$ # 关闭连接\n$ conn.close()\n$ 注意：存在中文的时候，连接需要添加charset='utf8'，否则中文显示乱码。\n\n```\n\n### 获取查询数据\n``` bash\n$ #! /usr/bin/env python\n$ # -*- coding:utf-8 -*-\n$\n$ import pymysql\n \n$ conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')\n$ cursor = conn.cursor()\n$ cursor.execute(\"select * from tb7\")\n \n$ # 获取剩余结果的第一行数据\n$ row_1 = cursor.fetchone()\n$ print row_1\n$ # 获取剩余结果前n行数据\n$ # row_2 = cursor.fetchmany(3)\n \n$ # 获取剩余结果所有数据\n$ # row_3 = cursor.fetchall()\n \n$ conn.commit()\n$ cursor.close()\n$ conn.close()\n```\n\n### 获取新创建数据自增ID\n\n可以获取到最新自增的ID，也就是最后插入的一条数据ID\n``` bash\n#! /usr/bin/env python\n# -*- coding:utf-8 -*-\n\nimport pymysql\n \nconn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')\ncursor = conn.cursor()\neffect_row = cursor.executemany(\"insert into tb7(user,pass,licnese)values(%s,%s,%s)\", [(\"u3\",\"u3pass\",\"11113\"),(\"u4\",\"u4pass\",\"22224\")])\nconn.commit()\ncursor.close()\nconn.close()\n#获取自增id\nnew_id = cursor.lastrowid      \nprint new_id\n```\n\n### 移动游标\n\n操作都是靠游标，那对游标的控制也是必须的\n\n注：在fetch数据时按照顺序进行，可以使用cursor.scroll(num,mode)来移动游标位置，如：\n \n``` bash\n$ cursor.scroll(1,mode='relative') # 相对当前位置移动\n$ cursor.scroll(2,mode='absolute') # 相对绝对位置移动\n```\n\n### fetch数据类型\n\n关于默认获取的数据是元祖类型，如果想要或者字典类型的数据，即：\n``` bash\n$ #! /usr/bin/env python\n$ # -*- coding:utf-8 -*-\n\n$ import pymysql\n \n$ conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')\n$ #游标设置为字典类型\n$ cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)\n$ cursor.execute(\"select * from tb7\")\n \n$ row_1 = cursor.fetchone()\n$ print row_1　　#{u'licnese': 213, u'user': '123', u'nid': 10, u'pass': '213'}\n \n$ conn.commit()\n$ cursor.close()\n$ conn.close()\n``` \n\n### 调用存储过程\n\na、调用无参存储过程\n\n``` bash\n$ #! /usr/bin/env python\n$ # -*- coding:utf-8 -*-\n\n \n$ import pymysql\n \n$ conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')\n$ #游标设置为字典类型\n$ cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)\n$ #无参数存储过程\n$ cursor.callproc('p2')  #等价于cursor.execute(\"call p2()\")\n \n$ row_1 = cursor.fetchone()\n$ print row_1\n \n \n$ conn.commit()\n$ cursor.close()\n$ conn.close()\n``` \n\nb、调用有参存储过程\n\n``` bash\n$ #! /usr/bin/env python\n$ # -*- coding:utf-8 -*-\n \n$ import pymysql\n \n$ conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')\n$ cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)\n \n$ cursor.callproc('p1', args=(1, 22, 3, 4))\n$ #获取执行完存储的参数,参数@开头\n$ cursor.execute(\"select @p1,@_p1_1,@_p1_2,@_p1_3\")  #{u'@_p1_1': 22, u'@p1': None, u'@_p1_2': 103, u'@_p1_3': 24}\n$ row_1 = cursor.fetchone()\n$ print row_1\n \n \n$ conn.commit()\n$ cursor.close()\n$ conn.close()\n``` \n\n## 关于pymysql防注入\n\n### 字符串拼接查询，造成注入\n\n正常查询语句：\n\n``` bash\n$ #! /usr/bin/env python\n$ # -*- coding:utf-8 -*-\n\n$ import pymysql\n \n$ conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')\n$ cursor = conn.cursor()\n$ user=\"u1\"\n$ passwd=\"u1pass\"\n$ #正常构造语句的情况\n$ sql=\"select user,pass from tb7 where user='%s' and pass='%s'\" % (user,passwd)\n$ #sql=select user,pass from tb7 where user='u1' and pass='u1pass'\n$ row_count=cursor.execute(sql) row_1 = cursor.fetchone()\n$ print row_count,row_1\n \n$ conn.commit()\n$ cursor.close()\n$ conn.close()\n```\n\n构造注入语句：\n``` bash\n$ #! /usr/bin/env python\n$ # -*- coding:utf-8 -*-\n\n$ import pymysql\n \n$ conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')\n$ cursor = conn.cursor()\n \n$ user=\"u1' or '1'-- \"\n$ passwd=\"u1pass\"\n$ sql=\"select user,pass from tb7 where user='%s' and pass='%s'\" % (user,passwd)\n \n$ #拼接语句被构造成下面这样，永真条件，此时就注入成功了。因此要避免这种情况需使用pymysql提供的参数化查询。\n$ #select user,pass from tb7 where user='u1' or '1'-- ' and pass='u1pass'\n \n$ row_count=cursor.execute(sql)\n$ row_1 = cursor.fetchone()\n$ print row_count,row_1\n \n \n$ conn.commit()\n$ cursor.close()\n$ conn.close()\n```\n\n### 避免注入，使用pymysql提供的参数化语句\n\n正常参数化查询\n\n```bash\n$ #! /usr/bin/env python\n$ # -*- coding:utf-8 -*-\n\n \n$ import pymysql\n \n$ conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')\n$ cursor = conn.cursor()\n$ user=\"u1\"\n$ passwd=\"u1pass\"\n$ #执行参数化查询\n$ row_count=cursor.execute(\"select user,pass from tb7 where user=%s and pass=%s\",(user,passwd))\n$ row_1 = cursor.fetchone()\n$ print row_count,row_1\n \n$ conn.commit()\n$ cursor.close()\n$ conn.close()\n\n构造注入，参数化查询注入失败。\n\n```bash\n$ #! /usr/bin/env python\n$ # -*- coding:utf-8 -*-\n\n$ import pymysql\n \n$ conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')\n$ cursor = conn.cursor()\n \n$ user=\"u1' or '1'-- \"\n$ passwd=\"u1pass\"\n$ #执行参数化查询\n$ row_count=cursor.execute(\"select user,pass from tb7 where user=%s and pass=%s\",(user,passwd))\n$ #内部执行参数化生成的SQL语句，对特殊字符进行了加\\转义，避免注入语句生成。\n$ # sql=cursor.mogrify(\"select user,pass from tb7 where user=%s and pass=%s\",(user,passwd))\n$ # print sql\n$ #select user,pass from tb7 where user='u1\\' or \\'1\\'-- ' and pass='u1pass'被转义的语句。\n \n$ row_1 = cursor.fetchone()\n$ print row_count,row_1\n \n$ conn.commit()\n$ cursor.close()\n$ conn.close()\n```\n\n结论：excute执行SQL语句的时候，必须使用参数化的方式，否则必然产生SQL注入漏洞。\n\n## 使用存mysql储过程动态执行SQL防注入\n\n使用MYSQL存储过程自动提供防注入，动态传入SQL到存储过程执行语句。\n\n```bash\n$ delimiter \\\\\n$ DROP PROCEDURE IF EXISTS proc_sql \\\\\n$ CREATE PROCEDURE proc_sql (\n$   in nid1 INT,\n$   in nid2 INT,\n$   in callsql VARCHAR(255)\n$   )\n$ BEGIN\n$   set @nid1 = nid1;\n$   set @nid2 = nid2;\n$   set @callsql = callsql;\n$     PREPARE myprod FROM @callsql;\n$ --   PREPARE prod FROM 'select * from tb2 where nid>? and nid<?';  传入的值为字符串，？为占位符\n$ --   用@p1，和@p2填充占位符\n$     EXECUTE myprod USING @nid1,@nid2;\n$   DEALLOCATE prepare myprod;\n \n$ END\\\\\n$ delimiter ;\n\n$ set @nid1=12;\n$ set @nid2=15;\n$ set @callsql = 'select * from tb7 where nid>? and nid<?';\n$ CALL proc_sql(@nid1,@nid2,@callsql)\n```\n\npymsql中调用\n\n```bash\n$ #! /usr/bin/env python\n$ # -*- coding:utf-8 -*-\n\n$ import pymysql\n \n$ conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')\n$ cursor = conn.cursor()\n$ mysql=\"select * from tb7 where nid>? and nid<?\"\n$ cursor.callproc('proc_sql', args=(11, 15, mysql))\n \n$ rows = cursor.fetchall()\n$ print rows #((12, 'u1', 'u1pass', 11111), (13, 'u2', 'u2pass', 22222), (14, 'u3', 'u3pass', 11113))\n$ conn.commit()\n$ cursor.close()\n$ conn.close()\n```\n\n## 使用with简化连接过程\n\n每次都连接关闭很麻烦，使用上下文管理，简化连接过程\n\n```bash\n$ #! /usr/bin/env python\n$ # -*- coding:utf-8 -*-\n\n \nimport pymysql\nimport contextlib\n$ #定义上下文管理器，连接后自动关闭连接\n@contextlib.contextmanager\ndef mysql(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1',charset='utf8'):\n  conn = pymysql.connect(host=host, port=port, user=user, passwd=passwd, db=db, charset=charset)\n  cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)\n  try:\n    yield cursor\n  finally:\n    conn.commit()\n    cursor.close()\n    conn.close()\n \n$ # 执行sql\nwith mysql() as cursor:\n  print(cursor)\n  row_count = cursor.execute(\"select * from tb7\")\n  row_1 = cursor.fetchone()\n  print row_count, row_1\n```\n\n## 总结\n\n以上就是关于Python中pymysql模块的全部内容，希望对大家学习或使用python能有一定的帮助，如果有疑问大家可以留言交流。\n","source":"_posts/PyMySQL.md","raw":"---\ntitle: PyMySQL\ndate: 2016-11-18 17:15:28\ntags:\ncategories: 技术向\nthumbnail: # http://i2.muimg.com/567571/98262c0ef87fbc73.png\n---\n\npymsql是Python中操作MySQL的模块，其使用方法和MySQLdb几乎相同。但目前pymysql支持python3.x而后者不支持3.x版本。\n\n## 前言\n\n本文测试python版本：2.7.11。mysql版本：5.6.24\n\n## 安装\n``` bash\n$ pip3 install pymysql\n```\n## 使用操作\n\n### 执行SQL\n``` bash\n$ #!/usr/bin/env pytho\n$ # -*- coding:utf-8 -*-\n$ import pymysql\n  \n$ # 创建连接\n$ conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1', $ charset='utf8')\n$ # 创建游标\ncursor = conn.cursor()\n  \n$ # 执行SQL，并返回收影响行数\n$ effect_row = cursor.execute(\"select * from tb7\")\n  \n$ # 执行SQL，并返回受影响行数\n$ #effect_row = cursor.execute(\"update tb7 set pass = '123' where nid = %s\", (11,))\n  \n$ # 执行SQL，并返回受影响行数,执行多次\n$ #effect_row = cursor.executemany(\"insert into tb7(user,pass,licnese)values(%s,%s,%s)\", [(\"u1\",\"u1pass\",\"11111\"),(\"u2\",\"u2pass\",\"22222\")])\n\n  \n$ # 提交，不然无法保存新建或者修改的数据\n$ conn.commit()\n  \n$ # 关闭游标\n$ cursor.close()\n$ # 关闭连接\n$ conn.close()\n$ 注意：存在中文的时候，连接需要添加charset='utf8'，否则中文显示乱码。\n\n```\n\n### 获取查询数据\n``` bash\n$ #! /usr/bin/env python\n$ # -*- coding:utf-8 -*-\n$\n$ import pymysql\n \n$ conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')\n$ cursor = conn.cursor()\n$ cursor.execute(\"select * from tb7\")\n \n$ # 获取剩余结果的第一行数据\n$ row_1 = cursor.fetchone()\n$ print row_1\n$ # 获取剩余结果前n行数据\n$ # row_2 = cursor.fetchmany(3)\n \n$ # 获取剩余结果所有数据\n$ # row_3 = cursor.fetchall()\n \n$ conn.commit()\n$ cursor.close()\n$ conn.close()\n```\n\n### 获取新创建数据自增ID\n\n可以获取到最新自增的ID，也就是最后插入的一条数据ID\n``` bash\n#! /usr/bin/env python\n# -*- coding:utf-8 -*-\n\nimport pymysql\n \nconn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')\ncursor = conn.cursor()\neffect_row = cursor.executemany(\"insert into tb7(user,pass,licnese)values(%s,%s,%s)\", [(\"u3\",\"u3pass\",\"11113\"),(\"u4\",\"u4pass\",\"22224\")])\nconn.commit()\ncursor.close()\nconn.close()\n#获取自增id\nnew_id = cursor.lastrowid      \nprint new_id\n```\n\n### 移动游标\n\n操作都是靠游标，那对游标的控制也是必须的\n\n注：在fetch数据时按照顺序进行，可以使用cursor.scroll(num,mode)来移动游标位置，如：\n \n``` bash\n$ cursor.scroll(1,mode='relative') # 相对当前位置移动\n$ cursor.scroll(2,mode='absolute') # 相对绝对位置移动\n```\n\n### fetch数据类型\n\n关于默认获取的数据是元祖类型，如果想要或者字典类型的数据，即：\n``` bash\n$ #! /usr/bin/env python\n$ # -*- coding:utf-8 -*-\n\n$ import pymysql\n \n$ conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')\n$ #游标设置为字典类型\n$ cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)\n$ cursor.execute(\"select * from tb7\")\n \n$ row_1 = cursor.fetchone()\n$ print row_1　　#{u'licnese': 213, u'user': '123', u'nid': 10, u'pass': '213'}\n \n$ conn.commit()\n$ cursor.close()\n$ conn.close()\n``` \n\n### 调用存储过程\n\na、调用无参存储过程\n\n``` bash\n$ #! /usr/bin/env python\n$ # -*- coding:utf-8 -*-\n\n \n$ import pymysql\n \n$ conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')\n$ #游标设置为字典类型\n$ cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)\n$ #无参数存储过程\n$ cursor.callproc('p2')  #等价于cursor.execute(\"call p2()\")\n \n$ row_1 = cursor.fetchone()\n$ print row_1\n \n \n$ conn.commit()\n$ cursor.close()\n$ conn.close()\n``` \n\nb、调用有参存储过程\n\n``` bash\n$ #! /usr/bin/env python\n$ # -*- coding:utf-8 -*-\n \n$ import pymysql\n \n$ conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')\n$ cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)\n \n$ cursor.callproc('p1', args=(1, 22, 3, 4))\n$ #获取执行完存储的参数,参数@开头\n$ cursor.execute(\"select @p1,@_p1_1,@_p1_2,@_p1_3\")  #{u'@_p1_1': 22, u'@p1': None, u'@_p1_2': 103, u'@_p1_3': 24}\n$ row_1 = cursor.fetchone()\n$ print row_1\n \n \n$ conn.commit()\n$ cursor.close()\n$ conn.close()\n``` \n\n## 关于pymysql防注入\n\n### 字符串拼接查询，造成注入\n\n正常查询语句：\n\n``` bash\n$ #! /usr/bin/env python\n$ # -*- coding:utf-8 -*-\n\n$ import pymysql\n \n$ conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')\n$ cursor = conn.cursor()\n$ user=\"u1\"\n$ passwd=\"u1pass\"\n$ #正常构造语句的情况\n$ sql=\"select user,pass from tb7 where user='%s' and pass='%s'\" % (user,passwd)\n$ #sql=select user,pass from tb7 where user='u1' and pass='u1pass'\n$ row_count=cursor.execute(sql) row_1 = cursor.fetchone()\n$ print row_count,row_1\n \n$ conn.commit()\n$ cursor.close()\n$ conn.close()\n```\n\n构造注入语句：\n``` bash\n$ #! /usr/bin/env python\n$ # -*- coding:utf-8 -*-\n\n$ import pymysql\n \n$ conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')\n$ cursor = conn.cursor()\n \n$ user=\"u1' or '1'-- \"\n$ passwd=\"u1pass\"\n$ sql=\"select user,pass from tb7 where user='%s' and pass='%s'\" % (user,passwd)\n \n$ #拼接语句被构造成下面这样，永真条件，此时就注入成功了。因此要避免这种情况需使用pymysql提供的参数化查询。\n$ #select user,pass from tb7 where user='u1' or '1'-- ' and pass='u1pass'\n \n$ row_count=cursor.execute(sql)\n$ row_1 = cursor.fetchone()\n$ print row_count,row_1\n \n \n$ conn.commit()\n$ cursor.close()\n$ conn.close()\n```\n\n### 避免注入，使用pymysql提供的参数化语句\n\n正常参数化查询\n\n```bash\n$ #! /usr/bin/env python\n$ # -*- coding:utf-8 -*-\n\n \n$ import pymysql\n \n$ conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')\n$ cursor = conn.cursor()\n$ user=\"u1\"\n$ passwd=\"u1pass\"\n$ #执行参数化查询\n$ row_count=cursor.execute(\"select user,pass from tb7 where user=%s and pass=%s\",(user,passwd))\n$ row_1 = cursor.fetchone()\n$ print row_count,row_1\n \n$ conn.commit()\n$ cursor.close()\n$ conn.close()\n\n构造注入，参数化查询注入失败。\n\n```bash\n$ #! /usr/bin/env python\n$ # -*- coding:utf-8 -*-\n\n$ import pymysql\n \n$ conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')\n$ cursor = conn.cursor()\n \n$ user=\"u1' or '1'-- \"\n$ passwd=\"u1pass\"\n$ #执行参数化查询\n$ row_count=cursor.execute(\"select user,pass from tb7 where user=%s and pass=%s\",(user,passwd))\n$ #内部执行参数化生成的SQL语句，对特殊字符进行了加\\转义，避免注入语句生成。\n$ # sql=cursor.mogrify(\"select user,pass from tb7 where user=%s and pass=%s\",(user,passwd))\n$ # print sql\n$ #select user,pass from tb7 where user='u1\\' or \\'1\\'-- ' and pass='u1pass'被转义的语句。\n \n$ row_1 = cursor.fetchone()\n$ print row_count,row_1\n \n$ conn.commit()\n$ cursor.close()\n$ conn.close()\n```\n\n结论：excute执行SQL语句的时候，必须使用参数化的方式，否则必然产生SQL注入漏洞。\n\n## 使用存mysql储过程动态执行SQL防注入\n\n使用MYSQL存储过程自动提供防注入，动态传入SQL到存储过程执行语句。\n\n```bash\n$ delimiter \\\\\n$ DROP PROCEDURE IF EXISTS proc_sql \\\\\n$ CREATE PROCEDURE proc_sql (\n$   in nid1 INT,\n$   in nid2 INT,\n$   in callsql VARCHAR(255)\n$   )\n$ BEGIN\n$   set @nid1 = nid1;\n$   set @nid2 = nid2;\n$   set @callsql = callsql;\n$     PREPARE myprod FROM @callsql;\n$ --   PREPARE prod FROM 'select * from tb2 where nid>? and nid<?';  传入的值为字符串，？为占位符\n$ --   用@p1，和@p2填充占位符\n$     EXECUTE myprod USING @nid1,@nid2;\n$   DEALLOCATE prepare myprod;\n \n$ END\\\\\n$ delimiter ;\n\n$ set @nid1=12;\n$ set @nid2=15;\n$ set @callsql = 'select * from tb7 where nid>? and nid<?';\n$ CALL proc_sql(@nid1,@nid2,@callsql)\n```\n\npymsql中调用\n\n```bash\n$ #! /usr/bin/env python\n$ # -*- coding:utf-8 -*-\n\n$ import pymysql\n \n$ conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')\n$ cursor = conn.cursor()\n$ mysql=\"select * from tb7 where nid>? and nid<?\"\n$ cursor.callproc('proc_sql', args=(11, 15, mysql))\n \n$ rows = cursor.fetchall()\n$ print rows #((12, 'u1', 'u1pass', 11111), (13, 'u2', 'u2pass', 22222), (14, 'u3', 'u3pass', 11113))\n$ conn.commit()\n$ cursor.close()\n$ conn.close()\n```\n\n## 使用with简化连接过程\n\n每次都连接关闭很麻烦，使用上下文管理，简化连接过程\n\n```bash\n$ #! /usr/bin/env python\n$ # -*- coding:utf-8 -*-\n\n \nimport pymysql\nimport contextlib\n$ #定义上下文管理器，连接后自动关闭连接\n@contextlib.contextmanager\ndef mysql(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1',charset='utf8'):\n  conn = pymysql.connect(host=host, port=port, user=user, passwd=passwd, db=db, charset=charset)\n  cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)\n  try:\n    yield cursor\n  finally:\n    conn.commit()\n    cursor.close()\n    conn.close()\n \n$ # 执行sql\nwith mysql() as cursor:\n  print(cursor)\n  row_count = cursor.execute(\"select * from tb7\")\n  row_1 = cursor.fetchone()\n  print row_count, row_1\n```\n\n## 总结\n\n以上就是关于Python中pymysql模块的全部内容，希望对大家学习或使用python能有一定的帮助，如果有疑问大家可以留言交流。\n","slug":"PyMySQL","published":1,"updated":"2021-12-12T14:25:37.561Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3bsl2ig00075awqev4b8yvh","content":"<p>pymsql是Python中操作MySQL的模块，其使用方法和MySQLdb几乎相同。但目前pymysql支持python3.x而后者不支持3.x版本。</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文测试python版本：2.7.11。mysql版本：5.6.24</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ pip3 install pymysql<br></code></pre></td></tr></table></figure>\n<h2 id=\"使用操作\"><a href=\"#使用操作\" class=\"headerlink\" title=\"使用操作\"></a>使用操作</h2><h3 id=\"执行SQL\"><a href=\"#执行SQL\" class=\"headerlink\" title=\"执行SQL\"></a>执行SQL</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ <span class=\"hljs-comment\">#!/usr/bin/env pytho</span><br>$ <span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span><br>$ import pymysql<br>  <br>$ <span class=\"hljs-comment\"># 创建连接</span><br>$ conn = pymysql.connect(host=<span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>, port=3306, user=<span class=\"hljs-string\">&#x27;root&#x27;</span>, passwd=<span class=\"hljs-string\">&#x27;&#x27;</span>, db=<span class=\"hljs-string\">&#x27;tkq1&#x27;</span>, $ charset=<span class=\"hljs-string\">&#x27;utf8&#x27;</span>)<br>$ <span class=\"hljs-comment\"># 创建游标</span><br>cursor = conn.cursor()<br>  <br>$ <span class=\"hljs-comment\"># 执行SQL，并返回收影响行数</span><br>$ effect_row = cursor.execute(<span class=\"hljs-string\">&quot;select * from tb7&quot;</span>)<br>  <br>$ <span class=\"hljs-comment\"># 执行SQL，并返回受影响行数</span><br>$ <span class=\"hljs-comment\">#effect_row = cursor.execute(&quot;update tb7 set pass = &#x27;123&#x27; where nid = %s&quot;, (11,))</span><br>  <br>$ <span class=\"hljs-comment\"># 执行SQL，并返回受影响行数,执行多次</span><br>$ <span class=\"hljs-comment\">#effect_row = cursor.executemany(&quot;insert into tb7(user,pass,licnese)values(%s,%s,%s)&quot;, [(&quot;u1&quot;,&quot;u1pass&quot;,&quot;11111&quot;),(&quot;u2&quot;,&quot;u2pass&quot;,&quot;22222&quot;)])</span><br><br>  <br>$ <span class=\"hljs-comment\"># 提交，不然无法保存新建或者修改的数据</span><br>$ conn.commit()<br>  <br>$ <span class=\"hljs-comment\"># 关闭游标</span><br>$ cursor.close()<br>$ <span class=\"hljs-comment\"># 关闭连接</span><br>$ conn.close()<br>$ 注意：存在中文的时候，连接需要添加charset=<span class=\"hljs-string\">&#x27;utf8&#x27;</span>，否则中文显示乱码。<br><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"获取查询数据\"><a href=\"#获取查询数据\" class=\"headerlink\" title=\"获取查询数据\"></a>获取查询数据</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ <span class=\"hljs-comment\">#! /usr/bin/env python</span><br>$ <span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span><br>$<br>$ import pymysql<br> <br>$ conn = pymysql.connect(host=<span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>, port=3306, user=<span class=\"hljs-string\">&#x27;root&#x27;</span>, passwd=<span class=\"hljs-string\">&#x27;&#x27;</span>, db=<span class=\"hljs-string\">&#x27;tkq1&#x27;</span>)<br>$ cursor = conn.cursor()<br>$ cursor.execute(<span class=\"hljs-string\">&quot;select * from tb7&quot;</span>)<br> <br>$ <span class=\"hljs-comment\"># 获取剩余结果的第一行数据</span><br>$ row_1 = cursor.fetchone()<br>$ <span class=\"hljs-built_in\">print</span> row_1<br>$ <span class=\"hljs-comment\"># 获取剩余结果前n行数据</span><br>$ <span class=\"hljs-comment\"># row_2 = cursor.fetchmany(3)</span><br> <br>$ <span class=\"hljs-comment\"># 获取剩余结果所有数据</span><br>$ <span class=\"hljs-comment\"># row_3 = cursor.fetchall()</span><br> <br>$ conn.commit()<br>$ cursor.close()<br>$ conn.close()<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"获取新创建数据自增ID\"><a href=\"#获取新创建数据自增ID\" class=\"headerlink\" title=\"获取新创建数据自增ID\"></a>获取新创建数据自增ID</h3><p>可以获取到最新自增的ID，也就是最后插入的一条数据ID</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#! /usr/bin/env python</span><br><span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span><br><br>import pymysql<br> <br>conn = pymysql.connect(host=<span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>, port=3306, user=<span class=\"hljs-string\">&#x27;root&#x27;</span>, passwd=<span class=\"hljs-string\">&#x27;&#x27;</span>, db=<span class=\"hljs-string\">&#x27;tkq1&#x27;</span>)<br>cursor = conn.cursor()<br>effect_row = cursor.executemany(<span class=\"hljs-string\">&quot;insert into tb7(user,pass,licnese)values(%s,%s,%s)&quot;</span>, [(<span class=\"hljs-string\">&quot;u3&quot;</span>,<span class=\"hljs-string\">&quot;u3pass&quot;</span>,<span class=\"hljs-string\">&quot;11113&quot;</span>),(<span class=\"hljs-string\">&quot;u4&quot;</span>,<span class=\"hljs-string\">&quot;u4pass&quot;</span>,<span class=\"hljs-string\">&quot;22224&quot;</span>)])<br>conn.commit()<br>cursor.close()<br>conn.close()<br><span class=\"hljs-comment\">#获取自增id</span><br>new_id = cursor.lastrowid      <br><span class=\"hljs-built_in\">print</span> new_id<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"移动游标\"><a href=\"#移动游标\" class=\"headerlink\" title=\"移动游标\"></a>移动游标</h3><p>操作都是靠游标，那对游标的控制也是必须的</p>\n<p>注：在fetch数据时按照顺序进行，可以使用cursor.scroll(num,mode)来移动游标位置，如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ cursor.scroll(1,mode=<span class=\"hljs-string\">&#x27;relative&#x27;</span>) <span class=\"hljs-comment\"># 相对当前位置移动</span><br>$ cursor.scroll(2,mode=<span class=\"hljs-string\">&#x27;absolute&#x27;</span>) <span class=\"hljs-comment\"># 相对绝对位置移动</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"fetch数据类型\"><a href=\"#fetch数据类型\" class=\"headerlink\" title=\"fetch数据类型\"></a>fetch数据类型</h3><p>关于默认获取的数据是元祖类型，如果想要或者字典类型的数据，即：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ <span class=\"hljs-comment\">#! /usr/bin/env python</span><br>$ <span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span><br><br>$ import pymysql<br> <br>$ conn = pymysql.connect(host=<span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>, port=3306, user=<span class=\"hljs-string\">&#x27;root&#x27;</span>, passwd=<span class=\"hljs-string\">&#x27;&#x27;</span>, db=<span class=\"hljs-string\">&#x27;tkq1&#x27;</span>)<br>$ <span class=\"hljs-comment\">#游标设置为字典类型</span><br>$ cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)<br>$ cursor.execute(<span class=\"hljs-string\">&quot;select * from tb7&quot;</span>)<br> <br>$ row_1 = cursor.fetchone()<br>$ <span class=\"hljs-built_in\">print</span> row_1　　<span class=\"hljs-comment\">#&#123;u&#x27;licnese&#x27;: 213, u&#x27;user&#x27;: &#x27;123&#x27;, u&#x27;nid&#x27;: 10, u&#x27;pass&#x27;: &#x27;213&#x27;&#125;</span><br> <br>$ conn.commit()<br>$ cursor.close()<br>$ conn.close()<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"调用存储过程\"><a href=\"#调用存储过程\" class=\"headerlink\" title=\"调用存储过程\"></a>调用存储过程</h3><p>a、调用无参存储过程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ <span class=\"hljs-comment\">#! /usr/bin/env python</span><br>$ <span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span><br><br> <br>$ import pymysql<br> <br>$ conn = pymysql.connect(host=<span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>, port=3306, user=<span class=\"hljs-string\">&#x27;root&#x27;</span>, passwd=<span class=\"hljs-string\">&#x27;&#x27;</span>, db=<span class=\"hljs-string\">&#x27;tkq1&#x27;</span>)<br>$ <span class=\"hljs-comment\">#游标设置为字典类型</span><br>$ cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)<br>$ <span class=\"hljs-comment\">#无参数存储过程</span><br>$ cursor.callproc(<span class=\"hljs-string\">&#x27;p2&#x27;</span>)  <span class=\"hljs-comment\">#等价于cursor.execute(&quot;call p2()&quot;)</span><br> <br>$ row_1 = cursor.fetchone()<br>$ <span class=\"hljs-built_in\">print</span> row_1<br> <br> <br>$ conn.commit()<br>$ cursor.close()<br>$ conn.close()<br></code></pre></td></tr></table></figure>\n\n<p>b、调用有参存储过程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ <span class=\"hljs-comment\">#! /usr/bin/env python</span><br>$ <span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span><br> <br>$ import pymysql<br> <br>$ conn = pymysql.connect(host=<span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>, port=3306, user=<span class=\"hljs-string\">&#x27;root&#x27;</span>, passwd=<span class=\"hljs-string\">&#x27;&#x27;</span>, db=<span class=\"hljs-string\">&#x27;tkq1&#x27;</span>)<br>$ cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)<br> <br>$ cursor.callproc(<span class=\"hljs-string\">&#x27;p1&#x27;</span>, args=(1, 22, 3, 4))<br>$ <span class=\"hljs-comment\">#获取执行完存储的参数,参数@开头</span><br>$ cursor.execute(<span class=\"hljs-string\">&quot;select @p1,@_p1_1,@_p1_2,@_p1_3&quot;</span>)  <span class=\"hljs-comment\">#&#123;u&#x27;@_p1_1&#x27;: 22, u&#x27;@p1&#x27;: None, u&#x27;@_p1_2&#x27;: 103, u&#x27;@_p1_3&#x27;: 24&#125;</span><br>$ row_1 = cursor.fetchone()<br>$ <span class=\"hljs-built_in\">print</span> row_1<br> <br> <br>$ conn.commit()<br>$ cursor.close()<br>$ conn.close()<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"关于pymysql防注入\"><a href=\"#关于pymysql防注入\" class=\"headerlink\" title=\"关于pymysql防注入\"></a>关于pymysql防注入</h2><h3 id=\"字符串拼接查询，造成注入\"><a href=\"#字符串拼接查询，造成注入\" class=\"headerlink\" title=\"字符串拼接查询，造成注入\"></a>字符串拼接查询，造成注入</h3><p>正常查询语句：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ <span class=\"hljs-comment\">#! /usr/bin/env python</span><br>$ <span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span><br><br>$ import pymysql<br> <br>$ conn = pymysql.connect(host=<span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>, port=3306, user=<span class=\"hljs-string\">&#x27;root&#x27;</span>, passwd=<span class=\"hljs-string\">&#x27;&#x27;</span>, db=<span class=\"hljs-string\">&#x27;tkq1&#x27;</span>)<br>$ cursor = conn.cursor()<br>$ user=<span class=\"hljs-string\">&quot;u1&quot;</span><br>$ passwd=<span class=\"hljs-string\">&quot;u1pass&quot;</span><br>$ <span class=\"hljs-comment\">#正常构造语句的情况</span><br>$ sql=<span class=\"hljs-string\">&quot;select user,pass from tb7 where user=&#x27;%s&#x27; and pass=&#x27;%s&#x27;&quot;</span> % (user,passwd)<br>$ <span class=\"hljs-comment\">#sql=select user,pass from tb7 where user=&#x27;u1&#x27; and pass=&#x27;u1pass&#x27;</span><br>$ row_count=cursor.execute(sql) row_1 = cursor.fetchone()<br>$ <span class=\"hljs-built_in\">print</span> row_count,row_1<br> <br>$ conn.commit()<br>$ cursor.close()<br>$ conn.close()<br></code></pre></td></tr></table></figure>\n\n<p>构造注入语句：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ <span class=\"hljs-comment\">#! /usr/bin/env python</span><br>$ <span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span><br><br>$ import pymysql<br> <br>$ conn = pymysql.connect(host=<span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>, port=3306, user=<span class=\"hljs-string\">&#x27;root&#x27;</span>, passwd=<span class=\"hljs-string\">&#x27;&#x27;</span>, db=<span class=\"hljs-string\">&#x27;tkq1&#x27;</span>)<br>$ cursor = conn.cursor()<br> <br>$ user=<span class=\"hljs-string\">&quot;u1&#x27; or &#x27;1&#x27;-- &quot;</span><br>$ passwd=<span class=\"hljs-string\">&quot;u1pass&quot;</span><br>$ sql=<span class=\"hljs-string\">&quot;select user,pass from tb7 where user=&#x27;%s&#x27; and pass=&#x27;%s&#x27;&quot;</span> % (user,passwd)<br> <br>$ <span class=\"hljs-comment\">#拼接语句被构造成下面这样，永真条件，此时就注入成功了。因此要避免这种情况需使用pymysql提供的参数化查询。</span><br>$ <span class=\"hljs-comment\">#select user,pass from tb7 where user=&#x27;u1&#x27; or &#x27;1&#x27;-- &#x27; and pass=&#x27;u1pass&#x27;</span><br> <br>$ row_count=cursor.execute(sql)<br>$ row_1 = cursor.fetchone()<br>$ <span class=\"hljs-built_in\">print</span> row_count,row_1<br> <br> <br>$ conn.commit()<br>$ cursor.close()<br>$ conn.close()<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"避免注入，使用pymysql提供的参数化语句\"><a href=\"#避免注入，使用pymysql提供的参数化语句\" class=\"headerlink\" title=\"避免注入，使用pymysql提供的参数化语句\"></a>避免注入，使用pymysql提供的参数化语句</h3><p>正常参数化查询</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ <span class=\"hljs-comment\">#! /usr/bin/env python</span><br>$ <span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span><br><br> <br>$ import pymysql<br> <br>$ conn = pymysql.connect(host=<span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>, port=3306, user=<span class=\"hljs-string\">&#x27;root&#x27;</span>, passwd=<span class=\"hljs-string\">&#x27;&#x27;</span>, db=<span class=\"hljs-string\">&#x27;tkq1&#x27;</span>)<br>$ cursor = conn.cursor()<br>$ user=<span class=\"hljs-string\">&quot;u1&quot;</span><br>$ passwd=<span class=\"hljs-string\">&quot;u1pass&quot;</span><br>$ <span class=\"hljs-comment\">#执行参数化查询</span><br>$ row_count=cursor.execute(<span class=\"hljs-string\">&quot;select user,pass from tb7 where user=%s and pass=%s&quot;</span>,(user,passwd))<br>$ row_1 = cursor.fetchone()<br>$ <span class=\"hljs-built_in\">print</span> row_count,row_1<br> <br>$ conn.commit()<br>$ cursor.close()<br>$ conn.close()<br><br>构造注入，参数化查询注入失败。<br><br>```bash<br>$ <span class=\"hljs-comment\">#! /usr/bin/env python</span><br>$ <span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span><br><br>$ import pymysql<br> <br>$ conn = pymysql.connect(host=<span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>, port=3306, user=<span class=\"hljs-string\">&#x27;root&#x27;</span>, passwd=<span class=\"hljs-string\">&#x27;&#x27;</span>, db=<span class=\"hljs-string\">&#x27;tkq1&#x27;</span>)<br>$ cursor = conn.cursor()<br> <br>$ user=<span class=\"hljs-string\">&quot;u1&#x27; or &#x27;1&#x27;-- &quot;</span><br>$ passwd=<span class=\"hljs-string\">&quot;u1pass&quot;</span><br>$ <span class=\"hljs-comment\">#执行参数化查询</span><br>$ row_count=cursor.execute(<span class=\"hljs-string\">&quot;select user,pass from tb7 where user=%s and pass=%s&quot;</span>,(user,passwd))<br>$ <span class=\"hljs-comment\">#内部执行参数化生成的SQL语句，对特殊字符进行了加\\转义，避免注入语句生成。</span><br>$ <span class=\"hljs-comment\"># sql=cursor.mogrify(&quot;select user,pass from tb7 where user=%s and pass=%s&quot;,(user,passwd))</span><br>$ <span class=\"hljs-comment\"># print sql</span><br>$ <span class=\"hljs-comment\">#select user,pass from tb7 where user=&#x27;u1\\&#x27; or \\&#x27;1\\&#x27;-- &#x27; and pass=&#x27;u1pass&#x27;被转义的语句。</span><br> <br>$ row_1 = cursor.fetchone()<br>$ <span class=\"hljs-built_in\">print</span> row_count,row_1<br> <br>$ conn.commit()<br>$ cursor.close()<br>$ conn.close()<br></code></pre></td></tr></table></figure>\n\n<p>结论：excute执行SQL语句的时候，必须使用参数化的方式，否则必然产生SQL注入漏洞。</p>\n<h2 id=\"使用存mysql储过程动态执行SQL防注入\"><a href=\"#使用存mysql储过程动态执行SQL防注入\" class=\"headerlink\" title=\"使用存mysql储过程动态执行SQL防注入\"></a>使用存mysql储过程动态执行SQL防注入</h2><p>使用MYSQL存储过程自动提供防注入，动态传入SQL到存储过程执行语句。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ delimiter \\\\<br>$ DROP PROCEDURE IF EXISTS proc_sql \\\\<br>$ CREATE PROCEDURE proc_sql (<br>$   <span class=\"hljs-keyword\">in</span> nid1 INT,<br>$   <span class=\"hljs-keyword\">in</span> nid2 INT,<br>$   <span class=\"hljs-keyword\">in</span> callsql VARCHAR(255)<br>$   )<br>$ BEGIN<br>$   <span class=\"hljs-built_in\">set</span> @nid1 = nid1;<br>$   <span class=\"hljs-built_in\">set</span> @nid2 = nid2;<br>$   <span class=\"hljs-built_in\">set</span> @callsql = callsql;<br>$     PREPARE myprod FROM @callsql;<br>$ --   PREPARE prod FROM <span class=\"hljs-string\">&#x27;select * from tb2 where nid&gt;? and nid&lt;?&#x27;</span>;  传入的值为字符串，？为占位符<br>$ --   用@p1，和@p2填充占位符<br>$     EXECUTE myprod USING @nid1,@nid2;<br>$   DEALLOCATE prepare myprod;<br> <br>$ END\\\\<br>$ delimiter ;<br><br>$ <span class=\"hljs-built_in\">set</span> @nid1=12;<br>$ <span class=\"hljs-built_in\">set</span> @nid2=15;<br>$ <span class=\"hljs-built_in\">set</span> @callsql = <span class=\"hljs-string\">&#x27;select * from tb7 where nid&gt;? and nid&lt;?&#x27;</span>;<br>$ CALL proc_sql(@nid1,@nid2,@callsql)<br></code></pre></td></tr></table></figure>\n\n<p>pymsql中调用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ <span class=\"hljs-comment\">#! /usr/bin/env python</span><br>$ <span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span><br><br>$ import pymysql<br> <br>$ conn = pymysql.connect(host=<span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>, port=3306, user=<span class=\"hljs-string\">&#x27;root&#x27;</span>, passwd=<span class=\"hljs-string\">&#x27;&#x27;</span>, db=<span class=\"hljs-string\">&#x27;tkq1&#x27;</span>)<br>$ cursor = conn.cursor()<br>$ mysql=<span class=\"hljs-string\">&quot;select * from tb7 where nid&gt;? and nid&lt;?&quot;</span><br>$ cursor.callproc(<span class=\"hljs-string\">&#x27;proc_sql&#x27;</span>, args=(11, 15, mysql))<br> <br>$ rows = cursor.fetchall()<br>$ <span class=\"hljs-built_in\">print</span> rows <span class=\"hljs-comment\">#((12, &#x27;u1&#x27;, &#x27;u1pass&#x27;, 11111), (13, &#x27;u2&#x27;, &#x27;u2pass&#x27;, 22222), (14, &#x27;u3&#x27;, &#x27;u3pass&#x27;, 11113))</span><br>$ conn.commit()<br>$ cursor.close()<br>$ conn.close()<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用with简化连接过程\"><a href=\"#使用with简化连接过程\" class=\"headerlink\" title=\"使用with简化连接过程\"></a>使用with简化连接过程</h2><p>每次都连接关闭很麻烦，使用上下文管理，简化连接过程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ <span class=\"hljs-comment\">#! /usr/bin/env python</span><br>$ <span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span><br><br> <br>import pymysql<br>import contextlib<br>$ <span class=\"hljs-comment\">#定义上下文管理器，连接后自动关闭连接</span><br>@contextlib.contextmanager<br>def mysql(host=<span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>, port=3306, user=<span class=\"hljs-string\">&#x27;root&#x27;</span>, passwd=<span class=\"hljs-string\">&#x27;&#x27;</span>, db=<span class=\"hljs-string\">&#x27;tkq1&#x27;</span>,charset=<span class=\"hljs-string\">&#x27;utf8&#x27;</span>):<br>  conn = pymysql.connect(host=host, port=port, user=user, passwd=passwd, db=db, charset=charset)<br>  cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)<br>  try:<br>    yield cursor<br>  finally:<br>    conn.commit()<br>    cursor.close()<br>    conn.close()<br> <br>$ <span class=\"hljs-comment\"># 执行sql</span><br>with mysql() as cursor:<br>  <span class=\"hljs-built_in\">print</span>(cursor)<br>  row_count = cursor.execute(<span class=\"hljs-string\">&quot;select * from tb7&quot;</span>)<br>  row_1 = cursor.fetchone()<br>  <span class=\"hljs-built_in\">print</span> row_count, row_1<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>以上就是关于Python中pymysql模块的全部内容，希望对大家学习或使用python能有一定的帮助，如果有疑问大家可以留言交流。</p>\n","site":{"data":{}},"wordcount":8161,"excerpt":"","more":"<p>pymsql是Python中操作MySQL的模块，其使用方法和MySQLdb几乎相同。但目前pymysql支持python3.x而后者不支持3.x版本。</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文测试python版本：2.7.11。mysql版本：5.6.24</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ pip3 install pymysql<br></code></pre></td></tr></table></figure>\n<h2 id=\"使用操作\"><a href=\"#使用操作\" class=\"headerlink\" title=\"使用操作\"></a>使用操作</h2><h3 id=\"执行SQL\"><a href=\"#执行SQL\" class=\"headerlink\" title=\"执行SQL\"></a>执行SQL</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ <span class=\"hljs-comment\">#!/usr/bin/env pytho</span><br>$ <span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span><br>$ import pymysql<br>  <br>$ <span class=\"hljs-comment\"># 创建连接</span><br>$ conn = pymysql.connect(host=<span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>, port=3306, user=<span class=\"hljs-string\">&#x27;root&#x27;</span>, passwd=<span class=\"hljs-string\">&#x27;&#x27;</span>, db=<span class=\"hljs-string\">&#x27;tkq1&#x27;</span>, $ charset=<span class=\"hljs-string\">&#x27;utf8&#x27;</span>)<br>$ <span class=\"hljs-comment\"># 创建游标</span><br>cursor = conn.cursor()<br>  <br>$ <span class=\"hljs-comment\"># 执行SQL，并返回收影响行数</span><br>$ effect_row = cursor.execute(<span class=\"hljs-string\">&quot;select * from tb7&quot;</span>)<br>  <br>$ <span class=\"hljs-comment\"># 执行SQL，并返回受影响行数</span><br>$ <span class=\"hljs-comment\">#effect_row = cursor.execute(&quot;update tb7 set pass = &#x27;123&#x27; where nid = %s&quot;, (11,))</span><br>  <br>$ <span class=\"hljs-comment\"># 执行SQL，并返回受影响行数,执行多次</span><br>$ <span class=\"hljs-comment\">#effect_row = cursor.executemany(&quot;insert into tb7(user,pass,licnese)values(%s,%s,%s)&quot;, [(&quot;u1&quot;,&quot;u1pass&quot;,&quot;11111&quot;),(&quot;u2&quot;,&quot;u2pass&quot;,&quot;22222&quot;)])</span><br><br>  <br>$ <span class=\"hljs-comment\"># 提交，不然无法保存新建或者修改的数据</span><br>$ conn.commit()<br>  <br>$ <span class=\"hljs-comment\"># 关闭游标</span><br>$ cursor.close()<br>$ <span class=\"hljs-comment\"># 关闭连接</span><br>$ conn.close()<br>$ 注意：存在中文的时候，连接需要添加charset=<span class=\"hljs-string\">&#x27;utf8&#x27;</span>，否则中文显示乱码。<br><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"获取查询数据\"><a href=\"#获取查询数据\" class=\"headerlink\" title=\"获取查询数据\"></a>获取查询数据</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ <span class=\"hljs-comment\">#! /usr/bin/env python</span><br>$ <span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span><br>$<br>$ import pymysql<br> <br>$ conn = pymysql.connect(host=<span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>, port=3306, user=<span class=\"hljs-string\">&#x27;root&#x27;</span>, passwd=<span class=\"hljs-string\">&#x27;&#x27;</span>, db=<span class=\"hljs-string\">&#x27;tkq1&#x27;</span>)<br>$ cursor = conn.cursor()<br>$ cursor.execute(<span class=\"hljs-string\">&quot;select * from tb7&quot;</span>)<br> <br>$ <span class=\"hljs-comment\"># 获取剩余结果的第一行数据</span><br>$ row_1 = cursor.fetchone()<br>$ <span class=\"hljs-built_in\">print</span> row_1<br>$ <span class=\"hljs-comment\"># 获取剩余结果前n行数据</span><br>$ <span class=\"hljs-comment\"># row_2 = cursor.fetchmany(3)</span><br> <br>$ <span class=\"hljs-comment\"># 获取剩余结果所有数据</span><br>$ <span class=\"hljs-comment\"># row_3 = cursor.fetchall()</span><br> <br>$ conn.commit()<br>$ cursor.close()<br>$ conn.close()<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"获取新创建数据自增ID\"><a href=\"#获取新创建数据自增ID\" class=\"headerlink\" title=\"获取新创建数据自增ID\"></a>获取新创建数据自增ID</h3><p>可以获取到最新自增的ID，也就是最后插入的一条数据ID</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#! /usr/bin/env python</span><br><span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span><br><br>import pymysql<br> <br>conn = pymysql.connect(host=<span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>, port=3306, user=<span class=\"hljs-string\">&#x27;root&#x27;</span>, passwd=<span class=\"hljs-string\">&#x27;&#x27;</span>, db=<span class=\"hljs-string\">&#x27;tkq1&#x27;</span>)<br>cursor = conn.cursor()<br>effect_row = cursor.executemany(<span class=\"hljs-string\">&quot;insert into tb7(user,pass,licnese)values(%s,%s,%s)&quot;</span>, [(<span class=\"hljs-string\">&quot;u3&quot;</span>,<span class=\"hljs-string\">&quot;u3pass&quot;</span>,<span class=\"hljs-string\">&quot;11113&quot;</span>),(<span class=\"hljs-string\">&quot;u4&quot;</span>,<span class=\"hljs-string\">&quot;u4pass&quot;</span>,<span class=\"hljs-string\">&quot;22224&quot;</span>)])<br>conn.commit()<br>cursor.close()<br>conn.close()<br><span class=\"hljs-comment\">#获取自增id</span><br>new_id = cursor.lastrowid      <br><span class=\"hljs-built_in\">print</span> new_id<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"移动游标\"><a href=\"#移动游标\" class=\"headerlink\" title=\"移动游标\"></a>移动游标</h3><p>操作都是靠游标，那对游标的控制也是必须的</p>\n<p>注：在fetch数据时按照顺序进行，可以使用cursor.scroll(num,mode)来移动游标位置，如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ cursor.scroll(1,mode=<span class=\"hljs-string\">&#x27;relative&#x27;</span>) <span class=\"hljs-comment\"># 相对当前位置移动</span><br>$ cursor.scroll(2,mode=<span class=\"hljs-string\">&#x27;absolute&#x27;</span>) <span class=\"hljs-comment\"># 相对绝对位置移动</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"fetch数据类型\"><a href=\"#fetch数据类型\" class=\"headerlink\" title=\"fetch数据类型\"></a>fetch数据类型</h3><p>关于默认获取的数据是元祖类型，如果想要或者字典类型的数据，即：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ <span class=\"hljs-comment\">#! /usr/bin/env python</span><br>$ <span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span><br><br>$ import pymysql<br> <br>$ conn = pymysql.connect(host=<span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>, port=3306, user=<span class=\"hljs-string\">&#x27;root&#x27;</span>, passwd=<span class=\"hljs-string\">&#x27;&#x27;</span>, db=<span class=\"hljs-string\">&#x27;tkq1&#x27;</span>)<br>$ <span class=\"hljs-comment\">#游标设置为字典类型</span><br>$ cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)<br>$ cursor.execute(<span class=\"hljs-string\">&quot;select * from tb7&quot;</span>)<br> <br>$ row_1 = cursor.fetchone()<br>$ <span class=\"hljs-built_in\">print</span> row_1　　<span class=\"hljs-comment\">#&#123;u&#x27;licnese&#x27;: 213, u&#x27;user&#x27;: &#x27;123&#x27;, u&#x27;nid&#x27;: 10, u&#x27;pass&#x27;: &#x27;213&#x27;&#125;</span><br> <br>$ conn.commit()<br>$ cursor.close()<br>$ conn.close()<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"调用存储过程\"><a href=\"#调用存储过程\" class=\"headerlink\" title=\"调用存储过程\"></a>调用存储过程</h3><p>a、调用无参存储过程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ <span class=\"hljs-comment\">#! /usr/bin/env python</span><br>$ <span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span><br><br> <br>$ import pymysql<br> <br>$ conn = pymysql.connect(host=<span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>, port=3306, user=<span class=\"hljs-string\">&#x27;root&#x27;</span>, passwd=<span class=\"hljs-string\">&#x27;&#x27;</span>, db=<span class=\"hljs-string\">&#x27;tkq1&#x27;</span>)<br>$ <span class=\"hljs-comment\">#游标设置为字典类型</span><br>$ cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)<br>$ <span class=\"hljs-comment\">#无参数存储过程</span><br>$ cursor.callproc(<span class=\"hljs-string\">&#x27;p2&#x27;</span>)  <span class=\"hljs-comment\">#等价于cursor.execute(&quot;call p2()&quot;)</span><br> <br>$ row_1 = cursor.fetchone()<br>$ <span class=\"hljs-built_in\">print</span> row_1<br> <br> <br>$ conn.commit()<br>$ cursor.close()<br>$ conn.close()<br></code></pre></td></tr></table></figure>\n\n<p>b、调用有参存储过程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ <span class=\"hljs-comment\">#! /usr/bin/env python</span><br>$ <span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span><br> <br>$ import pymysql<br> <br>$ conn = pymysql.connect(host=<span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>, port=3306, user=<span class=\"hljs-string\">&#x27;root&#x27;</span>, passwd=<span class=\"hljs-string\">&#x27;&#x27;</span>, db=<span class=\"hljs-string\">&#x27;tkq1&#x27;</span>)<br>$ cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)<br> <br>$ cursor.callproc(<span class=\"hljs-string\">&#x27;p1&#x27;</span>, args=(1, 22, 3, 4))<br>$ <span class=\"hljs-comment\">#获取执行完存储的参数,参数@开头</span><br>$ cursor.execute(<span class=\"hljs-string\">&quot;select @p1,@_p1_1,@_p1_2,@_p1_3&quot;</span>)  <span class=\"hljs-comment\">#&#123;u&#x27;@_p1_1&#x27;: 22, u&#x27;@p1&#x27;: None, u&#x27;@_p1_2&#x27;: 103, u&#x27;@_p1_3&#x27;: 24&#125;</span><br>$ row_1 = cursor.fetchone()<br>$ <span class=\"hljs-built_in\">print</span> row_1<br> <br> <br>$ conn.commit()<br>$ cursor.close()<br>$ conn.close()<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"关于pymysql防注入\"><a href=\"#关于pymysql防注入\" class=\"headerlink\" title=\"关于pymysql防注入\"></a>关于pymysql防注入</h2><h3 id=\"字符串拼接查询，造成注入\"><a href=\"#字符串拼接查询，造成注入\" class=\"headerlink\" title=\"字符串拼接查询，造成注入\"></a>字符串拼接查询，造成注入</h3><p>正常查询语句：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ <span class=\"hljs-comment\">#! /usr/bin/env python</span><br>$ <span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span><br><br>$ import pymysql<br> <br>$ conn = pymysql.connect(host=<span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>, port=3306, user=<span class=\"hljs-string\">&#x27;root&#x27;</span>, passwd=<span class=\"hljs-string\">&#x27;&#x27;</span>, db=<span class=\"hljs-string\">&#x27;tkq1&#x27;</span>)<br>$ cursor = conn.cursor()<br>$ user=<span class=\"hljs-string\">&quot;u1&quot;</span><br>$ passwd=<span class=\"hljs-string\">&quot;u1pass&quot;</span><br>$ <span class=\"hljs-comment\">#正常构造语句的情况</span><br>$ sql=<span class=\"hljs-string\">&quot;select user,pass from tb7 where user=&#x27;%s&#x27; and pass=&#x27;%s&#x27;&quot;</span> % (user,passwd)<br>$ <span class=\"hljs-comment\">#sql=select user,pass from tb7 where user=&#x27;u1&#x27; and pass=&#x27;u1pass&#x27;</span><br>$ row_count=cursor.execute(sql) row_1 = cursor.fetchone()<br>$ <span class=\"hljs-built_in\">print</span> row_count,row_1<br> <br>$ conn.commit()<br>$ cursor.close()<br>$ conn.close()<br></code></pre></td></tr></table></figure>\n\n<p>构造注入语句：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ <span class=\"hljs-comment\">#! /usr/bin/env python</span><br>$ <span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span><br><br>$ import pymysql<br> <br>$ conn = pymysql.connect(host=<span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>, port=3306, user=<span class=\"hljs-string\">&#x27;root&#x27;</span>, passwd=<span class=\"hljs-string\">&#x27;&#x27;</span>, db=<span class=\"hljs-string\">&#x27;tkq1&#x27;</span>)<br>$ cursor = conn.cursor()<br> <br>$ user=<span class=\"hljs-string\">&quot;u1&#x27; or &#x27;1&#x27;-- &quot;</span><br>$ passwd=<span class=\"hljs-string\">&quot;u1pass&quot;</span><br>$ sql=<span class=\"hljs-string\">&quot;select user,pass from tb7 where user=&#x27;%s&#x27; and pass=&#x27;%s&#x27;&quot;</span> % (user,passwd)<br> <br>$ <span class=\"hljs-comment\">#拼接语句被构造成下面这样，永真条件，此时就注入成功了。因此要避免这种情况需使用pymysql提供的参数化查询。</span><br>$ <span class=\"hljs-comment\">#select user,pass from tb7 where user=&#x27;u1&#x27; or &#x27;1&#x27;-- &#x27; and pass=&#x27;u1pass&#x27;</span><br> <br>$ row_count=cursor.execute(sql)<br>$ row_1 = cursor.fetchone()<br>$ <span class=\"hljs-built_in\">print</span> row_count,row_1<br> <br> <br>$ conn.commit()<br>$ cursor.close()<br>$ conn.close()<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"避免注入，使用pymysql提供的参数化语句\"><a href=\"#避免注入，使用pymysql提供的参数化语句\" class=\"headerlink\" title=\"避免注入，使用pymysql提供的参数化语句\"></a>避免注入，使用pymysql提供的参数化语句</h3><p>正常参数化查询</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ <span class=\"hljs-comment\">#! /usr/bin/env python</span><br>$ <span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span><br><br> <br>$ import pymysql<br> <br>$ conn = pymysql.connect(host=<span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>, port=3306, user=<span class=\"hljs-string\">&#x27;root&#x27;</span>, passwd=<span class=\"hljs-string\">&#x27;&#x27;</span>, db=<span class=\"hljs-string\">&#x27;tkq1&#x27;</span>)<br>$ cursor = conn.cursor()<br>$ user=<span class=\"hljs-string\">&quot;u1&quot;</span><br>$ passwd=<span class=\"hljs-string\">&quot;u1pass&quot;</span><br>$ <span class=\"hljs-comment\">#执行参数化查询</span><br>$ row_count=cursor.execute(<span class=\"hljs-string\">&quot;select user,pass from tb7 where user=%s and pass=%s&quot;</span>,(user,passwd))<br>$ row_1 = cursor.fetchone()<br>$ <span class=\"hljs-built_in\">print</span> row_count,row_1<br> <br>$ conn.commit()<br>$ cursor.close()<br>$ conn.close()<br><br>构造注入，参数化查询注入失败。<br><br>```bash<br>$ <span class=\"hljs-comment\">#! /usr/bin/env python</span><br>$ <span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span><br><br>$ import pymysql<br> <br>$ conn = pymysql.connect(host=<span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>, port=3306, user=<span class=\"hljs-string\">&#x27;root&#x27;</span>, passwd=<span class=\"hljs-string\">&#x27;&#x27;</span>, db=<span class=\"hljs-string\">&#x27;tkq1&#x27;</span>)<br>$ cursor = conn.cursor()<br> <br>$ user=<span class=\"hljs-string\">&quot;u1&#x27; or &#x27;1&#x27;-- &quot;</span><br>$ passwd=<span class=\"hljs-string\">&quot;u1pass&quot;</span><br>$ <span class=\"hljs-comment\">#执行参数化查询</span><br>$ row_count=cursor.execute(<span class=\"hljs-string\">&quot;select user,pass from tb7 where user=%s and pass=%s&quot;</span>,(user,passwd))<br>$ <span class=\"hljs-comment\">#内部执行参数化生成的SQL语句，对特殊字符进行了加\\转义，避免注入语句生成。</span><br>$ <span class=\"hljs-comment\"># sql=cursor.mogrify(&quot;select user,pass from tb7 where user=%s and pass=%s&quot;,(user,passwd))</span><br>$ <span class=\"hljs-comment\"># print sql</span><br>$ <span class=\"hljs-comment\">#select user,pass from tb7 where user=&#x27;u1\\&#x27; or \\&#x27;1\\&#x27;-- &#x27; and pass=&#x27;u1pass&#x27;被转义的语句。</span><br> <br>$ row_1 = cursor.fetchone()<br>$ <span class=\"hljs-built_in\">print</span> row_count,row_1<br> <br>$ conn.commit()<br>$ cursor.close()<br>$ conn.close()<br></code></pre></td></tr></table></figure>\n\n<p>结论：excute执行SQL语句的时候，必须使用参数化的方式，否则必然产生SQL注入漏洞。</p>\n<h2 id=\"使用存mysql储过程动态执行SQL防注入\"><a href=\"#使用存mysql储过程动态执行SQL防注入\" class=\"headerlink\" title=\"使用存mysql储过程动态执行SQL防注入\"></a>使用存mysql储过程动态执行SQL防注入</h2><p>使用MYSQL存储过程自动提供防注入，动态传入SQL到存储过程执行语句。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ delimiter \\\\<br>$ DROP PROCEDURE IF EXISTS proc_sql \\\\<br>$ CREATE PROCEDURE proc_sql (<br>$   <span class=\"hljs-keyword\">in</span> nid1 INT,<br>$   <span class=\"hljs-keyword\">in</span> nid2 INT,<br>$   <span class=\"hljs-keyword\">in</span> callsql VARCHAR(255)<br>$   )<br>$ BEGIN<br>$   <span class=\"hljs-built_in\">set</span> @nid1 = nid1;<br>$   <span class=\"hljs-built_in\">set</span> @nid2 = nid2;<br>$   <span class=\"hljs-built_in\">set</span> @callsql = callsql;<br>$     PREPARE myprod FROM @callsql;<br>$ --   PREPARE prod FROM <span class=\"hljs-string\">&#x27;select * from tb2 where nid&gt;? and nid&lt;?&#x27;</span>;  传入的值为字符串，？为占位符<br>$ --   用@p1，和@p2填充占位符<br>$     EXECUTE myprod USING @nid1,@nid2;<br>$   DEALLOCATE prepare myprod;<br> <br>$ END\\\\<br>$ delimiter ;<br><br>$ <span class=\"hljs-built_in\">set</span> @nid1=12;<br>$ <span class=\"hljs-built_in\">set</span> @nid2=15;<br>$ <span class=\"hljs-built_in\">set</span> @callsql = <span class=\"hljs-string\">&#x27;select * from tb7 where nid&gt;? and nid&lt;?&#x27;</span>;<br>$ CALL proc_sql(@nid1,@nid2,@callsql)<br></code></pre></td></tr></table></figure>\n\n<p>pymsql中调用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ <span class=\"hljs-comment\">#! /usr/bin/env python</span><br>$ <span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span><br><br>$ import pymysql<br> <br>$ conn = pymysql.connect(host=<span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>, port=3306, user=<span class=\"hljs-string\">&#x27;root&#x27;</span>, passwd=<span class=\"hljs-string\">&#x27;&#x27;</span>, db=<span class=\"hljs-string\">&#x27;tkq1&#x27;</span>)<br>$ cursor = conn.cursor()<br>$ mysql=<span class=\"hljs-string\">&quot;select * from tb7 where nid&gt;? and nid&lt;?&quot;</span><br>$ cursor.callproc(<span class=\"hljs-string\">&#x27;proc_sql&#x27;</span>, args=(11, 15, mysql))<br> <br>$ rows = cursor.fetchall()<br>$ <span class=\"hljs-built_in\">print</span> rows <span class=\"hljs-comment\">#((12, &#x27;u1&#x27;, &#x27;u1pass&#x27;, 11111), (13, &#x27;u2&#x27;, &#x27;u2pass&#x27;, 22222), (14, &#x27;u3&#x27;, &#x27;u3pass&#x27;, 11113))</span><br>$ conn.commit()<br>$ cursor.close()<br>$ conn.close()<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用with简化连接过程\"><a href=\"#使用with简化连接过程\" class=\"headerlink\" title=\"使用with简化连接过程\"></a>使用with简化连接过程</h2><p>每次都连接关闭很麻烦，使用上下文管理，简化连接过程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ <span class=\"hljs-comment\">#! /usr/bin/env python</span><br>$ <span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span><br><br> <br>import pymysql<br>import contextlib<br>$ <span class=\"hljs-comment\">#定义上下文管理器，连接后自动关闭连接</span><br>@contextlib.contextmanager<br>def mysql(host=<span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>, port=3306, user=<span class=\"hljs-string\">&#x27;root&#x27;</span>, passwd=<span class=\"hljs-string\">&#x27;&#x27;</span>, db=<span class=\"hljs-string\">&#x27;tkq1&#x27;</span>,charset=<span class=\"hljs-string\">&#x27;utf8&#x27;</span>):<br>  conn = pymysql.connect(host=host, port=port, user=user, passwd=passwd, db=db, charset=charset)<br>  cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)<br>  try:<br>    yield cursor<br>  finally:<br>    conn.commit()<br>    cursor.close()<br>    conn.close()<br> <br>$ <span class=\"hljs-comment\"># 执行sql</span><br>with mysql() as cursor:<br>  <span class=\"hljs-built_in\">print</span>(cursor)<br>  row_count = cursor.execute(<span class=\"hljs-string\">&quot;select * from tb7&quot;</span>)<br>  row_1 = cursor.fetchone()<br>  <span class=\"hljs-built_in\">print</span> row_count, row_1<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>以上就是关于Python中pymysql模块的全部内容，希望对大家学习或使用python能有一定的帮助，如果有疑问大家可以留言交流。</p>\n"},{"title":"Python解释执行原理及过程","date":"2016-10-25T15:55:47.000Z","thumbnail":"http://i1.piimg.com/567571/de3fdf0bf57dff25.png","_content":"\n\n## 简单的例子\n先从一个简单的例子说起，包含了两个文件 foo.py 和 demo.py\n``` bash\n[foo.py]\ndef add(a, b):\n    return a + b\n[demo.py]\nimport foo\na = [1, 'python']\na = 'a string'\ndef func():\n\ta = 1\n\tb = 257\n\tprint(a + b)\nprint(a)\nif __name__ == '__main__':\n\tfunc()\n\tfoo.add(1, 2)\n```\n执行这个程序\n\npython demo.py\n输出结果\n\na string\n258\n同时，该文件目录多出一个 foo.pyc 文件\n\n## 背后的魔法\n看完程序的执行结果，接下来开始一行行解释代码。\n\n### 模块\nPython 将 .py 文件视为一个 module，这些 module 中，有一个主 module，也就是程序运行的入口。在这个例子中，主 module 是 demo.py。\n\n### 编译\n执行 python demo.py 后，将会启动 Python 的解释器，然后将 demo.py 编译成一个字节码对象 PyCodeObject。\n\n有的人可能会很好奇，编译的结果不应是 pyc 文件吗，就像 Java 的 class 文件，那为什么是一个对象呢，这里稍微解释一下。\n\n在 Python 的世界中，一切都是对象，函数也是对象，类型也是对象，类也是对象（类属于自定义的类型，在 Python ### 之前，int, dict 这些内置类型与类是存在不同的，在之后才统一起来，全部继承自 object），甚至连编译出来的字节码也是对象，.pyc 文件是字节码对象（PyCodeObject）在硬盘上的表现形式。\n\n在运行期间，编译结果也就是 PyCodeObject 对象，只会存在于内存中，而当这个模块的 Python 代码 执行完 后，就会将编译结果保存到了 pyc 文件中，这样下次就不用编译，直接加载到内存中。pyc 文件只是 PyCodeObject 对象在硬盘上的表现形式。\n\n这个 PyCodeObject 对象包含了 Python 源代码中的字符串，常量值，以及通过语法解析后编译生成的字节码指令。PyCodeObject 对象还会存储这些字节码指令与原始代码行号的对应关系，这样当出现异常时，就能指明位于哪一行的代码。\n\n### pyc 文件\n一个 pyc 文件包含了三部分信息：Python 的 magic number、pyc 文件创建的时间信息，以及 PyCodeObject 对象。\n\nmagic number 是 Python 定义的一个整数值。一般来说，不同版本的 Python 实现都会定义不同的 magic number，这个值是用来保证 Python 兼容性的。比如要限制由低版本编译的 pyc 文件不能让高版本的 Python 程序来执行，只需要检查 magic number 不同就可以了。由于不同版本的 Python 定义的字节码指令可能会不同，如果不做检查，执行的时候就可能出错。\n\n下面所示的代码可以来创建 pyc 文件，使用方法\n\n python generate_pyc.py module_name\n例如\n\n python generate_pyc.py demo\n[generate_pyc.pyc]\nimport imp\nimport sys\ndef generate_pyc(name):\n\tfp, pathname, description = imp.find_module(name)\n\ttry:\n\t\timp.load_module(name, fp, pathname, description)\t\n\tfinally:\n\t\tif fp:\n\t\t\tfp.close()\nif __name__ == '__main__':\n\tgenerate_pyc(sys.argv[1])\n### 字节码指令\n为什么 pyc 文件也称作字节码文件？因为这些文件存储的都是一些二进制的字节数据，而不是能让人直观查看的文本数据。\n\nPython 标准库提供了用来生成代码对应字节码的工具 dis 。dis 提供一个名为 dis 的方法，这个方法接收一个 code 对象，然后会输出 code 对象里的字节码指令信息。\n\ns = open('demo.py').read()\nco = compile(s, 'demo.py', 'exec')\nimport dis\ndis.dis(co)\n执行上面这段代码可以输出 demo.py 编译后的字节码指令\n\n  1           0 LOAD_CONST\t   0 (-1)\n\t 3 LOAD_CONST\t   1 (None)\n\t 6 IMPORT_NAME\t  0 (foo)\n\t 9 STORE_NAME\t   0 (foo)\n 3          12 LOAD_CONST\t   2 (1)\n\t15 LOAD_CONST\t   3 (u'python')\n\t18 BUILD_LIST\t   2\n\t21 STORE_NAME\t   1 (a)\n 4          24 LOAD_CONST\t   4 (u'a string')\n\t27 STORE_NAME\t   1 (a)\n 6          30 LOAD_CONST\t   5 (<code object func at 00D97650, file \"demo.py\", line 6>)\n\t33 MAKE_FUNCTION\t0\n\t36 STORE_NAME\t   2 (func)\n11          39 LOAD_NAME\t    1 (a)\n\t42 PRINT_ITEM          \n\t43 PRINT_NEWLINE       \n13          44 LOAD_NAME\t    3 (__name__)\n\t47 LOAD_CONST\t   6 (u'__main__')\n\t50 COMPARE_OP\t   2 (==)\n\t53 POP_JUMP_IF_FALSE       82\n14          56 LOAD_NAME\t    2 (func)\n\t59 CALL_FUNCTION\t0\n\t62 POP_TOP\t \n15          63 LOAD_NAME\t    0 (foo)\n\t66 LOAD_ATTR\t    4 (add)\n\t69 LOAD_CONST\t   2 (1)\n\t72 LOAD_CONST\t   7 (2)\n\t75 CALL_FUNCTION\t2\n\t78 POP_TOP\t \n\t79 JUMP_FORWARD\t 0 (to 82)\n       >>   82 LOAD_CONST\t   1 (None)\n\t85 RETURN_VALUE        \n### Python 虚拟机\ndemo.py 被编译后，接下来的工作就交由 Python 虚拟机来执行字节码指令了。Python 虚拟机会从编译得到的 PyCodeObject 对象中依次读入每一条字节码指令，并在当前的 上下文环境 中执行这条字节码指令。我们的程序就是通过这样循环往复的过程才得以执行。\n\n### import 指令\ndemo.py 的第一行代码是 import foo 。import 指令用来载入一个模块，另外一个载入模块的方法是 from xx import yy 。用 from 语句的好处是，可以只复制需要的符号变量到当前的命名空间中（关于命名空间将在后面介绍）。\n\n前文提到，当已经存在 pyc 文件时，就可以直接载入而省去编译过程。但是代码文件的内容会更新，如何保证更新后能重新编译而不入旧的 pyc 文件呢。答案就在 pyc 文件中存储的 创建时间信息 。当执行 import 指令的时候，如果已存在 pyc 文件，Python 会检查创建时间是否晚于代码文件的修改时间，这样就能判断是否需要重新编译，还是直接载入了。如果不存在 pyc 文件，就会先将 py 文件编译。\n\n### 绝对引入和相对引入\n前文已经介绍了 import foo 这行代码。这里隐含了一个问题，就是 foo 是什么，如何找到 foo 。这就属于 Python 的模块引入规则，这里不展开介绍，可以参考 pep-0328 。\n\n### 赋值语句\n接下来，执行到 a = [1, 'python'] ，这是一条赋值语句，定义了一个变量 a，它对应的值是 [1, 'python']。这里要解释一下， 变量 是什么呢？\n\n按照 维基百科 的解释\n\n变量是一个存储位置和一个关联的符号名字，这个存储位置包含了一些已知或未知的量或者信息。\n\n变量实际上是一个字符串的符号，用来关联一个存储在内存中的对象。在 Python 中，会使用 dict（就是 Python 的 dict 对象）来存储变量符号（字符串）与一个对象的映射。\n\n那么赋值语句实际上就是用来建立这种关联，在这个例子中是将符号 a 与一个列表对象 [1, 'python'] 建立映射。\n\n紧接着的代码执行了 a = 'a string' ，这条指令则将符号 a 与另外一个字符串对象 a string 建立了映射。今后对变量 a 的操作，将反应到字符串对象 a string 上。\n\n### def 指令\n我们的 Python 代码继续往下运行，这里执行到一条 def func() ，从字节码指令中也可以看出端倪 MAKE_FUNCTION 。没错这条指令是用来创建函数的。Python 是动态语言，def 实际上是执行一条指令，用来创建函数（class 则是创建类的指令），而不仅仅是个语法关键字。函数并不是事先创建好的，而是执行到的时候才创建的。\n\ndef func() 将会创建一个名称为 func 的函数对象。实际上是先创建一个函数对象，然后将 func 这个名称符号绑定到这个函数上。\n\nPython 中是无法实现 C 和 Java 中的重载的，因为重载要求函数名要相同，而参数的类型或数量不同，但是 Python 是通过变量符号（如这里的 func ）来关联一个函数，当我们用 def 语句再次创建一个同名的函数时，这个变量名就绑定到新的函数对象上了。\n\n### 动态类型\n继续看函数 func 里面的代码，这时又有一条赋值语句 a = 1 。变量 a 现在已经变成了第三种类型，它现在是一个整数了。那么 Python 是怎么实现动态类型的呢？答案就藏在具体存储的对象上。变量 a 仅仅只是一个符号（实际上是一个字符串对象），类型信息是存储在对象上的。在 Python 中，对象机制的核心是类型信息和引用计数（引用计数属于垃圾回收的部分）。\n\n用 type(a)，可以输出 a 的类型，这里是 int\n\nb = 257 跳过，我们直接来看看 print(a + b) ，print 是输出函数，这里略过。这里想要探究的是 a + b 。\n\n因为 a 和 b 并不存储类型信息，因此当执行 a + b 的时候就必须先检查类型，比如 1 + 2 和 \"1\" + \"2\" 的结果是不一样的。\n\n看到这里，我们就可以想象一下执行一句简单的 a + b ，Python 虚拟机需要做多少繁琐的事情了。首先需要分别检查 a 和 b 所对应对象的类型，还要匹配类型是否一致（1 + \"2\" 将会出现异常），然后根据对象的类型调用正确的 + 函数（例如数值的 + 或字符串的 +），\n\n而 CPU 对于上面这条语句只需要执行 ADD 指令\n（还需要先将变量 MOV 到寄存器）。\n\n### 命名空间 (namespace)\n在介绍上面的这些代码时，还漏掉了一个关键的信息就是命名空间。在 Python 中，类、函数、module 都对应着一个独立的命名空间。而一个独立的命名空间会对应一个 PyCodeObject 对象，所以上面的 demo.py 文件编译后会生成两个 PyCodeObject，只是在 demo.py 这个 module 层的 PyCodeObject 中通过一个变量符号 func 嵌套了一个函数的 PyCodeObject。\n\n命名空间的意义，就是用来确定一个变量符号到底对应什么对象。命名空间可以一个套一个地形成一条命名空间链，Python 虚拟机在执行的过程中，会有很大一部分时间消耗在从这条命名空间链中确定一个符号所对应的对象是什么。\n\n在 Python中，命名空间是由一个 dict 对象实现的，它维护了（name，obj）这样的关联关系。\n\n说到这里，再补充一下 import foo 这行代码会在 demo.py 这个模块的命名空间中，创建一个新的变量名 foo ， foo 将绑定到一个 PyCodeObject 对象，也就是 foo.py 的编译结果。\n\n#### dir 函数\n\nPython 的 内置函数 dir 可以用来查看一个命名空间下的所有名字符号。一个用处是查看一个命名空间的所有属性和方法（这里的命名空间就是指类、函数、module）。\n\n比如，查看当前的命名空间，可以使用 dir()，查看 sys 模块，可以使用 dir(sys)。\n\n#### LEGB 规则\n\nPython 使用 LEGB 的顺序来查找一个符号对应的对象\n\nlocals -> enclosing function -> globals -> builtins\n\nlocals，当前所在命名空间（如函数、模块），函数的参数也属于命名空间内的变量\n\nenclosing，外部嵌套函数的命名空间（闭包中常见）\n\ndef fun1(a):\n    def fun2():\n        # a 位于外部嵌套函数的命名空间\n        print(a)\nglobals，全局变量，函数定义所在模块的命名空间\n\na = 1\ndef fun():\n    # 需要通过 global 指令来声明全局变量\n    global a\n    # 修改全局变量，而不是创建一个新的 local 变量\n    a = 2\nbuiltins，内置模块的命名空间。Python 在启动的时候会自动为我们载入很多内置的函数、类，比如 dict，list，type，print，这些都位于 __builtins__ 模块中，可以使用 dir(__builtins__) 来查看。这也是为什么我们在没有 import 任何模块的情况下，就能使用这么多丰富的函数和功能了。\n\n介绍完命名空间，就能理解 print(a) 这行代码输出的结果为什么是 a string 了。\n\n### 内置属性 __name__\n现在到了解释 if __name__ == '__main__' 这行代码的时候了。当 Python 程序启动后，Python 会自动为每个模块设置一个属性 __name__ 通常使用的是模块的名字，也就是文件名，但唯一的例外是主模块，主模块将会被设置为 __main__ 。利用这一特性，就可以做一些特别的事。比如当该模块以主模块来运行的时候，可以运行测试用例。而当被其他模块 import 时，则只是乖乖的，提供函数和功能就好。\n\n### 函数调用\n最后两行是函数调用，这里略去不讲。\n\n## 回顾\n讲到最后，还有些内容需要再回顾和补充一下。\n\n### pyc 文件\nPython 只会对那些以后可能继续被使用和载入的模块才会生成 pyc 文件，Python 认为使用了 import 指令的模块，属于这种类型，因此会生成 pyc 文件。而对于只是临时用一次的模块，并不会生成 pyc 文件，Python 将主模块当成了这种类型的文件。这就解释了为什么 python demo.py 执行完后，只会生成一个 foo.pyc 文件。\n\n如果要问 pyc 文件什么时候生成，答案就是在执行了 import 指令之后，from xx import yy 同样属于 import 指令。\n\n### 小整数对象池\n在 demo.py 这里例子中，所用的整数特意用了一个 257，这是为了介绍小整数对象池的。整数在程序中的使用非常广泛，Python 为了优化速度，使用了小整数对象池，避免为整数频繁申请和销毁内存空间。\n\nPython 对小整数的定义是 [-5, 257)，这些整数对象是提前建立好的，不会被垃圾回收。在一个 Python 的程序中，所有位于这个范围内的整数使用的都是同一个对象，从下面这个例子就可以看出。\n\n>>> a = 1\n>>> id(a)\n40059744\n>>> b = 1\n>>> id(b)\n40059744\n>>> c = 257\n>>> id(c)\n41069072\n>>> d = 257\n>>> id(257)\n41069096\nid 函数可以用来查看一个对象的唯一标志，可以认为是内存地址\n\n对于大整数，Python 使用的是一个 大整数对象池 。这句话的意思是：\n\n每当创建一个大整数的时候，都会新建一个对象，但是这个对象不再使用的时候，并不会销毁，后面再建立的对象会复用之前已经不再使用的对象的内存空间。（这里的不再使用指的是引用计数为0，可以被销毁）\n\n### 字符串对象缓冲池\n如果仔细思考一下，一定会猜到字符串也采用了这种类似的技术，我们来看一下\n\n>>> a = 'a'\n>>> b = 'a'\n>>> id(a)\n14660456\n>>> id(b)\n14660456\n没错，Python 的设计者为 一个字节 的字符对应的字符串对象 (PyStringObject) 也设计了这样一个对象池。同时还有一个 intern 机制，可以将内容相同的字符串变量转换成指向同一个字符串对象。\n\nintern 机制的关键，就是在系统中有一个（key，value）映射关系的集合，集合的名称叫做 interned。在这个集合中，记录着被 intern 机制处理过的 PyStringObject 对象。不过 Python 始终会为字符串创建 PyStringObject 对象，即便在interned 中已经有一个与之对应的 PyStringObject 对象了，而 intern 机制是在字符串被创建后才起作用。\n\n>>> a = 'a string'\n>>> b = 'a string'\n>>> a is b\nFalse\n>>> a = intern('a string') # 手动调用 intern 方法\n>>> b = intern('a string')\n>>> a is b\nTrue\n关于 intern 函数 可以参考 官方文档 ，更多扩展阅读：\n\nhttp://stackoverflow.com/questions/15541404/python-string-interning\n\n值得说明的是，数值类型和字符串类型在 Python 中都是不可变的，这意味着你无法修改这个对象的值，每次对变量的修改，实际上是创建一个新的对象。得益于这样的设计，才能使用对象缓冲池这种优化。\n\nPython 的实现上大量采用了这种内存对象池的技术，不仅仅对于这些特定的对象，还有专门的内存池用于小对象，使用这种技术可以避免频繁地申请和释放内存空间，目的就是让 Python 能稍微更快一点。更多内容可以参考 这里 。\n\n如果想了解更快的 Python，可以看看 PyPy\n\n### import 指令\n前文提到 import 指令是用来载入 module 的，如果需要，也会顺道做编译的事。但 import 指令，还会做一件重要的事情就是把 import 的那个 module 的代码执行一遍， 这件事情很重要 。Python 是解释执行的，连函数都是执行的时候才创建的。如果不把那个 module 的代码执行一遍，那么 module 里面的函数都没法创建，更别提去调用这些函数了。\n\n执行代码的另外一个重要作用，就是在这个 module 的命名空间中，创建模块内定义的函数和各种对象的符号名称（也就是变量名），并将其绑定到对象上，这样其他 module 才能通过变量名来引用这些对象。\n\nPython 虚拟机还会将已经 import 过的 module 缓存起来，放到一个全局 module 集合 sys.modules 中。这样做有一个好处，即如果程序的在另一个地方再次 import 这个模块，Python 虚拟机只需要将全局 module 集合中缓存的那个 module 对象返回即可。\n\n你现在一定想到了 sys.modules 是一个 dict 对象，可以通过 type(sys.modules) 来验证\n\n### 多线程\ndemo.py 这个例子并没有用到多线程，但还是有必要提一下。\n\n在提到多线程的时候，往往要关注线程如何同步，如何访问共享资源。Python 是通过一个全局解释器锁 GIL（Global Interpreter Lock）来实现线程同步的。当 Python 程序只有单线程时，并不会启用 GIL，而当用户创建了一个 thread 时，表示要使用多线程，Python 解释器就会自动激活 GIL，并创建所需要的上下文环境和数据结构。\n\nPython 字节码解释器的工作原理是按照指令的顺序一条一条地顺序执行，Python 内部维护着一个数值，这个数值就是 Python 内部的时钟，如果这个数值为 N，则意味着 Python 在执行了 N 条指令以后应该立即启动线程调度机制，可以通过下面的代码获取这个数值。\n\nimport sys\nsys.getcheckinterval() # 100\n线程调度机制将会为线程分配 GIL，获取到 GIL 的线程就能开始执行，而其他线程则必须等待。由于 GIL 的存在，Python 的多线程性能十分低下，无法发挥多核 CPU 的优势，性能甚至不如单线程。因此如果你想用到多核 CPU，一个建议是使用 多进程 。\n\n### 垃圾回收\n在讲到垃圾回收的时候，通常会使用引用计数的模型，这是一种最直观，最简单的垃圾收集技术。Python 同样也使用了引用计数，但是引用计数存在这些缺点：\n\n频繁更新引用计数会降低运行效率\n引用计数无法解决循环引用问题\nPython 在 引用计数机制 的基础上，使用了主流垃圾收集技术中的 标记——清除 和 分代收集 两种技术。\n\n关于垃圾回收，可以参考\n\nhttp://hbprotoss.github.io/posts/pythonla-ji-hui-shou-ji-zhi.html\n\n## 参考文献\n《Python源码分析》\n","source":"_posts/Python解释执行原理及过程.md","raw":"---\ntitle: Python解释执行原理及过程\ndate: 2016-10-25 23:55:47\ntags:\ncategories: 技术向\nthumbnail: http://i1.piimg.com/567571/de3fdf0bf57dff25.png\n---\n\n\n## 简单的例子\n先从一个简单的例子说起，包含了两个文件 foo.py 和 demo.py\n``` bash\n[foo.py]\ndef add(a, b):\n    return a + b\n[demo.py]\nimport foo\na = [1, 'python']\na = 'a string'\ndef func():\n\ta = 1\n\tb = 257\n\tprint(a + b)\nprint(a)\nif __name__ == '__main__':\n\tfunc()\n\tfoo.add(1, 2)\n```\n执行这个程序\n\npython demo.py\n输出结果\n\na string\n258\n同时，该文件目录多出一个 foo.pyc 文件\n\n## 背后的魔法\n看完程序的执行结果，接下来开始一行行解释代码。\n\n### 模块\nPython 将 .py 文件视为一个 module，这些 module 中，有一个主 module，也就是程序运行的入口。在这个例子中，主 module 是 demo.py。\n\n### 编译\n执行 python demo.py 后，将会启动 Python 的解释器，然后将 demo.py 编译成一个字节码对象 PyCodeObject。\n\n有的人可能会很好奇，编译的结果不应是 pyc 文件吗，就像 Java 的 class 文件，那为什么是一个对象呢，这里稍微解释一下。\n\n在 Python 的世界中，一切都是对象，函数也是对象，类型也是对象，类也是对象（类属于自定义的类型，在 Python ### 之前，int, dict 这些内置类型与类是存在不同的，在之后才统一起来，全部继承自 object），甚至连编译出来的字节码也是对象，.pyc 文件是字节码对象（PyCodeObject）在硬盘上的表现形式。\n\n在运行期间，编译结果也就是 PyCodeObject 对象，只会存在于内存中，而当这个模块的 Python 代码 执行完 后，就会将编译结果保存到了 pyc 文件中，这样下次就不用编译，直接加载到内存中。pyc 文件只是 PyCodeObject 对象在硬盘上的表现形式。\n\n这个 PyCodeObject 对象包含了 Python 源代码中的字符串，常量值，以及通过语法解析后编译生成的字节码指令。PyCodeObject 对象还会存储这些字节码指令与原始代码行号的对应关系，这样当出现异常时，就能指明位于哪一行的代码。\n\n### pyc 文件\n一个 pyc 文件包含了三部分信息：Python 的 magic number、pyc 文件创建的时间信息，以及 PyCodeObject 对象。\n\nmagic number 是 Python 定义的一个整数值。一般来说，不同版本的 Python 实现都会定义不同的 magic number，这个值是用来保证 Python 兼容性的。比如要限制由低版本编译的 pyc 文件不能让高版本的 Python 程序来执行，只需要检查 magic number 不同就可以了。由于不同版本的 Python 定义的字节码指令可能会不同，如果不做检查，执行的时候就可能出错。\n\n下面所示的代码可以来创建 pyc 文件，使用方法\n\n python generate_pyc.py module_name\n例如\n\n python generate_pyc.py demo\n[generate_pyc.pyc]\nimport imp\nimport sys\ndef generate_pyc(name):\n\tfp, pathname, description = imp.find_module(name)\n\ttry:\n\t\timp.load_module(name, fp, pathname, description)\t\n\tfinally:\n\t\tif fp:\n\t\t\tfp.close()\nif __name__ == '__main__':\n\tgenerate_pyc(sys.argv[1])\n### 字节码指令\n为什么 pyc 文件也称作字节码文件？因为这些文件存储的都是一些二进制的字节数据，而不是能让人直观查看的文本数据。\n\nPython 标准库提供了用来生成代码对应字节码的工具 dis 。dis 提供一个名为 dis 的方法，这个方法接收一个 code 对象，然后会输出 code 对象里的字节码指令信息。\n\ns = open('demo.py').read()\nco = compile(s, 'demo.py', 'exec')\nimport dis\ndis.dis(co)\n执行上面这段代码可以输出 demo.py 编译后的字节码指令\n\n  1           0 LOAD_CONST\t   0 (-1)\n\t 3 LOAD_CONST\t   1 (None)\n\t 6 IMPORT_NAME\t  0 (foo)\n\t 9 STORE_NAME\t   0 (foo)\n 3          12 LOAD_CONST\t   2 (1)\n\t15 LOAD_CONST\t   3 (u'python')\n\t18 BUILD_LIST\t   2\n\t21 STORE_NAME\t   1 (a)\n 4          24 LOAD_CONST\t   4 (u'a string')\n\t27 STORE_NAME\t   1 (a)\n 6          30 LOAD_CONST\t   5 (<code object func at 00D97650, file \"demo.py\", line 6>)\n\t33 MAKE_FUNCTION\t0\n\t36 STORE_NAME\t   2 (func)\n11          39 LOAD_NAME\t    1 (a)\n\t42 PRINT_ITEM          \n\t43 PRINT_NEWLINE       \n13          44 LOAD_NAME\t    3 (__name__)\n\t47 LOAD_CONST\t   6 (u'__main__')\n\t50 COMPARE_OP\t   2 (==)\n\t53 POP_JUMP_IF_FALSE       82\n14          56 LOAD_NAME\t    2 (func)\n\t59 CALL_FUNCTION\t0\n\t62 POP_TOP\t \n15          63 LOAD_NAME\t    0 (foo)\n\t66 LOAD_ATTR\t    4 (add)\n\t69 LOAD_CONST\t   2 (1)\n\t72 LOAD_CONST\t   7 (2)\n\t75 CALL_FUNCTION\t2\n\t78 POP_TOP\t \n\t79 JUMP_FORWARD\t 0 (to 82)\n       >>   82 LOAD_CONST\t   1 (None)\n\t85 RETURN_VALUE        \n### Python 虚拟机\ndemo.py 被编译后，接下来的工作就交由 Python 虚拟机来执行字节码指令了。Python 虚拟机会从编译得到的 PyCodeObject 对象中依次读入每一条字节码指令，并在当前的 上下文环境 中执行这条字节码指令。我们的程序就是通过这样循环往复的过程才得以执行。\n\n### import 指令\ndemo.py 的第一行代码是 import foo 。import 指令用来载入一个模块，另外一个载入模块的方法是 from xx import yy 。用 from 语句的好处是，可以只复制需要的符号变量到当前的命名空间中（关于命名空间将在后面介绍）。\n\n前文提到，当已经存在 pyc 文件时，就可以直接载入而省去编译过程。但是代码文件的内容会更新，如何保证更新后能重新编译而不入旧的 pyc 文件呢。答案就在 pyc 文件中存储的 创建时间信息 。当执行 import 指令的时候，如果已存在 pyc 文件，Python 会检查创建时间是否晚于代码文件的修改时间，这样就能判断是否需要重新编译，还是直接载入了。如果不存在 pyc 文件，就会先将 py 文件编译。\n\n### 绝对引入和相对引入\n前文已经介绍了 import foo 这行代码。这里隐含了一个问题，就是 foo 是什么，如何找到 foo 。这就属于 Python 的模块引入规则，这里不展开介绍，可以参考 pep-0328 。\n\n### 赋值语句\n接下来，执行到 a = [1, 'python'] ，这是一条赋值语句，定义了一个变量 a，它对应的值是 [1, 'python']。这里要解释一下， 变量 是什么呢？\n\n按照 维基百科 的解释\n\n变量是一个存储位置和一个关联的符号名字，这个存储位置包含了一些已知或未知的量或者信息。\n\n变量实际上是一个字符串的符号，用来关联一个存储在内存中的对象。在 Python 中，会使用 dict（就是 Python 的 dict 对象）来存储变量符号（字符串）与一个对象的映射。\n\n那么赋值语句实际上就是用来建立这种关联，在这个例子中是将符号 a 与一个列表对象 [1, 'python'] 建立映射。\n\n紧接着的代码执行了 a = 'a string' ，这条指令则将符号 a 与另外一个字符串对象 a string 建立了映射。今后对变量 a 的操作，将反应到字符串对象 a string 上。\n\n### def 指令\n我们的 Python 代码继续往下运行，这里执行到一条 def func() ，从字节码指令中也可以看出端倪 MAKE_FUNCTION 。没错这条指令是用来创建函数的。Python 是动态语言，def 实际上是执行一条指令，用来创建函数（class 则是创建类的指令），而不仅仅是个语法关键字。函数并不是事先创建好的，而是执行到的时候才创建的。\n\ndef func() 将会创建一个名称为 func 的函数对象。实际上是先创建一个函数对象，然后将 func 这个名称符号绑定到这个函数上。\n\nPython 中是无法实现 C 和 Java 中的重载的，因为重载要求函数名要相同，而参数的类型或数量不同，但是 Python 是通过变量符号（如这里的 func ）来关联一个函数，当我们用 def 语句再次创建一个同名的函数时，这个变量名就绑定到新的函数对象上了。\n\n### 动态类型\n继续看函数 func 里面的代码，这时又有一条赋值语句 a = 1 。变量 a 现在已经变成了第三种类型，它现在是一个整数了。那么 Python 是怎么实现动态类型的呢？答案就藏在具体存储的对象上。变量 a 仅仅只是一个符号（实际上是一个字符串对象），类型信息是存储在对象上的。在 Python 中，对象机制的核心是类型信息和引用计数（引用计数属于垃圾回收的部分）。\n\n用 type(a)，可以输出 a 的类型，这里是 int\n\nb = 257 跳过，我们直接来看看 print(a + b) ，print 是输出函数，这里略过。这里想要探究的是 a + b 。\n\n因为 a 和 b 并不存储类型信息，因此当执行 a + b 的时候就必须先检查类型，比如 1 + 2 和 \"1\" + \"2\" 的结果是不一样的。\n\n看到这里，我们就可以想象一下执行一句简单的 a + b ，Python 虚拟机需要做多少繁琐的事情了。首先需要分别检查 a 和 b 所对应对象的类型，还要匹配类型是否一致（1 + \"2\" 将会出现异常），然后根据对象的类型调用正确的 + 函数（例如数值的 + 或字符串的 +），\n\n而 CPU 对于上面这条语句只需要执行 ADD 指令\n（还需要先将变量 MOV 到寄存器）。\n\n### 命名空间 (namespace)\n在介绍上面的这些代码时，还漏掉了一个关键的信息就是命名空间。在 Python 中，类、函数、module 都对应着一个独立的命名空间。而一个独立的命名空间会对应一个 PyCodeObject 对象，所以上面的 demo.py 文件编译后会生成两个 PyCodeObject，只是在 demo.py 这个 module 层的 PyCodeObject 中通过一个变量符号 func 嵌套了一个函数的 PyCodeObject。\n\n命名空间的意义，就是用来确定一个变量符号到底对应什么对象。命名空间可以一个套一个地形成一条命名空间链，Python 虚拟机在执行的过程中，会有很大一部分时间消耗在从这条命名空间链中确定一个符号所对应的对象是什么。\n\n在 Python中，命名空间是由一个 dict 对象实现的，它维护了（name，obj）这样的关联关系。\n\n说到这里，再补充一下 import foo 这行代码会在 demo.py 这个模块的命名空间中，创建一个新的变量名 foo ， foo 将绑定到一个 PyCodeObject 对象，也就是 foo.py 的编译结果。\n\n#### dir 函数\n\nPython 的 内置函数 dir 可以用来查看一个命名空间下的所有名字符号。一个用处是查看一个命名空间的所有属性和方法（这里的命名空间就是指类、函数、module）。\n\n比如，查看当前的命名空间，可以使用 dir()，查看 sys 模块，可以使用 dir(sys)。\n\n#### LEGB 规则\n\nPython 使用 LEGB 的顺序来查找一个符号对应的对象\n\nlocals -> enclosing function -> globals -> builtins\n\nlocals，当前所在命名空间（如函数、模块），函数的参数也属于命名空间内的变量\n\nenclosing，外部嵌套函数的命名空间（闭包中常见）\n\ndef fun1(a):\n    def fun2():\n        # a 位于外部嵌套函数的命名空间\n        print(a)\nglobals，全局变量，函数定义所在模块的命名空间\n\na = 1\ndef fun():\n    # 需要通过 global 指令来声明全局变量\n    global a\n    # 修改全局变量，而不是创建一个新的 local 变量\n    a = 2\nbuiltins，内置模块的命名空间。Python 在启动的时候会自动为我们载入很多内置的函数、类，比如 dict，list，type，print，这些都位于 __builtins__ 模块中，可以使用 dir(__builtins__) 来查看。这也是为什么我们在没有 import 任何模块的情况下，就能使用这么多丰富的函数和功能了。\n\n介绍完命名空间，就能理解 print(a) 这行代码输出的结果为什么是 a string 了。\n\n### 内置属性 __name__\n现在到了解释 if __name__ == '__main__' 这行代码的时候了。当 Python 程序启动后，Python 会自动为每个模块设置一个属性 __name__ 通常使用的是模块的名字，也就是文件名，但唯一的例外是主模块，主模块将会被设置为 __main__ 。利用这一特性，就可以做一些特别的事。比如当该模块以主模块来运行的时候，可以运行测试用例。而当被其他模块 import 时，则只是乖乖的，提供函数和功能就好。\n\n### 函数调用\n最后两行是函数调用，这里略去不讲。\n\n## 回顾\n讲到最后，还有些内容需要再回顾和补充一下。\n\n### pyc 文件\nPython 只会对那些以后可能继续被使用和载入的模块才会生成 pyc 文件，Python 认为使用了 import 指令的模块，属于这种类型，因此会生成 pyc 文件。而对于只是临时用一次的模块，并不会生成 pyc 文件，Python 将主模块当成了这种类型的文件。这就解释了为什么 python demo.py 执行完后，只会生成一个 foo.pyc 文件。\n\n如果要问 pyc 文件什么时候生成，答案就是在执行了 import 指令之后，from xx import yy 同样属于 import 指令。\n\n### 小整数对象池\n在 demo.py 这里例子中，所用的整数特意用了一个 257，这是为了介绍小整数对象池的。整数在程序中的使用非常广泛，Python 为了优化速度，使用了小整数对象池，避免为整数频繁申请和销毁内存空间。\n\nPython 对小整数的定义是 [-5, 257)，这些整数对象是提前建立好的，不会被垃圾回收。在一个 Python 的程序中，所有位于这个范围内的整数使用的都是同一个对象，从下面这个例子就可以看出。\n\n>>> a = 1\n>>> id(a)\n40059744\n>>> b = 1\n>>> id(b)\n40059744\n>>> c = 257\n>>> id(c)\n41069072\n>>> d = 257\n>>> id(257)\n41069096\nid 函数可以用来查看一个对象的唯一标志，可以认为是内存地址\n\n对于大整数，Python 使用的是一个 大整数对象池 。这句话的意思是：\n\n每当创建一个大整数的时候，都会新建一个对象，但是这个对象不再使用的时候，并不会销毁，后面再建立的对象会复用之前已经不再使用的对象的内存空间。（这里的不再使用指的是引用计数为0，可以被销毁）\n\n### 字符串对象缓冲池\n如果仔细思考一下，一定会猜到字符串也采用了这种类似的技术，我们来看一下\n\n>>> a = 'a'\n>>> b = 'a'\n>>> id(a)\n14660456\n>>> id(b)\n14660456\n没错，Python 的设计者为 一个字节 的字符对应的字符串对象 (PyStringObject) 也设计了这样一个对象池。同时还有一个 intern 机制，可以将内容相同的字符串变量转换成指向同一个字符串对象。\n\nintern 机制的关键，就是在系统中有一个（key，value）映射关系的集合，集合的名称叫做 interned。在这个集合中，记录着被 intern 机制处理过的 PyStringObject 对象。不过 Python 始终会为字符串创建 PyStringObject 对象，即便在interned 中已经有一个与之对应的 PyStringObject 对象了，而 intern 机制是在字符串被创建后才起作用。\n\n>>> a = 'a string'\n>>> b = 'a string'\n>>> a is b\nFalse\n>>> a = intern('a string') # 手动调用 intern 方法\n>>> b = intern('a string')\n>>> a is b\nTrue\n关于 intern 函数 可以参考 官方文档 ，更多扩展阅读：\n\nhttp://stackoverflow.com/questions/15541404/python-string-interning\n\n值得说明的是，数值类型和字符串类型在 Python 中都是不可变的，这意味着你无法修改这个对象的值，每次对变量的修改，实际上是创建一个新的对象。得益于这样的设计，才能使用对象缓冲池这种优化。\n\nPython 的实现上大量采用了这种内存对象池的技术，不仅仅对于这些特定的对象，还有专门的内存池用于小对象，使用这种技术可以避免频繁地申请和释放内存空间，目的就是让 Python 能稍微更快一点。更多内容可以参考 这里 。\n\n如果想了解更快的 Python，可以看看 PyPy\n\n### import 指令\n前文提到 import 指令是用来载入 module 的，如果需要，也会顺道做编译的事。但 import 指令，还会做一件重要的事情就是把 import 的那个 module 的代码执行一遍， 这件事情很重要 。Python 是解释执行的，连函数都是执行的时候才创建的。如果不把那个 module 的代码执行一遍，那么 module 里面的函数都没法创建，更别提去调用这些函数了。\n\n执行代码的另外一个重要作用，就是在这个 module 的命名空间中，创建模块内定义的函数和各种对象的符号名称（也就是变量名），并将其绑定到对象上，这样其他 module 才能通过变量名来引用这些对象。\n\nPython 虚拟机还会将已经 import 过的 module 缓存起来，放到一个全局 module 集合 sys.modules 中。这样做有一个好处，即如果程序的在另一个地方再次 import 这个模块，Python 虚拟机只需要将全局 module 集合中缓存的那个 module 对象返回即可。\n\n你现在一定想到了 sys.modules 是一个 dict 对象，可以通过 type(sys.modules) 来验证\n\n### 多线程\ndemo.py 这个例子并没有用到多线程，但还是有必要提一下。\n\n在提到多线程的时候，往往要关注线程如何同步，如何访问共享资源。Python 是通过一个全局解释器锁 GIL（Global Interpreter Lock）来实现线程同步的。当 Python 程序只有单线程时，并不会启用 GIL，而当用户创建了一个 thread 时，表示要使用多线程，Python 解释器就会自动激活 GIL，并创建所需要的上下文环境和数据结构。\n\nPython 字节码解释器的工作原理是按照指令的顺序一条一条地顺序执行，Python 内部维护着一个数值，这个数值就是 Python 内部的时钟，如果这个数值为 N，则意味着 Python 在执行了 N 条指令以后应该立即启动线程调度机制，可以通过下面的代码获取这个数值。\n\nimport sys\nsys.getcheckinterval() # 100\n线程调度机制将会为线程分配 GIL，获取到 GIL 的线程就能开始执行，而其他线程则必须等待。由于 GIL 的存在，Python 的多线程性能十分低下，无法发挥多核 CPU 的优势，性能甚至不如单线程。因此如果你想用到多核 CPU，一个建议是使用 多进程 。\n\n### 垃圾回收\n在讲到垃圾回收的时候，通常会使用引用计数的模型，这是一种最直观，最简单的垃圾收集技术。Python 同样也使用了引用计数，但是引用计数存在这些缺点：\n\n频繁更新引用计数会降低运行效率\n引用计数无法解决循环引用问题\nPython 在 引用计数机制 的基础上，使用了主流垃圾收集技术中的 标记——清除 和 分代收集 两种技术。\n\n关于垃圾回收，可以参考\n\nhttp://hbprotoss.github.io/posts/pythonla-ji-hui-shou-ji-zhi.html\n\n## 参考文献\n《Python源码分析》\n","slug":"Python解释执行原理及过程","published":1,"updated":"2021-12-12T14:25:37.697Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3bsl2ih00085awq6uctcs5p","content":"<h2 id=\"简单的例子\"><a href=\"#简单的例子\" class=\"headerlink\" title=\"简单的例子\"></a>简单的例子</h2><p>先从一个简单的例子说起，包含了两个文件 foo.py 和 demo.py</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">[foo.py]<br>def add(a, b):<br>    <span class=\"hljs-built_in\">return</span> a + b<br>[demo.py]<br>import foo<br>a = [1, <span class=\"hljs-string\">&#x27;python&#x27;</span>]<br>a = <span class=\"hljs-string\">&#x27;a string&#x27;</span><br>def func():<br>\ta = 1<br>\tb = 257<br>\t<span class=\"hljs-built_in\">print</span>(a + b)<br><span class=\"hljs-built_in\">print</span>(a)<br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&#x27;__main__&#x27;</span>:<br>\tfunc()<br>\tfoo.add(1, 2)<br></code></pre></td></tr></table></figure>\n<p>执行这个程序</p>\n<p>python demo.py<br>输出结果</p>\n<p>a string<br>258<br>同时，该文件目录多出一个 foo.pyc 文件</p>\n<h2 id=\"背后的魔法\"><a href=\"#背后的魔法\" class=\"headerlink\" title=\"背后的魔法\"></a>背后的魔法</h2><p>看完程序的执行结果，接下来开始一行行解释代码。</p>\n<h3 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h3><p>Python 将 .py 文件视为一个 module，这些 module 中，有一个主 module，也就是程序运行的入口。在这个例子中，主 module 是 demo.py。</p>\n<h3 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h3><p>执行 python demo.py 后，将会启动 Python 的解释器，然后将 demo.py 编译成一个字节码对象 PyCodeObject。</p>\n<p>有的人可能会很好奇，编译的结果不应是 pyc 文件吗，就像 Java 的 class 文件，那为什么是一个对象呢，这里稍微解释一下。</p>\n<p>在 Python 的世界中，一切都是对象，函数也是对象，类型也是对象，类也是对象（类属于自定义的类型，在 Python ### 之前，int, dict 这些内置类型与类是存在不同的，在之后才统一起来，全部继承自 object），甚至连编译出来的字节码也是对象，.pyc 文件是字节码对象（PyCodeObject）在硬盘上的表现形式。</p>\n<p>在运行期间，编译结果也就是 PyCodeObject 对象，只会存在于内存中，而当这个模块的 Python 代码 执行完 后，就会将编译结果保存到了 pyc 文件中，这样下次就不用编译，直接加载到内存中。pyc 文件只是 PyCodeObject 对象在硬盘上的表现形式。</p>\n<p>这个 PyCodeObject 对象包含了 Python 源代码中的字符串，常量值，以及通过语法解析后编译生成的字节码指令。PyCodeObject 对象还会存储这些字节码指令与原始代码行号的对应关系，这样当出现异常时，就能指明位于哪一行的代码。</p>\n<h3 id=\"pyc-文件\"><a href=\"#pyc-文件\" class=\"headerlink\" title=\"pyc 文件\"></a>pyc 文件</h3><p>一个 pyc 文件包含了三部分信息：Python 的 magic number、pyc 文件创建的时间信息，以及 PyCodeObject 对象。</p>\n<p>magic number 是 Python 定义的一个整数值。一般来说，不同版本的 Python 实现都会定义不同的 magic number，这个值是用来保证 Python 兼容性的。比如要限制由低版本编译的 pyc 文件不能让高版本的 Python 程序来执行，只需要检查 magic number 不同就可以了。由于不同版本的 Python 定义的字节码指令可能会不同，如果不做检查，执行的时候就可能出错。</p>\n<p>下面所示的代码可以来创建 pyc 文件，使用方法</p>\n<p> python generate_pyc.py module_name<br>例如</p>\n<p> python generate_pyc.py demo<br>[generate_pyc.pyc]<br>import imp<br>import sys<br>def generate_pyc(name):<br>    fp, pathname, description &#x3D; imp.find_module(name)<br>    try:<br>        imp.load_module(name, fp, pathname, description)\t<br>    finally:<br>        if fp:<br>            fp.close()<br>if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘:<br>    generate_pyc(sys.argv[1])</p>\n<h3 id=\"字节码指令\"><a href=\"#字节码指令\" class=\"headerlink\" title=\"字节码指令\"></a>字节码指令</h3><p>为什么 pyc 文件也称作字节码文件？因为这些文件存储的都是一些二进制的字节数据，而不是能让人直观查看的文本数据。</p>\n<p>Python 标准库提供了用来生成代码对应字节码的工具 dis 。dis 提供一个名为 dis 的方法，这个方法接收一个 code 对象，然后会输出 code 对象里的字节码指令信息。</p>\n<p>s &#x3D; open(‘demo.py’).read()<br>co &#x3D; compile(s, ‘demo.py’, ‘exec’)<br>import dis<br>dis.dis(co)<br>执行上面这段代码可以输出 demo.py 编译后的字节码指令</p>\n<p>  1           0 LOAD_CONST\t   0 (-1)<br>     3 LOAD_CONST\t   1 (None)<br>     6 IMPORT_NAME\t  0 (foo)<br>     9 STORE_NAME\t   0 (foo)<br> 3          12 LOAD_CONST\t   2 (1)<br>    15 LOAD_CONST\t   3 (u’python’)<br>    18 BUILD_LIST\t   2<br>    21 STORE_NAME\t   1 (a)<br> 4          24 LOAD_CONST\t   4 (u’a string’)<br>    27 STORE_NAME\t   1 (a)<br> 6          30 LOAD_CONST\t   5 (&lt;code object func at 00D97650, file “demo.py”, line 6&gt;)<br>    33 MAKE_FUNCTION\t0<br>    36 STORE_NAME\t   2 (func)<br>11          39 LOAD_NAME\t    1 (a)<br>    42 PRINT_ITEM<br>    43 PRINT_NEWLINE<br>13          44 LOAD_NAME\t    3 (<strong>name</strong>)<br>    47 LOAD_CONST\t   6 (u’<strong>main</strong>‘)<br>    50 COMPARE_OP\t   2 (&#x3D;&#x3D;)<br>    53 POP_JUMP_IF_FALSE       82<br>14          56 LOAD_NAME\t    2 (func)<br>    59 CALL_FUNCTION\t0<br>    62 POP_TOP\t<br>15          63 LOAD_NAME\t    0 (foo)<br>    66 LOAD_ATTR\t    4 (add)<br>    69 LOAD_CONST\t   2 (1)<br>    72 LOAD_CONST\t   7 (2)<br>    75 CALL_FUNCTION\t2<br>    78 POP_TOP\t<br>    79 JUMP_FORWARD\t 0 (to 82)<br>       &gt;&gt;   82 LOAD_CONST\t   1 (None)<br>    85 RETURN_VALUE        </p>\n<h3 id=\"Python-虚拟机\"><a href=\"#Python-虚拟机\" class=\"headerlink\" title=\"Python 虚拟机\"></a>Python 虚拟机</h3><p>demo.py 被编译后，接下来的工作就交由 Python 虚拟机来执行字节码指令了。Python 虚拟机会从编译得到的 PyCodeObject 对象中依次读入每一条字节码指令，并在当前的 上下文环境 中执行这条字节码指令。我们的程序就是通过这样循环往复的过程才得以执行。</p>\n<h3 id=\"import-指令\"><a href=\"#import-指令\" class=\"headerlink\" title=\"import 指令\"></a>import 指令</h3><p>demo.py 的第一行代码是 import foo 。import 指令用来载入一个模块，另外一个载入模块的方法是 from xx import yy 。用 from 语句的好处是，可以只复制需要的符号变量到当前的命名空间中（关于命名空间将在后面介绍）。</p>\n<p>前文提到，当已经存在 pyc 文件时，就可以直接载入而省去编译过程。但是代码文件的内容会更新，如何保证更新后能重新编译而不入旧的 pyc 文件呢。答案就在 pyc 文件中存储的 创建时间信息 。当执行 import 指令的时候，如果已存在 pyc 文件，Python 会检查创建时间是否晚于代码文件的修改时间，这样就能判断是否需要重新编译，还是直接载入了。如果不存在 pyc 文件，就会先将 py 文件编译。</p>\n<h3 id=\"绝对引入和相对引入\"><a href=\"#绝对引入和相对引入\" class=\"headerlink\" title=\"绝对引入和相对引入\"></a>绝对引入和相对引入</h3><p>前文已经介绍了 import foo 这行代码。这里隐含了一个问题，就是 foo 是什么，如何找到 foo 。这就属于 Python 的模块引入规则，这里不展开介绍，可以参考 pep-0328 。</p>\n<h3 id=\"赋值语句\"><a href=\"#赋值语句\" class=\"headerlink\" title=\"赋值语句\"></a>赋值语句</h3><p>接下来，执行到 a &#x3D; [1, ‘python’] ，这是一条赋值语句，定义了一个变量 a，它对应的值是 [1, ‘python’]。这里要解释一下， 变量 是什么呢？</p>\n<p>按照 维基百科 的解释</p>\n<p>变量是一个存储位置和一个关联的符号名字，这个存储位置包含了一些已知或未知的量或者信息。</p>\n<p>变量实际上是一个字符串的符号，用来关联一个存储在内存中的对象。在 Python 中，会使用 dict（就是 Python 的 dict 对象）来存储变量符号（字符串）与一个对象的映射。</p>\n<p>那么赋值语句实际上就是用来建立这种关联，在这个例子中是将符号 a 与一个列表对象 [1, ‘python’] 建立映射。</p>\n<p>紧接着的代码执行了 a &#x3D; ‘a string’ ，这条指令则将符号 a 与另外一个字符串对象 a string 建立了映射。今后对变量 a 的操作，将反应到字符串对象 a string 上。</p>\n<h3 id=\"def-指令\"><a href=\"#def-指令\" class=\"headerlink\" title=\"def 指令\"></a>def 指令</h3><p>我们的 Python 代码继续往下运行，这里执行到一条 def func() ，从字节码指令中也可以看出端倪 MAKE_FUNCTION 。没错这条指令是用来创建函数的。Python 是动态语言，def 实际上是执行一条指令，用来创建函数（class 则是创建类的指令），而不仅仅是个语法关键字。函数并不是事先创建好的，而是执行到的时候才创建的。</p>\n<p>def func() 将会创建一个名称为 func 的函数对象。实际上是先创建一个函数对象，然后将 func 这个名称符号绑定到这个函数上。</p>\n<p>Python 中是无法实现 C 和 Java 中的重载的，因为重载要求函数名要相同，而参数的类型或数量不同，但是 Python 是通过变量符号（如这里的 func ）来关联一个函数，当我们用 def 语句再次创建一个同名的函数时，这个变量名就绑定到新的函数对象上了。</p>\n<h3 id=\"动态类型\"><a href=\"#动态类型\" class=\"headerlink\" title=\"动态类型\"></a>动态类型</h3><p>继续看函数 func 里面的代码，这时又有一条赋值语句 a &#x3D; 1 。变量 a 现在已经变成了第三种类型，它现在是一个整数了。那么 Python 是怎么实现动态类型的呢？答案就藏在具体存储的对象上。变量 a 仅仅只是一个符号（实际上是一个字符串对象），类型信息是存储在对象上的。在 Python 中，对象机制的核心是类型信息和引用计数（引用计数属于垃圾回收的部分）。</p>\n<p>用 type(a)，可以输出 a 的类型，这里是 int</p>\n<p>b &#x3D; 257 跳过，我们直接来看看 print(a + b) ，print 是输出函数，这里略过。这里想要探究的是 a + b 。</p>\n<p>因为 a 和 b 并不存储类型信息，因此当执行 a + b 的时候就必须先检查类型，比如 1 + 2 和 “1” + “2” 的结果是不一样的。</p>\n<p>看到这里，我们就可以想象一下执行一句简单的 a + b ，Python 虚拟机需要做多少繁琐的事情了。首先需要分别检查 a 和 b 所对应对象的类型，还要匹配类型是否一致（1 + “2” 将会出现异常），然后根据对象的类型调用正确的 + 函数（例如数值的 + 或字符串的 +），</p>\n<p>而 CPU 对于上面这条语句只需要执行 ADD 指令<br>（还需要先将变量 MOV 到寄存器）。</p>\n<h3 id=\"命名空间-namespace\"><a href=\"#命名空间-namespace\" class=\"headerlink\" title=\"命名空间 (namespace)\"></a>命名空间 (namespace)</h3><p>在介绍上面的这些代码时，还漏掉了一个关键的信息就是命名空间。在 Python 中，类、函数、module 都对应着一个独立的命名空间。而一个独立的命名空间会对应一个 PyCodeObject 对象，所以上面的 demo.py 文件编译后会生成两个 PyCodeObject，只是在 demo.py 这个 module 层的 PyCodeObject 中通过一个变量符号 func 嵌套了一个函数的 PyCodeObject。</p>\n<p>命名空间的意义，就是用来确定一个变量符号到底对应什么对象。命名空间可以一个套一个地形成一条命名空间链，Python 虚拟机在执行的过程中，会有很大一部分时间消耗在从这条命名空间链中确定一个符号所对应的对象是什么。</p>\n<p>在 Python中，命名空间是由一个 dict 对象实现的，它维护了（name，obj）这样的关联关系。</p>\n<p>说到这里，再补充一下 import foo 这行代码会在 demo.py 这个模块的命名空间中，创建一个新的变量名 foo ， foo 将绑定到一个 PyCodeObject 对象，也就是 foo.py 的编译结果。</p>\n<h4 id=\"dir-函数\"><a href=\"#dir-函数\" class=\"headerlink\" title=\"dir 函数\"></a>dir 函数</h4><p>Python 的 内置函数 dir 可以用来查看一个命名空间下的所有名字符号。一个用处是查看一个命名空间的所有属性和方法（这里的命名空间就是指类、函数、module）。</p>\n<p>比如，查看当前的命名空间，可以使用 dir()，查看 sys 模块，可以使用 dir(sys)。</p>\n<h4 id=\"LEGB-规则\"><a href=\"#LEGB-规则\" class=\"headerlink\" title=\"LEGB 规则\"></a>LEGB 规则</h4><p>Python 使用 LEGB 的顺序来查找一个符号对应的对象</p>\n<p>locals -&gt; enclosing function -&gt; globals -&gt; builtins</p>\n<p>locals，当前所在命名空间（如函数、模块），函数的参数也属于命名空间内的变量</p>\n<p>enclosing，外部嵌套函数的命名空间（闭包中常见）</p>\n<p>def fun1(a):<br>    def fun2():<br>        # a 位于外部嵌套函数的命名空间<br>        print(a)<br>globals，全局变量，函数定义所在模块的命名空间</p>\n<p>a &#x3D; 1<br>def fun():<br>    # 需要通过 global 指令来声明全局变量<br>    global a<br>    # 修改全局变量，而不是创建一个新的 local 变量<br>    a &#x3D; 2<br>builtins，内置模块的命名空间。Python 在启动的时候会自动为我们载入很多内置的函数、类，比如 dict，list，type，print，这些都位于 <strong>builtins</strong> 模块中，可以使用 dir(<strong>builtins</strong>) 来查看。这也是为什么我们在没有 import 任何模块的情况下，就能使用这么多丰富的函数和功能了。</p>\n<p>介绍完命名空间，就能理解 print(a) 这行代码输出的结果为什么是 a string 了。</p>\n<h3 id=\"内置属性-name\"><a href=\"#内置属性-name\" class=\"headerlink\" title=\"内置属性 name\"></a>内置属性 <strong>name</strong></h3><p>现在到了解释 if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘ 这行代码的时候了。当 Python 程序启动后，Python 会自动为每个模块设置一个属性 <strong>name</strong> 通常使用的是模块的名字，也就是文件名，但唯一的例外是主模块，主模块将会被设置为 <strong>main</strong> 。利用这一特性，就可以做一些特别的事。比如当该模块以主模块来运行的时候，可以运行测试用例。而当被其他模块 import 时，则只是乖乖的，提供函数和功能就好。</p>\n<h3 id=\"函数调用\"><a href=\"#函数调用\" class=\"headerlink\" title=\"函数调用\"></a>函数调用</h3><p>最后两行是函数调用，这里略去不讲。</p>\n<h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p>讲到最后，还有些内容需要再回顾和补充一下。</p>\n<h3 id=\"pyc-文件-1\"><a href=\"#pyc-文件-1\" class=\"headerlink\" title=\"pyc 文件\"></a>pyc 文件</h3><p>Python 只会对那些以后可能继续被使用和载入的模块才会生成 pyc 文件，Python 认为使用了 import 指令的模块，属于这种类型，因此会生成 pyc 文件。而对于只是临时用一次的模块，并不会生成 pyc 文件，Python 将主模块当成了这种类型的文件。这就解释了为什么 python demo.py 执行完后，只会生成一个 foo.pyc 文件。</p>\n<p>如果要问 pyc 文件什么时候生成，答案就是在执行了 import 指令之后，from xx import yy 同样属于 import 指令。</p>\n<h3 id=\"小整数对象池\"><a href=\"#小整数对象池\" class=\"headerlink\" title=\"小整数对象池\"></a>小整数对象池</h3><p>在 demo.py 这里例子中，所用的整数特意用了一个 257，这是为了介绍小整数对象池的。整数在程序中的使用非常广泛，Python 为了优化速度，使用了小整数对象池，避免为整数频繁申请和销毁内存空间。</p>\n<p>Python 对小整数的定义是 [-5, 257)，这些整数对象是提前建立好的，不会被垃圾回收。在一个 Python 的程序中，所有位于这个范围内的整数使用的都是同一个对象，从下面这个例子就可以看出。</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>a &#x3D; 1<br>id(a)<br>40059744<br>b &#x3D; 1<br>id(b)<br>40059744<br>c &#x3D; 257<br>id(c)<br>41069072<br>d &#x3D; 257<br>id(257)<br>41069096<br>id 函数可以用来查看一个对象的唯一标志，可以认为是内存地址</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>对于大整数，Python 使用的是一个 大整数对象池 。这句话的意思是：</p>\n<p>每当创建一个大整数的时候，都会新建一个对象，但是这个对象不再使用的时候，并不会销毁，后面再建立的对象会复用之前已经不再使用的对象的内存空间。（这里的不再使用指的是引用计数为0，可以被销毁）</p>\n<h3 id=\"字符串对象缓冲池\"><a href=\"#字符串对象缓冲池\" class=\"headerlink\" title=\"字符串对象缓冲池\"></a>字符串对象缓冲池</h3><p>如果仔细思考一下，一定会猜到字符串也采用了这种类似的技术，我们来看一下</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>a &#x3D; ‘a’<br>b &#x3D; ‘a’<br>id(a)<br>14660456<br>id(b)<br>14660456<br>没错，Python 的设计者为 一个字节 的字符对应的字符串对象 (PyStringObject) 也设计了这样一个对象池。同时还有一个 intern 机制，可以将内容相同的字符串变量转换成指向同一个字符串对象。</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>intern 机制的关键，就是在系统中有一个（key，value）映射关系的集合，集合的名称叫做 interned。在这个集合中，记录着被 intern 机制处理过的 PyStringObject 对象。不过 Python 始终会为字符串创建 PyStringObject 对象，即便在interned 中已经有一个与之对应的 PyStringObject 对象了，而 intern 机制是在字符串被创建后才起作用。</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>a &#x3D; ‘a string’<br>b &#x3D; ‘a string’<br>a is b<br>False<br>a &#x3D; intern(‘a string’) # 手动调用 intern 方法<br>b &#x3D; intern(‘a string’)<br>a is b<br>True<br>关于 intern 函数 可以参考 官方文档 ，更多扩展阅读：</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><a href=\"http://stackoverflow.com/questions/15541404/python-string-interning\">http://stackoverflow.com/questions/15541404/python-string-interning</a></p>\n<p>值得说明的是，数值类型和字符串类型在 Python 中都是不可变的，这意味着你无法修改这个对象的值，每次对变量的修改，实际上是创建一个新的对象。得益于这样的设计，才能使用对象缓冲池这种优化。</p>\n<p>Python 的实现上大量采用了这种内存对象池的技术，不仅仅对于这些特定的对象，还有专门的内存池用于小对象，使用这种技术可以避免频繁地申请和释放内存空间，目的就是让 Python 能稍微更快一点。更多内容可以参考 这里 。</p>\n<p>如果想了解更快的 Python，可以看看 PyPy</p>\n<h3 id=\"import-指令-1\"><a href=\"#import-指令-1\" class=\"headerlink\" title=\"import 指令\"></a>import 指令</h3><p>前文提到 import 指令是用来载入 module 的，如果需要，也会顺道做编译的事。但 import 指令，还会做一件重要的事情就是把 import 的那个 module 的代码执行一遍， 这件事情很重要 。Python 是解释执行的，连函数都是执行的时候才创建的。如果不把那个 module 的代码执行一遍，那么 module 里面的函数都没法创建，更别提去调用这些函数了。</p>\n<p>执行代码的另外一个重要作用，就是在这个 module 的命名空间中，创建模块内定义的函数和各种对象的符号名称（也就是变量名），并将其绑定到对象上，这样其他 module 才能通过变量名来引用这些对象。</p>\n<p>Python 虚拟机还会将已经 import 过的 module 缓存起来，放到一个全局 module 集合 sys.modules 中。这样做有一个好处，即如果程序的在另一个地方再次 import 这个模块，Python 虚拟机只需要将全局 module 集合中缓存的那个 module 对象返回即可。</p>\n<p>你现在一定想到了 sys.modules 是一个 dict 对象，可以通过 type(sys.modules) 来验证</p>\n<h3 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h3><p>demo.py 这个例子并没有用到多线程，但还是有必要提一下。</p>\n<p>在提到多线程的时候，往往要关注线程如何同步，如何访问共享资源。Python 是通过一个全局解释器锁 GIL（Global Interpreter Lock）来实现线程同步的。当 Python 程序只有单线程时，并不会启用 GIL，而当用户创建了一个 thread 时，表示要使用多线程，Python 解释器就会自动激活 GIL，并创建所需要的上下文环境和数据结构。</p>\n<p>Python 字节码解释器的工作原理是按照指令的顺序一条一条地顺序执行，Python 内部维护着一个数值，这个数值就是 Python 内部的时钟，如果这个数值为 N，则意味着 Python 在执行了 N 条指令以后应该立即启动线程调度机制，可以通过下面的代码获取这个数值。</p>\n<p>import sys<br>sys.getcheckinterval() # 100<br>线程调度机制将会为线程分配 GIL，获取到 GIL 的线程就能开始执行，而其他线程则必须等待。由于 GIL 的存在，Python 的多线程性能十分低下，无法发挥多核 CPU 的优势，性能甚至不如单线程。因此如果你想用到多核 CPU，一个建议是使用 多进程 。</p>\n<h3 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h3><p>在讲到垃圾回收的时候，通常会使用引用计数的模型，这是一种最直观，最简单的垃圾收集技术。Python 同样也使用了引用计数，但是引用计数存在这些缺点：</p>\n<p>频繁更新引用计数会降低运行效率<br>引用计数无法解决循环引用问题<br>Python 在 引用计数机制 的基础上，使用了主流垃圾收集技术中的 标记——清除 和 分代收集 两种技术。</p>\n<p>关于垃圾回收，可以参考</p>\n<p><a href=\"http://hbprotoss.github.io/posts/pythonla-ji-hui-shou-ji-zhi.html\">http://hbprotoss.github.io/posts/pythonla-ji-hui-shou-ji-zhi.html</a></p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>《Python源码分析》</p>\n","site":{"data":{}},"wordcount":8116,"excerpt":"","more":"<h2 id=\"简单的例子\"><a href=\"#简单的例子\" class=\"headerlink\" title=\"简单的例子\"></a>简单的例子</h2><p>先从一个简单的例子说起，包含了两个文件 foo.py 和 demo.py</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">[foo.py]<br>def add(a, b):<br>    <span class=\"hljs-built_in\">return</span> a + b<br>[demo.py]<br>import foo<br>a = [1, <span class=\"hljs-string\">&#x27;python&#x27;</span>]<br>a = <span class=\"hljs-string\">&#x27;a string&#x27;</span><br>def func():<br>\ta = 1<br>\tb = 257<br>\t<span class=\"hljs-built_in\">print</span>(a + b)<br><span class=\"hljs-built_in\">print</span>(a)<br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&#x27;__main__&#x27;</span>:<br>\tfunc()<br>\tfoo.add(1, 2)<br></code></pre></td></tr></table></figure>\n<p>执行这个程序</p>\n<p>python demo.py<br>输出结果</p>\n<p>a string<br>258<br>同时，该文件目录多出一个 foo.pyc 文件</p>\n<h2 id=\"背后的魔法\"><a href=\"#背后的魔法\" class=\"headerlink\" title=\"背后的魔法\"></a>背后的魔法</h2><p>看完程序的执行结果，接下来开始一行行解释代码。</p>\n<h3 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h3><p>Python 将 .py 文件视为一个 module，这些 module 中，有一个主 module，也就是程序运行的入口。在这个例子中，主 module 是 demo.py。</p>\n<h3 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h3><p>执行 python demo.py 后，将会启动 Python 的解释器，然后将 demo.py 编译成一个字节码对象 PyCodeObject。</p>\n<p>有的人可能会很好奇，编译的结果不应是 pyc 文件吗，就像 Java 的 class 文件，那为什么是一个对象呢，这里稍微解释一下。</p>\n<p>在 Python 的世界中，一切都是对象，函数也是对象，类型也是对象，类也是对象（类属于自定义的类型，在 Python ### 之前，int, dict 这些内置类型与类是存在不同的，在之后才统一起来，全部继承自 object），甚至连编译出来的字节码也是对象，.pyc 文件是字节码对象（PyCodeObject）在硬盘上的表现形式。</p>\n<p>在运行期间，编译结果也就是 PyCodeObject 对象，只会存在于内存中，而当这个模块的 Python 代码 执行完 后，就会将编译结果保存到了 pyc 文件中，这样下次就不用编译，直接加载到内存中。pyc 文件只是 PyCodeObject 对象在硬盘上的表现形式。</p>\n<p>这个 PyCodeObject 对象包含了 Python 源代码中的字符串，常量值，以及通过语法解析后编译生成的字节码指令。PyCodeObject 对象还会存储这些字节码指令与原始代码行号的对应关系，这样当出现异常时，就能指明位于哪一行的代码。</p>\n<h3 id=\"pyc-文件\"><a href=\"#pyc-文件\" class=\"headerlink\" title=\"pyc 文件\"></a>pyc 文件</h3><p>一个 pyc 文件包含了三部分信息：Python 的 magic number、pyc 文件创建的时间信息，以及 PyCodeObject 对象。</p>\n<p>magic number 是 Python 定义的一个整数值。一般来说，不同版本的 Python 实现都会定义不同的 magic number，这个值是用来保证 Python 兼容性的。比如要限制由低版本编译的 pyc 文件不能让高版本的 Python 程序来执行，只需要检查 magic number 不同就可以了。由于不同版本的 Python 定义的字节码指令可能会不同，如果不做检查，执行的时候就可能出错。</p>\n<p>下面所示的代码可以来创建 pyc 文件，使用方法</p>\n<p> python generate_pyc.py module_name<br>例如</p>\n<p> python generate_pyc.py demo<br>[generate_pyc.pyc]<br>import imp<br>import sys<br>def generate_pyc(name):<br>    fp, pathname, description &#x3D; imp.find_module(name)<br>    try:<br>        imp.load_module(name, fp, pathname, description)\t<br>    finally:<br>        if fp:<br>            fp.close()<br>if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘:<br>    generate_pyc(sys.argv[1])</p>\n<h3 id=\"字节码指令\"><a href=\"#字节码指令\" class=\"headerlink\" title=\"字节码指令\"></a>字节码指令</h3><p>为什么 pyc 文件也称作字节码文件？因为这些文件存储的都是一些二进制的字节数据，而不是能让人直观查看的文本数据。</p>\n<p>Python 标准库提供了用来生成代码对应字节码的工具 dis 。dis 提供一个名为 dis 的方法，这个方法接收一个 code 对象，然后会输出 code 对象里的字节码指令信息。</p>\n<p>s &#x3D; open(‘demo.py’).read()<br>co &#x3D; compile(s, ‘demo.py’, ‘exec’)<br>import dis<br>dis.dis(co)<br>执行上面这段代码可以输出 demo.py 编译后的字节码指令</p>\n<p>  1           0 LOAD_CONST\t   0 (-1)<br>     3 LOAD_CONST\t   1 (None)<br>     6 IMPORT_NAME\t  0 (foo)<br>     9 STORE_NAME\t   0 (foo)<br> 3          12 LOAD_CONST\t   2 (1)<br>    15 LOAD_CONST\t   3 (u’python’)<br>    18 BUILD_LIST\t   2<br>    21 STORE_NAME\t   1 (a)<br> 4          24 LOAD_CONST\t   4 (u’a string’)<br>    27 STORE_NAME\t   1 (a)<br> 6          30 LOAD_CONST\t   5 (&lt;code object func at 00D97650, file “demo.py”, line 6&gt;)<br>    33 MAKE_FUNCTION\t0<br>    36 STORE_NAME\t   2 (func)<br>11          39 LOAD_NAME\t    1 (a)<br>    42 PRINT_ITEM<br>    43 PRINT_NEWLINE<br>13          44 LOAD_NAME\t    3 (<strong>name</strong>)<br>    47 LOAD_CONST\t   6 (u’<strong>main</strong>‘)<br>    50 COMPARE_OP\t   2 (&#x3D;&#x3D;)<br>    53 POP_JUMP_IF_FALSE       82<br>14          56 LOAD_NAME\t    2 (func)<br>    59 CALL_FUNCTION\t0<br>    62 POP_TOP\t<br>15          63 LOAD_NAME\t    0 (foo)<br>    66 LOAD_ATTR\t    4 (add)<br>    69 LOAD_CONST\t   2 (1)<br>    72 LOAD_CONST\t   7 (2)<br>    75 CALL_FUNCTION\t2<br>    78 POP_TOP\t<br>    79 JUMP_FORWARD\t 0 (to 82)<br>       &gt;&gt;   82 LOAD_CONST\t   1 (None)<br>    85 RETURN_VALUE        </p>\n<h3 id=\"Python-虚拟机\"><a href=\"#Python-虚拟机\" class=\"headerlink\" title=\"Python 虚拟机\"></a>Python 虚拟机</h3><p>demo.py 被编译后，接下来的工作就交由 Python 虚拟机来执行字节码指令了。Python 虚拟机会从编译得到的 PyCodeObject 对象中依次读入每一条字节码指令，并在当前的 上下文环境 中执行这条字节码指令。我们的程序就是通过这样循环往复的过程才得以执行。</p>\n<h3 id=\"import-指令\"><a href=\"#import-指令\" class=\"headerlink\" title=\"import 指令\"></a>import 指令</h3><p>demo.py 的第一行代码是 import foo 。import 指令用来载入一个模块，另外一个载入模块的方法是 from xx import yy 。用 from 语句的好处是，可以只复制需要的符号变量到当前的命名空间中（关于命名空间将在后面介绍）。</p>\n<p>前文提到，当已经存在 pyc 文件时，就可以直接载入而省去编译过程。但是代码文件的内容会更新，如何保证更新后能重新编译而不入旧的 pyc 文件呢。答案就在 pyc 文件中存储的 创建时间信息 。当执行 import 指令的时候，如果已存在 pyc 文件，Python 会检查创建时间是否晚于代码文件的修改时间，这样就能判断是否需要重新编译，还是直接载入了。如果不存在 pyc 文件，就会先将 py 文件编译。</p>\n<h3 id=\"绝对引入和相对引入\"><a href=\"#绝对引入和相对引入\" class=\"headerlink\" title=\"绝对引入和相对引入\"></a>绝对引入和相对引入</h3><p>前文已经介绍了 import foo 这行代码。这里隐含了一个问题，就是 foo 是什么，如何找到 foo 。这就属于 Python 的模块引入规则，这里不展开介绍，可以参考 pep-0328 。</p>\n<h3 id=\"赋值语句\"><a href=\"#赋值语句\" class=\"headerlink\" title=\"赋值语句\"></a>赋值语句</h3><p>接下来，执行到 a &#x3D; [1, ‘python’] ，这是一条赋值语句，定义了一个变量 a，它对应的值是 [1, ‘python’]。这里要解释一下， 变量 是什么呢？</p>\n<p>按照 维基百科 的解释</p>\n<p>变量是一个存储位置和一个关联的符号名字，这个存储位置包含了一些已知或未知的量或者信息。</p>\n<p>变量实际上是一个字符串的符号，用来关联一个存储在内存中的对象。在 Python 中，会使用 dict（就是 Python 的 dict 对象）来存储变量符号（字符串）与一个对象的映射。</p>\n<p>那么赋值语句实际上就是用来建立这种关联，在这个例子中是将符号 a 与一个列表对象 [1, ‘python’] 建立映射。</p>\n<p>紧接着的代码执行了 a &#x3D; ‘a string’ ，这条指令则将符号 a 与另外一个字符串对象 a string 建立了映射。今后对变量 a 的操作，将反应到字符串对象 a string 上。</p>\n<h3 id=\"def-指令\"><a href=\"#def-指令\" class=\"headerlink\" title=\"def 指令\"></a>def 指令</h3><p>我们的 Python 代码继续往下运行，这里执行到一条 def func() ，从字节码指令中也可以看出端倪 MAKE_FUNCTION 。没错这条指令是用来创建函数的。Python 是动态语言，def 实际上是执行一条指令，用来创建函数（class 则是创建类的指令），而不仅仅是个语法关键字。函数并不是事先创建好的，而是执行到的时候才创建的。</p>\n<p>def func() 将会创建一个名称为 func 的函数对象。实际上是先创建一个函数对象，然后将 func 这个名称符号绑定到这个函数上。</p>\n<p>Python 中是无法实现 C 和 Java 中的重载的，因为重载要求函数名要相同，而参数的类型或数量不同，但是 Python 是通过变量符号（如这里的 func ）来关联一个函数，当我们用 def 语句再次创建一个同名的函数时，这个变量名就绑定到新的函数对象上了。</p>\n<h3 id=\"动态类型\"><a href=\"#动态类型\" class=\"headerlink\" title=\"动态类型\"></a>动态类型</h3><p>继续看函数 func 里面的代码，这时又有一条赋值语句 a &#x3D; 1 。变量 a 现在已经变成了第三种类型，它现在是一个整数了。那么 Python 是怎么实现动态类型的呢？答案就藏在具体存储的对象上。变量 a 仅仅只是一个符号（实际上是一个字符串对象），类型信息是存储在对象上的。在 Python 中，对象机制的核心是类型信息和引用计数（引用计数属于垃圾回收的部分）。</p>\n<p>用 type(a)，可以输出 a 的类型，这里是 int</p>\n<p>b &#x3D; 257 跳过，我们直接来看看 print(a + b) ，print 是输出函数，这里略过。这里想要探究的是 a + b 。</p>\n<p>因为 a 和 b 并不存储类型信息，因此当执行 a + b 的时候就必须先检查类型，比如 1 + 2 和 “1” + “2” 的结果是不一样的。</p>\n<p>看到这里，我们就可以想象一下执行一句简单的 a + b ，Python 虚拟机需要做多少繁琐的事情了。首先需要分别检查 a 和 b 所对应对象的类型，还要匹配类型是否一致（1 + “2” 将会出现异常），然后根据对象的类型调用正确的 + 函数（例如数值的 + 或字符串的 +），</p>\n<p>而 CPU 对于上面这条语句只需要执行 ADD 指令<br>（还需要先将变量 MOV 到寄存器）。</p>\n<h3 id=\"命名空间-namespace\"><a href=\"#命名空间-namespace\" class=\"headerlink\" title=\"命名空间 (namespace)\"></a>命名空间 (namespace)</h3><p>在介绍上面的这些代码时，还漏掉了一个关键的信息就是命名空间。在 Python 中，类、函数、module 都对应着一个独立的命名空间。而一个独立的命名空间会对应一个 PyCodeObject 对象，所以上面的 demo.py 文件编译后会生成两个 PyCodeObject，只是在 demo.py 这个 module 层的 PyCodeObject 中通过一个变量符号 func 嵌套了一个函数的 PyCodeObject。</p>\n<p>命名空间的意义，就是用来确定一个变量符号到底对应什么对象。命名空间可以一个套一个地形成一条命名空间链，Python 虚拟机在执行的过程中，会有很大一部分时间消耗在从这条命名空间链中确定一个符号所对应的对象是什么。</p>\n<p>在 Python中，命名空间是由一个 dict 对象实现的，它维护了（name，obj）这样的关联关系。</p>\n<p>说到这里，再补充一下 import foo 这行代码会在 demo.py 这个模块的命名空间中，创建一个新的变量名 foo ， foo 将绑定到一个 PyCodeObject 对象，也就是 foo.py 的编译结果。</p>\n<h4 id=\"dir-函数\"><a href=\"#dir-函数\" class=\"headerlink\" title=\"dir 函数\"></a>dir 函数</h4><p>Python 的 内置函数 dir 可以用来查看一个命名空间下的所有名字符号。一个用处是查看一个命名空间的所有属性和方法（这里的命名空间就是指类、函数、module）。</p>\n<p>比如，查看当前的命名空间，可以使用 dir()，查看 sys 模块，可以使用 dir(sys)。</p>\n<h4 id=\"LEGB-规则\"><a href=\"#LEGB-规则\" class=\"headerlink\" title=\"LEGB 规则\"></a>LEGB 规则</h4><p>Python 使用 LEGB 的顺序来查找一个符号对应的对象</p>\n<p>locals -&gt; enclosing function -&gt; globals -&gt; builtins</p>\n<p>locals，当前所在命名空间（如函数、模块），函数的参数也属于命名空间内的变量</p>\n<p>enclosing，外部嵌套函数的命名空间（闭包中常见）</p>\n<p>def fun1(a):<br>    def fun2():<br>        # a 位于外部嵌套函数的命名空间<br>        print(a)<br>globals，全局变量，函数定义所在模块的命名空间</p>\n<p>a &#x3D; 1<br>def fun():<br>    # 需要通过 global 指令来声明全局变量<br>    global a<br>    # 修改全局变量，而不是创建一个新的 local 变量<br>    a &#x3D; 2<br>builtins，内置模块的命名空间。Python 在启动的时候会自动为我们载入很多内置的函数、类，比如 dict，list，type，print，这些都位于 <strong>builtins</strong> 模块中，可以使用 dir(<strong>builtins</strong>) 来查看。这也是为什么我们在没有 import 任何模块的情况下，就能使用这么多丰富的函数和功能了。</p>\n<p>介绍完命名空间，就能理解 print(a) 这行代码输出的结果为什么是 a string 了。</p>\n<h3 id=\"内置属性-name\"><a href=\"#内置属性-name\" class=\"headerlink\" title=\"内置属性 name\"></a>内置属性 <strong>name</strong></h3><p>现在到了解释 if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘ 这行代码的时候了。当 Python 程序启动后，Python 会自动为每个模块设置一个属性 <strong>name</strong> 通常使用的是模块的名字，也就是文件名，但唯一的例外是主模块，主模块将会被设置为 <strong>main</strong> 。利用这一特性，就可以做一些特别的事。比如当该模块以主模块来运行的时候，可以运行测试用例。而当被其他模块 import 时，则只是乖乖的，提供函数和功能就好。</p>\n<h3 id=\"函数调用\"><a href=\"#函数调用\" class=\"headerlink\" title=\"函数调用\"></a>函数调用</h3><p>最后两行是函数调用，这里略去不讲。</p>\n<h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p>讲到最后，还有些内容需要再回顾和补充一下。</p>\n<h3 id=\"pyc-文件-1\"><a href=\"#pyc-文件-1\" class=\"headerlink\" title=\"pyc 文件\"></a>pyc 文件</h3><p>Python 只会对那些以后可能继续被使用和载入的模块才会生成 pyc 文件，Python 认为使用了 import 指令的模块，属于这种类型，因此会生成 pyc 文件。而对于只是临时用一次的模块，并不会生成 pyc 文件，Python 将主模块当成了这种类型的文件。这就解释了为什么 python demo.py 执行完后，只会生成一个 foo.pyc 文件。</p>\n<p>如果要问 pyc 文件什么时候生成，答案就是在执行了 import 指令之后，from xx import yy 同样属于 import 指令。</p>\n<h3 id=\"小整数对象池\"><a href=\"#小整数对象池\" class=\"headerlink\" title=\"小整数对象池\"></a>小整数对象池</h3><p>在 demo.py 这里例子中，所用的整数特意用了一个 257，这是为了介绍小整数对象池的。整数在程序中的使用非常广泛，Python 为了优化速度，使用了小整数对象池，避免为整数频繁申请和销毁内存空间。</p>\n<p>Python 对小整数的定义是 [-5, 257)，这些整数对象是提前建立好的，不会被垃圾回收。在一个 Python 的程序中，所有位于这个范围内的整数使用的都是同一个对象，从下面这个例子就可以看出。</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>a &#x3D; 1<br>id(a)<br>40059744<br>b &#x3D; 1<br>id(b)<br>40059744<br>c &#x3D; 257<br>id(c)<br>41069072<br>d &#x3D; 257<br>id(257)<br>41069096<br>id 函数可以用来查看一个对象的唯一标志，可以认为是内存地址</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>对于大整数，Python 使用的是一个 大整数对象池 。这句话的意思是：</p>\n<p>每当创建一个大整数的时候，都会新建一个对象，但是这个对象不再使用的时候，并不会销毁，后面再建立的对象会复用之前已经不再使用的对象的内存空间。（这里的不再使用指的是引用计数为0，可以被销毁）</p>\n<h3 id=\"字符串对象缓冲池\"><a href=\"#字符串对象缓冲池\" class=\"headerlink\" title=\"字符串对象缓冲池\"></a>字符串对象缓冲池</h3><p>如果仔细思考一下，一定会猜到字符串也采用了这种类似的技术，我们来看一下</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>a &#x3D; ‘a’<br>b &#x3D; ‘a’<br>id(a)<br>14660456<br>id(b)<br>14660456<br>没错，Python 的设计者为 一个字节 的字符对应的字符串对象 (PyStringObject) 也设计了这样一个对象池。同时还有一个 intern 机制，可以将内容相同的字符串变量转换成指向同一个字符串对象。</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>intern 机制的关键，就是在系统中有一个（key，value）映射关系的集合，集合的名称叫做 interned。在这个集合中，记录着被 intern 机制处理过的 PyStringObject 对象。不过 Python 始终会为字符串创建 PyStringObject 对象，即便在interned 中已经有一个与之对应的 PyStringObject 对象了，而 intern 机制是在字符串被创建后才起作用。</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>a &#x3D; ‘a string’<br>b &#x3D; ‘a string’<br>a is b<br>False<br>a &#x3D; intern(‘a string’) # 手动调用 intern 方法<br>b &#x3D; intern(‘a string’)<br>a is b<br>True<br>关于 intern 函数 可以参考 官方文档 ，更多扩展阅读：</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><a href=\"http://stackoverflow.com/questions/15541404/python-string-interning\">http://stackoverflow.com/questions/15541404/python-string-interning</a></p>\n<p>值得说明的是，数值类型和字符串类型在 Python 中都是不可变的，这意味着你无法修改这个对象的值，每次对变量的修改，实际上是创建一个新的对象。得益于这样的设计，才能使用对象缓冲池这种优化。</p>\n<p>Python 的实现上大量采用了这种内存对象池的技术，不仅仅对于这些特定的对象，还有专门的内存池用于小对象，使用这种技术可以避免频繁地申请和释放内存空间，目的就是让 Python 能稍微更快一点。更多内容可以参考 这里 。</p>\n<p>如果想了解更快的 Python，可以看看 PyPy</p>\n<h3 id=\"import-指令-1\"><a href=\"#import-指令-1\" class=\"headerlink\" title=\"import 指令\"></a>import 指令</h3><p>前文提到 import 指令是用来载入 module 的，如果需要，也会顺道做编译的事。但 import 指令，还会做一件重要的事情就是把 import 的那个 module 的代码执行一遍， 这件事情很重要 。Python 是解释执行的，连函数都是执行的时候才创建的。如果不把那个 module 的代码执行一遍，那么 module 里面的函数都没法创建，更别提去调用这些函数了。</p>\n<p>执行代码的另外一个重要作用，就是在这个 module 的命名空间中，创建模块内定义的函数和各种对象的符号名称（也就是变量名），并将其绑定到对象上，这样其他 module 才能通过变量名来引用这些对象。</p>\n<p>Python 虚拟机还会将已经 import 过的 module 缓存起来，放到一个全局 module 集合 sys.modules 中。这样做有一个好处，即如果程序的在另一个地方再次 import 这个模块，Python 虚拟机只需要将全局 module 集合中缓存的那个 module 对象返回即可。</p>\n<p>你现在一定想到了 sys.modules 是一个 dict 对象，可以通过 type(sys.modules) 来验证</p>\n<h3 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h3><p>demo.py 这个例子并没有用到多线程，但还是有必要提一下。</p>\n<p>在提到多线程的时候，往往要关注线程如何同步，如何访问共享资源。Python 是通过一个全局解释器锁 GIL（Global Interpreter Lock）来实现线程同步的。当 Python 程序只有单线程时，并不会启用 GIL，而当用户创建了一个 thread 时，表示要使用多线程，Python 解释器就会自动激活 GIL，并创建所需要的上下文环境和数据结构。</p>\n<p>Python 字节码解释器的工作原理是按照指令的顺序一条一条地顺序执行，Python 内部维护着一个数值，这个数值就是 Python 内部的时钟，如果这个数值为 N，则意味着 Python 在执行了 N 条指令以后应该立即启动线程调度机制，可以通过下面的代码获取这个数值。</p>\n<p>import sys<br>sys.getcheckinterval() # 100<br>线程调度机制将会为线程分配 GIL，获取到 GIL 的线程就能开始执行，而其他线程则必须等待。由于 GIL 的存在，Python 的多线程性能十分低下，无法发挥多核 CPU 的优势，性能甚至不如单线程。因此如果你想用到多核 CPU，一个建议是使用 多进程 。</p>\n<h3 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h3><p>在讲到垃圾回收的时候，通常会使用引用计数的模型，这是一种最直观，最简单的垃圾收集技术。Python 同样也使用了引用计数，但是引用计数存在这些缺点：</p>\n<p>频繁更新引用计数会降低运行效率<br>引用计数无法解决循环引用问题<br>Python 在 引用计数机制 的基础上，使用了主流垃圾收集技术中的 标记——清除 和 分代收集 两种技术。</p>\n<p>关于垃圾回收，可以参考</p>\n<p><a href=\"http://hbprotoss.github.io/posts/pythonla-ji-hui-shou-ji-zhi.html\">http://hbprotoss.github.io/posts/pythonla-ji-hui-shou-ji-zhi.html</a></p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>《Python源码分析》</p>\n"},{"title":"Tess of the D'Urbervilles","date":"2016-10-17T15:55:28.000Z","thumbnail":"http://i1.piimg.com/567571/9e316afc3febf6fd.jpg","_content":"今天看了一部好虐心的剧，今天也是好虐心的一天。。。不想说话，只想发图\n\n# Tess of the D'Urbervilles\n> 如果那日，我们曾跳过舞。我着白裙，你穿灰衣。芳草萋萋，日色温柔，初刻相逢的圣洁与纯真，我们必将幸福。必将幸福。\n\n> 将不会有泪水反复浸泡的忏悔与诅咒，将不会有命运交错压碾的痛苦与追悔，亦将不会有我与你，在巨石阵，乌鸦群下的诀别。\n\n[多图预警] 只想发图，不想说话\n![](http://i4.buimg.com/567571/9ad0752fbbfb491c.jpg)\n![](http://i1.piimg.com/567571/bf8f55715eab4649.jpg)\n![](http://i2.muimg.com/567571/5af8f99d4b093c45.jpg)\n![](http://i4.buimg.com/567571/b51bf903312c39d0.jpg)\n![](http://i1.piimg.com/567571/275e0c9b1964c7f7.jpg)\n\n***\n\nEverything is as it should be. \n\n\nIt couldnt have lasted, Angel.\n\n\nToo much happiness.\n\n\nIf we had danced that day, \nhow happy we might have be.\n\n","source":"_posts/Tess of the D'Urbervilles.md","raw":"---\ntitle: Tess of the D'Urbervilles\ndate: 2016-10-17 23:55:28\ntags:\ncategories: 自言语\nthumbnail: http://i1.piimg.com/567571/9e316afc3febf6fd.jpg\n---\n今天看了一部好虐心的剧，今天也是好虐心的一天。。。不想说话，只想发图\n\n# Tess of the D'Urbervilles\n> 如果那日，我们曾跳过舞。我着白裙，你穿灰衣。芳草萋萋，日色温柔，初刻相逢的圣洁与纯真，我们必将幸福。必将幸福。\n\n> 将不会有泪水反复浸泡的忏悔与诅咒，将不会有命运交错压碾的痛苦与追悔，亦将不会有我与你，在巨石阵，乌鸦群下的诀别。\n\n[多图预警] 只想发图，不想说话\n![](http://i4.buimg.com/567571/9ad0752fbbfb491c.jpg)\n![](http://i1.piimg.com/567571/bf8f55715eab4649.jpg)\n![](http://i2.muimg.com/567571/5af8f99d4b093c45.jpg)\n![](http://i4.buimg.com/567571/b51bf903312c39d0.jpg)\n![](http://i1.piimg.com/567571/275e0c9b1964c7f7.jpg)\n\n***\n\nEverything is as it should be. \n\n\nIt couldnt have lasted, Angel.\n\n\nToo much happiness.\n\n\nIf we had danced that day, \nhow happy we might have be.\n\n","slug":"Tess of the D'Urbervilles","published":1,"updated":"2021-12-12T14:25:37.897Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3bsl2ii000a5awq11xn4t5n","content":"<p>今天看了一部好虐心的剧，今天也是好虐心的一天。。。不想说话，只想发图</p>\n<h1 id=\"Tess-of-the-D’Urbervilles\"><a href=\"#Tess-of-the-D’Urbervilles\" class=\"headerlink\" title=\"Tess of the D’Urbervilles\"></a>Tess of the D’Urbervilles</h1><blockquote>\n<p>如果那日，我们曾跳过舞。我着白裙，你穿灰衣。芳草萋萋，日色温柔，初刻相逢的圣洁与纯真，我们必将幸福。必将幸福。</p>\n</blockquote>\n<blockquote>\n<p>将不会有泪水反复浸泡的忏悔与诅咒，将不会有命运交错压碾的痛苦与追悔，亦将不会有我与你，在巨石阵，乌鸦群下的诀别。</p>\n</blockquote>\n<p>[多图预警] 只想发图，不想说话<br><img src=\"http://i4.buimg.com/567571/9ad0752fbbfb491c.jpg\"><br><img src=\"http://i1.piimg.com/567571/bf8f55715eab4649.jpg\"><br><img src=\"http://i2.muimg.com/567571/5af8f99d4b093c45.jpg\"><br><img src=\"http://i4.buimg.com/567571/b51bf903312c39d0.jpg\"><br><img src=\"http://i1.piimg.com/567571/275e0c9b1964c7f7.jpg\"></p>\n<hr>\n<p>Everything is as it should be. </p>\n<p>It couldnt have lasted, Angel.</p>\n<p>Too much happiness.</p>\n<p>If we had danced that day,<br>how happy we might have be.</p>\n","site":{"data":{}},"wordcount":293,"excerpt":"","more":"<p>今天看了一部好虐心的剧，今天也是好虐心的一天。。。不想说话，只想发图</p>\n<h1 id=\"Tess-of-the-D’Urbervilles\"><a href=\"#Tess-of-the-D’Urbervilles\" class=\"headerlink\" title=\"Tess of the D’Urbervilles\"></a>Tess of the D’Urbervilles</h1><blockquote>\n<p>如果那日，我们曾跳过舞。我着白裙，你穿灰衣。芳草萋萋，日色温柔，初刻相逢的圣洁与纯真，我们必将幸福。必将幸福。</p>\n</blockquote>\n<blockquote>\n<p>将不会有泪水反复浸泡的忏悔与诅咒，将不会有命运交错压碾的痛苦与追悔，亦将不会有我与你，在巨石阵，乌鸦群下的诀别。</p>\n</blockquote>\n<p>[多图预警] 只想发图，不想说话<br><img src=\"http://i4.buimg.com/567571/9ad0752fbbfb491c.jpg\"><br><img src=\"http://i1.piimg.com/567571/bf8f55715eab4649.jpg\"><br><img src=\"http://i2.muimg.com/567571/5af8f99d4b093c45.jpg\"><br><img src=\"http://i4.buimg.com/567571/b51bf903312c39d0.jpg\"><br><img src=\"http://i1.piimg.com/567571/275e0c9b1964c7f7.jpg\"></p>\n<hr>\n<p>Everything is as it should be. </p>\n<p>It couldnt have lasted, Angel.</p>\n<p>Too much happiness.</p>\n<p>If we had danced that day,<br>how happy we might have be.</p>\n"},{"title":"UbuntuKylin13.10下安装配置Theano","date":"2016-04-16T10:30:22.000Z","thumbnail":null,"_content":"\n  今天在师兄的引领下开始学习基于Python的类库——Theano. 来自网上的一种说法是Theano基于表示矩阵向量的numpy和包含大量数学功能的scipy模块。对于数据的处理来说Python还是具有一定的优势。打算配置Theano时，因为官网的一句温馨提示（“除Linux64位机外，其他OS并不能很好用于测试”），才想起来打开那尘封已久的Kubuntu13.10。遂毅然决定在Ubuntu下安装配置Theano。\n\n     在刚配置Theano时，存在使用命令apt-get下载无源的情况。鉴于这种情况，个人给出建议无非三点：\n\n      一、切换软件源（国内好评的有网易的、搜狐的或者阿里的）或者换时间段安装；\n\n      二、连接的网络有问题或者无线网卡驱动升级；\n\n      三、系统版本已不受支持，要改为旧版本的源。\n\n\n     本人遇到情况是属于第三种，解决方法是无非两种：\n     一、升级系统到最新版本\n     二、重新配置旧版本的源：\n打开源列表    \n``` bash\n$ sudo gedit /etc/apt/sources.list\n``` \n把该配置文件内的所有http:// us.archive.ubuntu.com改为http:// old-releases.ubuntu.com\n执行sudo apt-get update 更新缓存。\n     下载完成后，如果安装失败，可能的情况是系统先前的安装软件的Python依赖库过于庞杂，因为配置前的环境较为恶劣，请安装Theano前务必清理干净。正常安装如下图所示：![image1](http://i4.buimg.com/567571/1782df22181a5fbf.png)\n``` bash\n$ sudo pip install --upgrade --no-deps theano \n``` \n![image2](http://i2.muimg.com/567571/82b8ed4f76e6d38c.png)\n安装完成后，测试配置是否正确：\n测试指令：\n``` bash\n$ python -c \"import numpy; numpy.test()\" \n$ python -c \"import scipy; scipy.test()\" \n$ python -c \"import theano; theano.test()\" \n``` \n\n","source":"_posts/UbuntuKylin13.10下安装配置Theano.md","raw":"---\ntitle: UbuntuKylin13.10下安装配置Theano\ndate: 2016-04-16 18:30:22\ntags:\ncategories: 技术向\nthumbnail: # http://i4.buimg.com/567571/6cf2c02911d0cda6.png\n---\n\n  今天在师兄的引领下开始学习基于Python的类库——Theano. 来自网上的一种说法是Theano基于表示矩阵向量的numpy和包含大量数学功能的scipy模块。对于数据的处理来说Python还是具有一定的优势。打算配置Theano时，因为官网的一句温馨提示（“除Linux64位机外，其他OS并不能很好用于测试”），才想起来打开那尘封已久的Kubuntu13.10。遂毅然决定在Ubuntu下安装配置Theano。\n\n     在刚配置Theano时，存在使用命令apt-get下载无源的情况。鉴于这种情况，个人给出建议无非三点：\n\n      一、切换软件源（国内好评的有网易的、搜狐的或者阿里的）或者换时间段安装；\n\n      二、连接的网络有问题或者无线网卡驱动升级；\n\n      三、系统版本已不受支持，要改为旧版本的源。\n\n\n     本人遇到情况是属于第三种，解决方法是无非两种：\n     一、升级系统到最新版本\n     二、重新配置旧版本的源：\n打开源列表    \n``` bash\n$ sudo gedit /etc/apt/sources.list\n``` \n把该配置文件内的所有http:// us.archive.ubuntu.com改为http:// old-releases.ubuntu.com\n执行sudo apt-get update 更新缓存。\n     下载完成后，如果安装失败，可能的情况是系统先前的安装软件的Python依赖库过于庞杂，因为配置前的环境较为恶劣，请安装Theano前务必清理干净。正常安装如下图所示：![image1](http://i4.buimg.com/567571/1782df22181a5fbf.png)\n``` bash\n$ sudo pip install --upgrade --no-deps theano \n``` \n![image2](http://i2.muimg.com/567571/82b8ed4f76e6d38c.png)\n安装完成后，测试配置是否正确：\n测试指令：\n``` bash\n$ python -c \"import numpy; numpy.test()\" \n$ python -c \"import scipy; scipy.test()\" \n$ python -c \"import theano; theano.test()\" \n``` \n\n","slug":"UbuntuKylin13.10下安装配置Theano","published":1,"updated":"2021-12-12T14:25:38.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3bsl2ij000b5awq21bf86ya","content":"<p>  今天在师兄的引领下开始学习基于Python的类库——Theano. 来自网上的一种说法是Theano基于表示矩阵向量的numpy和包含大量数学功能的scipy模块。对于数据的处理来说Python还是具有一定的优势。打算配置Theano时，因为官网的一句温馨提示（“除Linux64位机外，其他OS并不能很好用于测试”），才想起来打开那尘封已久的Kubuntu13.10。遂毅然决定在Ubuntu下安装配置Theano。</p>\n<pre><code> 在刚配置Theano时，存在使用命令apt-get下载无源的情况。鉴于这种情况，个人给出建议无非三点：\n\n  一、切换软件源（国内好评的有网易的、搜狐的或者阿里的）或者换时间段安装；\n\n  二、连接的网络有问题或者无线网卡驱动升级；\n\n  三、系统版本已不受支持，要改为旧版本的源。\n\n\n 本人遇到情况是属于第三种，解决方法是无非两种：\n 一、升级系统到最新版本\n 二、重新配置旧版本的源：\n</code></pre>\n<p>打开源列表    </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ sudo gedit /etc/apt/sources.list<br></code></pre></td></tr></table></figure>\n<p>把该配置文件内的所有http:&#x2F;&#x2F; us.archive.ubuntu.com改为http:&#x2F;&#x2F; old-releases.ubuntu.com<br>执行sudo apt-get update 更新缓存。<br>     下载完成后，如果安装失败，可能的情况是系统先前的安装软件的Python依赖库过于庞杂，因为配置前的环境较为恶劣，请安装Theano前务必清理干净。正常安装如下图所示：<img src=\"http://i4.buimg.com/567571/1782df22181a5fbf.png\" alt=\"image1\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ sudo pip install --upgrade --no-deps theano <br></code></pre></td></tr></table></figure>\n<p><img src=\"http://i2.muimg.com/567571/82b8ed4f76e6d38c.png\" alt=\"image2\"><br>安装完成后，测试配置是否正确：<br>测试指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ python -c <span class=\"hljs-string\">&quot;import numpy; numpy.test()&quot;</span> <br>$ python -c <span class=\"hljs-string\">&quot;import scipy; scipy.test()&quot;</span> <br>$ python -c <span class=\"hljs-string\">&quot;import theano; theano.test()&quot;</span> <br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"wordcount":817,"excerpt":"","more":"<p>  今天在师兄的引领下开始学习基于Python的类库——Theano. 来自网上的一种说法是Theano基于表示矩阵向量的numpy和包含大量数学功能的scipy模块。对于数据的处理来说Python还是具有一定的优势。打算配置Theano时，因为官网的一句温馨提示（“除Linux64位机外，其他OS并不能很好用于测试”），才想起来打开那尘封已久的Kubuntu13.10。遂毅然决定在Ubuntu下安装配置Theano。</p>\n<pre><code> 在刚配置Theano时，存在使用命令apt-get下载无源的情况。鉴于这种情况，个人给出建议无非三点：\n\n  一、切换软件源（国内好评的有网易的、搜狐的或者阿里的）或者换时间段安装；\n\n  二、连接的网络有问题或者无线网卡驱动升级；\n\n  三、系统版本已不受支持，要改为旧版本的源。\n\n\n 本人遇到情况是属于第三种，解决方法是无非两种：\n 一、升级系统到最新版本\n 二、重新配置旧版本的源：\n</code></pre>\n<p>打开源列表    </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ sudo gedit /etc/apt/sources.list<br></code></pre></td></tr></table></figure>\n<p>把该配置文件内的所有http:&#x2F;&#x2F; us.archive.ubuntu.com改为http:&#x2F;&#x2F; old-releases.ubuntu.com<br>执行sudo apt-get update 更新缓存。<br>     下载完成后，如果安装失败，可能的情况是系统先前的安装软件的Python依赖库过于庞杂，因为配置前的环境较为恶劣，请安装Theano前务必清理干净。正常安装如下图所示：<img src=\"http://i4.buimg.com/567571/1782df22181a5fbf.png\" alt=\"image1\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ sudo pip install --upgrade --no-deps theano <br></code></pre></td></tr></table></figure>\n<p><img src=\"http://i2.muimg.com/567571/82b8ed4f76e6d38c.png\" alt=\"image2\"><br>安装完成后，测试配置是否正确：<br>测试指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ python -c <span class=\"hljs-string\">&quot;import numpy; numpy.test()&quot;</span> <br>$ python -c <span class=\"hljs-string\">&quot;import scipy; scipy.test()&quot;</span> <br>$ python -c <span class=\"hljs-string\">&quot;import theano; theano.test()&quot;</span> <br></code></pre></td></tr></table></figure>\n\n"},{"title":"基于马尔可夫链的语义推导算法","date":"2021-12-12T15:25:13.000Z","thumbnail":null,"_content":"\n","source":"_posts/基于马尔可夫链的语义推导算法.md","raw":"---\ntitle: 基于马尔可夫链的语义推导算法\ndate: 2021-12-12 23:25:13\ntags:\ncategories: 技术向\nthumbnail: # http://i2.muimg.com/567571/8a8c33b8e8f2438c.png\n---\n\n","slug":"基于马尔可夫链的语义推导算法","published":1,"updated":"2021-12-12T15:43:01.475Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3bsl2im000e5awq5ew10asi","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""},{"title":"多轮对话交互系统文本预处理模块之基于条件随机场判断对话文本是否有下文","date":"2021-12-30T15:25:13.000Z","_content":"\n条件随机场（conditional random field，CRF）是给定一组是给定一组输入随机变量条件下另一组输出随机变量的条件概率分布模型。条件随机场可以用于不同的预测问题，由输入序列对输出序列预测的判别模型，形式为对数线性模型，其学习方法通常是极大似然估计或正则化的极大似然估计。\n\n条件随机场的3个基本问题：概率计算问题、学习问题和预测问题。\n\n\n## 1、CRF是啥（原理简释）\n### 1.1 计算处理过程\n\n### 1.2 I/O\n\n\n## 2、CRF能干啥（应用场景）\n##\n\n\n## 3、CRF用于NLU中识别客户开始说话的文本是否还存在下文\n### 3.1、优点：\n\n### 3.2、缺点：\n\n\n[1]李航.统计学习方法（第二版）[M].北京：清华大学出版社，2019\n","source":"_posts/多轮对话交互系统文本预处理模块之基于条件随机场判断文本是否有下文.md","raw":"---\ntitle: 多轮对话交互系统文本预处理模块之基于条件随机场判断对话文本是否有下文\ndate: 2021-12-30 23:25:13\ntags:\ncategories: 技术向\n---\n\n条件随机场（conditional random field，CRF）是给定一组是给定一组输入随机变量条件下另一组输出随机变量的条件概率分布模型。条件随机场可以用于不同的预测问题，由输入序列对输出序列预测的判别模型，形式为对数线性模型，其学习方法通常是极大似然估计或正则化的极大似然估计。\n\n条件随机场的3个基本问题：概率计算问题、学习问题和预测问题。\n\n\n## 1、CRF是啥（原理简释）\n### 1.1 计算处理过程\n\n### 1.2 I/O\n\n\n## 2、CRF能干啥（应用场景）\n##\n\n\n## 3、CRF用于NLU中识别客户开始说话的文本是否还存在下文\n### 3.1、优点：\n\n### 3.2、缺点：\n\n\n[1]李航.统计学习方法（第二版）[M].北京：清华大学出版社，2019\n","slug":"多轮对话交互系统文本预处理模块之基于条件随机场判断文本是否有下文","published":1,"updated":"2021-12-30T17:23:39.535Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3bsl2in000f5awqdrwu6hmj","content":"<p>条件随机场（conditional random field，CRF）是给定一组是给定一组输入随机变量条件下另一组输出随机变量的条件概率分布模型。条件随机场可以用于不同的预测问题，由输入序列对输出序列预测的判别模型，形式为对数线性模型，其学习方法通常是极大似然估计或正则化的极大似然估计。</p>\n<p>条件随机场的3个基本问题：概率计算问题、学习问题和预测问题。</p>\n<h2 id=\"1、CRF是啥（原理简释）\"><a href=\"#1、CRF是啥（原理简释）\" class=\"headerlink\" title=\"1、CRF是啥（原理简释）\"></a>1、CRF是啥（原理简释）</h2><h3 id=\"1-1-计算处理过程\"><a href=\"#1-1-计算处理过程\" class=\"headerlink\" title=\"1.1 计算处理过程\"></a>1.1 计算处理过程</h3><h3 id=\"1-2-I-x2F-O\"><a href=\"#1-2-I-x2F-O\" class=\"headerlink\" title=\"1.2 I&#x2F;O\"></a>1.2 I&#x2F;O</h3><h2 id=\"2、CRF能干啥（应用场景）\"><a href=\"#2、CRF能干啥（应用场景）\" class=\"headerlink\" title=\"2、CRF能干啥（应用场景）\"></a>2、CRF能干啥（应用场景）</h2><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h2 id=\"3、CRF用于NLU中识别客户开始说话的文本是否还存在下文\"><a href=\"#3、CRF用于NLU中识别客户开始说话的文本是否还存在下文\" class=\"headerlink\" title=\"3、CRF用于NLU中识别客户开始说话的文本是否还存在下文\"></a>3、CRF用于NLU中识别客户开始说话的文本是否还存在下文</h2><h3 id=\"3-1、优点：\"><a href=\"#3-1、优点：\" class=\"headerlink\" title=\"3.1、优点：\"></a>3.1、优点：</h3><h3 id=\"3-2、缺点：\"><a href=\"#3-2、缺点：\" class=\"headerlink\" title=\"3.2、缺点：\"></a>3.2、缺点：</h3><p>[1]李航.统计学习方法（第二版）[M].北京：清华大学出版社，2019</p>\n","site":{"data":{}},"wordcount":298,"excerpt":"","more":"<p>条件随机场（conditional random field，CRF）是给定一组是给定一组输入随机变量条件下另一组输出随机变量的条件概率分布模型。条件随机场可以用于不同的预测问题，由输入序列对输出序列预测的判别模型，形式为对数线性模型，其学习方法通常是极大似然估计或正则化的极大似然估计。</p>\n<p>条件随机场的3个基本问题：概率计算问题、学习问题和预测问题。</p>\n<h2 id=\"1、CRF是啥（原理简释）\"><a href=\"#1、CRF是啥（原理简释）\" class=\"headerlink\" title=\"1、CRF是啥（原理简释）\"></a>1、CRF是啥（原理简释）</h2><h3 id=\"1-1-计算处理过程\"><a href=\"#1-1-计算处理过程\" class=\"headerlink\" title=\"1.1 计算处理过程\"></a>1.1 计算处理过程</h3><h3 id=\"1-2-I-x2F-O\"><a href=\"#1-2-I-x2F-O\" class=\"headerlink\" title=\"1.2 I&#x2F;O\"></a>1.2 I&#x2F;O</h3><h2 id=\"2、CRF能干啥（应用场景）\"><a href=\"#2、CRF能干啥（应用场景）\" class=\"headerlink\" title=\"2、CRF能干啥（应用场景）\"></a>2、CRF能干啥（应用场景）</h2><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h2 id=\"3、CRF用于NLU中识别客户开始说话的文本是否还存在下文\"><a href=\"#3、CRF用于NLU中识别客户开始说话的文本是否还存在下文\" class=\"headerlink\" title=\"3、CRF用于NLU中识别客户开始说话的文本是否还存在下文\"></a>3、CRF用于NLU中识别客户开始说话的文本是否还存在下文</h2><h3 id=\"3-1、优点：\"><a href=\"#3-1、优点：\" class=\"headerlink\" title=\"3.1、优点：\"></a>3.1、优点：</h3><h3 id=\"3-2、缺点：\"><a href=\"#3-2、缺点：\" class=\"headerlink\" title=\"3.2、缺点：\"></a>3.2、缺点：</h3><p>[1]李航.统计学习方法（第二版）[M].北京：清华大学出版社，2019</p>\n"},{"title":"数学建模之预测模型总结","date":"2016-03-13T15:55:47.000Z","thumbnail":null,"_content":"\n基于数学建模的预测方法种类繁多，从经典的单耗法、弹性系数法、统计分析法，到目前的灰色预测法。当在使用相应的预测方法建立预测模型时，我们需要知道主要的一些预测方法的研究特点，优缺点和适用范围。下面就当下一些主要的预测方法进行总结：\n\n![](http://i1.piimg.com/567571/43c34cca95626317.png)\n","source":"_posts/数学建模之预测模型总结.md","raw":"---\ntitle: 数学建模之预测模型总结\ndate: 2016-03-13 23:55:47\ncategories: 事件簿\nthumbnail: # http://i2.muimg.com/567571/66a196ad0fabb62e.png\n---\n\n基于数学建模的预测方法种类繁多，从经典的单耗法、弹性系数法、统计分析法，到目前的灰色预测法。当在使用相应的预测方法建立预测模型时，我们需要知道主要的一些预测方法的研究特点，优缺点和适用范围。下面就当下一些主要的预测方法进行总结：\n\n![](http://i1.piimg.com/567571/43c34cca95626317.png)\n","slug":"数学建模之预测模型总结","published":1,"updated":"2021-12-12T14:25:36.965Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3bsl2ip000i5awq0od22zyn","content":"<p>基于数学建模的预测方法种类繁多，从经典的单耗法、弹性系数法、统计分析法，到目前的灰色预测法。当在使用相应的预测方法建立预测模型时，我们需要知道主要的一些预测方法的研究特点，优缺点和适用范围。下面就当下一些主要的预测方法进行总结：</p>\n<p><img src=\"http://i1.piimg.com/567571/43c34cca95626317.png\"></p>\n","site":{"data":{}},"wordcount":114,"excerpt":"","more":"<p>基于数学建模的预测方法种类繁多，从经典的单耗法、弹性系数法、统计分析法，到目前的灰色预测法。当在使用相应的预测方法建立预测模型时，我们需要知道主要的一些预测方法的研究特点，优缺点和适用范围。下面就当下一些主要的预测方法进行总结：</p>\n<p><img src=\"http://i1.piimg.com/567571/43c34cca95626317.png\"></p>\n"},{"title":"看南飞的孤雁，过境处依旧是聚散人间","date":"2016-05-27T17:30:05.000Z","thumbnail":null,"_content":"\n“时间是个贪婪的赌徒，从不作弊，每赌必赢” ————波德莱尔《时钟》\n\n明天就要收拾行李离开寝室，离开师大，离开这座城市了。此去经年，往事如烟。铭记每一天，想念一些人，也深爱这土地。此番一别，重聚是缘。\n\n## 封缄过往\n四年时间，既长又短。新生入学第一天的场景还历历在目，而如今已物是人非。依稀记得我当时去学院指定地点报到，迎新的是一个大二的学姐，好像是甘肃的吧，第一次接触北方人，但感觉她和蔼可亲的样子冲淡了我对北方人氏粗狂豪迈的人设。她告诉我关于大学生活的一些注意事项，担心我不熟悉路，还送我到了寝室拿好了钥匙，真是细心学姐一枚，哈哈～ 刚来学校觉得学校好大，然后读着读着就小了，在这临别之际，感觉校园似乎又变大了，大得可以装下每一届毕业生的离愁别绪。\n大一新生入学，就是军训啦，外加各种社团招新。感觉当时的自己图个热闹，也忙得不亦乐乎。总之大一整学年过得还称心如意。不得不提的就是我们学校的一个可爱又烦人的传统，每年毕业季的时候，毕业生们就会成群结队在每栋异性宿舍楼下唱几首歌，有时还深更半夜在校园里呐喊“我！们！毕！业！啦！”，不知道是无处发泄为数不多的青春，还是得通过嘶吼来缓解离愁别绪。大一我对这种现象的态度是不解，到了大二感觉是烦人，大三觉得也还能接收，而如今大四已经毕业时，才蓦然觉得感同身受。。。不过那一年毕业时那个学姐一个人拿着音响对整个6栋唱了一个多小时的歌情景，真令人记忆犹新吖，真的，有些事情不做，可能一辈子都不会做了吧。\n大二以后我就开始喜欢上了旅行，和同学一起的，自己一个人去的，反正只要走着就很好。读万卷书，行万里路吧。去过好些地方，但令我向往的还是那些没去过的地方［捂脸～］\n大三准备找实习，东瞅瞅，西碰碰，最后大四准备考研了［再次捂脸～］虽然高考完了填志愿时就打算了读完大学考研。备考这一年也不知道怎么熬过来的，寝室那仨都直接跑去实习就业了，所以寝室就我一个人，虽说和此时此景迷之相似，但我知道后会有期，而如今呢，聚散随缘，天各一方。毕业酒会上，大家也都把酒言欢，可醉过之后呢，都依依不舍和浓浓的离愁别绪。毕业照拍摄，天公也不作美，大雨倾盆，这天气真是比人还多愁善感。。。\n初来南昌，我对这个城市不痛不痒，但感觉交通秩序是真差。。。但时至今日，临别在即，却也依依不舍。似乎除了故乡，我只拍过此地的月亮。也许我还没有看透世态炎凉，人事易分，但我真的看够了月圆月缺，烟花易冷。记得读过这样一句话“一个人成年以后。得做好失去的准备。”得之坦然，失之淡然，争是必然，顺其自然吧。\n![](http://i1.piimg.com/567571/601989ceade3dd16.jpg)\n\n## 书写当下\n“谁校对时间，谁就会忽然变老”。\n寝室四个我是最后一个走的，倒不是不想提前走，只是我这人喜欢送别人，不喜欢别人送我［无解～］最开始告别了林仔，然后送走i橙和聪哥，最后看着空空荡荡的房间，忽然就放了苏打绿的那首歌《我好想你》“开了灯眼前的模样，偌大的放。。。”呃，其实寝室很小啦。\n今天我原本打算去小杏岭情人坡埋一个时间囊的，但是奈何学校的草地土质太硬了［衰～］，根本挖不动吖，更别说挖个洞了。也许是许久没有下雨的缘故吧，我只好把它沉到了静湖里(°_°)… 反正以后也一不定能找见不是嘛，就当搁个不求打捞的思念吧，让它替我的回忆留守此地。今天下午我又去重新坐了一下南昌市地铁1号线，从瑶湖师大到老师大的距离就是我们之间的距离吧。\n明天去火车站的我打算让的士司机再绕一绕这座城市，看看奥体中心，艾溪湖，艾溪桥，老师大，八一广场，老福山，坛子口。。。\n因为我知道，此去一别，相逢随缘啦。\n![](http://i1.piimg.com/567571/37655a2af55e22ea.jpg)\n\n## 遥寄未来\n哎。。。生而为人，生来孤独。人这一生什么也留不住，只能同那千变万化的瞬间起舞。不觉窗外已更深雾重，然后自己在这碎碎念，也不知道都写了些啥，反正想到什么就写下什么，这不正如记忆的零碎嘛。好了啦，明天还要早起收拾些东西，打扫下寝室，就早点休息吧，晚安啦，自己。晚安啦，此地。\n谨以此文寄给未来的自己，希望未来的你过得比从前每一天都好。天天开心，事事顺心！\n“重逢处飞鸟起落，不是往日你我”\n![](http://i2.muimg.com/567571/e4c674e70b46ed15.jpg)\n\n丙申年 夏\n于南昌\n","source":"_posts/看南飞的孤雁，过境处依旧是聚散人间.md","raw":"---\ntitle: 看南飞的孤雁，过境处依旧是聚散人间\ndate: 2016-05-28 01:30:05\ntags:\ncategories: 自言语\nthumbnail: # http://i4.buimg.com/567571/20025748305ee8fe.jpg\n---\n\n“时间是个贪婪的赌徒，从不作弊，每赌必赢” ————波德莱尔《时钟》\n\n明天就要收拾行李离开寝室，离开师大，离开这座城市了。此去经年，往事如烟。铭记每一天，想念一些人，也深爱这土地。此番一别，重聚是缘。\n\n## 封缄过往\n四年时间，既长又短。新生入学第一天的场景还历历在目，而如今已物是人非。依稀记得我当时去学院指定地点报到，迎新的是一个大二的学姐，好像是甘肃的吧，第一次接触北方人，但感觉她和蔼可亲的样子冲淡了我对北方人氏粗狂豪迈的人设。她告诉我关于大学生活的一些注意事项，担心我不熟悉路，还送我到了寝室拿好了钥匙，真是细心学姐一枚，哈哈～ 刚来学校觉得学校好大，然后读着读着就小了，在这临别之际，感觉校园似乎又变大了，大得可以装下每一届毕业生的离愁别绪。\n大一新生入学，就是军训啦，外加各种社团招新。感觉当时的自己图个热闹，也忙得不亦乐乎。总之大一整学年过得还称心如意。不得不提的就是我们学校的一个可爱又烦人的传统，每年毕业季的时候，毕业生们就会成群结队在每栋异性宿舍楼下唱几首歌，有时还深更半夜在校园里呐喊“我！们！毕！业！啦！”，不知道是无处发泄为数不多的青春，还是得通过嘶吼来缓解离愁别绪。大一我对这种现象的态度是不解，到了大二感觉是烦人，大三觉得也还能接收，而如今大四已经毕业时，才蓦然觉得感同身受。。。不过那一年毕业时那个学姐一个人拿着音响对整个6栋唱了一个多小时的歌情景，真令人记忆犹新吖，真的，有些事情不做，可能一辈子都不会做了吧。\n大二以后我就开始喜欢上了旅行，和同学一起的，自己一个人去的，反正只要走着就很好。读万卷书，行万里路吧。去过好些地方，但令我向往的还是那些没去过的地方［捂脸～］\n大三准备找实习，东瞅瞅，西碰碰，最后大四准备考研了［再次捂脸～］虽然高考完了填志愿时就打算了读完大学考研。备考这一年也不知道怎么熬过来的，寝室那仨都直接跑去实习就业了，所以寝室就我一个人，虽说和此时此景迷之相似，但我知道后会有期，而如今呢，聚散随缘，天各一方。毕业酒会上，大家也都把酒言欢，可醉过之后呢，都依依不舍和浓浓的离愁别绪。毕业照拍摄，天公也不作美，大雨倾盆，这天气真是比人还多愁善感。。。\n初来南昌，我对这个城市不痛不痒，但感觉交通秩序是真差。。。但时至今日，临别在即，却也依依不舍。似乎除了故乡，我只拍过此地的月亮。也许我还没有看透世态炎凉，人事易分，但我真的看够了月圆月缺，烟花易冷。记得读过这样一句话“一个人成年以后。得做好失去的准备。”得之坦然，失之淡然，争是必然，顺其自然吧。\n![](http://i1.piimg.com/567571/601989ceade3dd16.jpg)\n\n## 书写当下\n“谁校对时间，谁就会忽然变老”。\n寝室四个我是最后一个走的，倒不是不想提前走，只是我这人喜欢送别人，不喜欢别人送我［无解～］最开始告别了林仔，然后送走i橙和聪哥，最后看着空空荡荡的房间，忽然就放了苏打绿的那首歌《我好想你》“开了灯眼前的模样，偌大的放。。。”呃，其实寝室很小啦。\n今天我原本打算去小杏岭情人坡埋一个时间囊的，但是奈何学校的草地土质太硬了［衰～］，根本挖不动吖，更别说挖个洞了。也许是许久没有下雨的缘故吧，我只好把它沉到了静湖里(°_°)… 反正以后也一不定能找见不是嘛，就当搁个不求打捞的思念吧，让它替我的回忆留守此地。今天下午我又去重新坐了一下南昌市地铁1号线，从瑶湖师大到老师大的距离就是我们之间的距离吧。\n明天去火车站的我打算让的士司机再绕一绕这座城市，看看奥体中心，艾溪湖，艾溪桥，老师大，八一广场，老福山，坛子口。。。\n因为我知道，此去一别，相逢随缘啦。\n![](http://i1.piimg.com/567571/37655a2af55e22ea.jpg)\n\n## 遥寄未来\n哎。。。生而为人，生来孤独。人这一生什么也留不住，只能同那千变万化的瞬间起舞。不觉窗外已更深雾重，然后自己在这碎碎念，也不知道都写了些啥，反正想到什么就写下什么，这不正如记忆的零碎嘛。好了啦，明天还要早起收拾些东西，打扫下寝室，就早点休息吧，晚安啦，自己。晚安啦，此地。\n谨以此文寄给未来的自己，希望未来的你过得比从前每一天都好。天天开心，事事顺心！\n“重逢处飞鸟起落，不是往日你我”\n![](http://i2.muimg.com/567571/e4c674e70b46ed15.jpg)\n\n丙申年 夏\n于南昌\n","slug":"看南飞的孤雁，过境处依旧是聚散人间","published":1,"updated":"2021-12-12T14:25:36.861Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3bsl2ir000k5awq2cm7gry7","content":"<p>“时间是个贪婪的赌徒，从不作弊，每赌必赢” ————波德莱尔《时钟》</p>\n<p>明天就要收拾行李离开寝室，离开师大，离开这座城市了。此去经年，往事如烟。铭记每一天，想念一些人，也深爱这土地。此番一别，重聚是缘。</p>\n<h2 id=\"封缄过往\"><a href=\"#封缄过往\" class=\"headerlink\" title=\"封缄过往\"></a>封缄过往</h2><p>四年时间，既长又短。新生入学第一天的场景还历历在目，而如今已物是人非。依稀记得我当时去学院指定地点报到，迎新的是一个大二的学姐，好像是甘肃的吧，第一次接触北方人，但感觉她和蔼可亲的样子冲淡了我对北方人氏粗狂豪迈的人设。她告诉我关于大学生活的一些注意事项，担心我不熟悉路，还送我到了寝室拿好了钥匙，真是细心学姐一枚，哈哈～ 刚来学校觉得学校好大，然后读着读着就小了，在这临别之际，感觉校园似乎又变大了，大得可以装下每一届毕业生的离愁别绪。<br>大一新生入学，就是军训啦，外加各种社团招新。感觉当时的自己图个热闹，也忙得不亦乐乎。总之大一整学年过得还称心如意。不得不提的就是我们学校的一个可爱又烦人的传统，每年毕业季的时候，毕业生们就会成群结队在每栋异性宿舍楼下唱几首歌，有时还深更半夜在校园里呐喊“我！们！毕！业！啦！”，不知道是无处发泄为数不多的青春，还是得通过嘶吼来缓解离愁别绪。大一我对这种现象的态度是不解，到了大二感觉是烦人，大三觉得也还能接收，而如今大四已经毕业时，才蓦然觉得感同身受。。。不过那一年毕业时那个学姐一个人拿着音响对整个6栋唱了一个多小时的歌情景，真令人记忆犹新吖，真的，有些事情不做，可能一辈子都不会做了吧。<br>大二以后我就开始喜欢上了旅行，和同学一起的，自己一个人去的，反正只要走着就很好。读万卷书，行万里路吧。去过好些地方，但令我向往的还是那些没去过的地方［捂脸～］<br>大三准备找实习，东瞅瞅，西碰碰，最后大四准备考研了［再次捂脸～］虽然高考完了填志愿时就打算了读完大学考研。备考这一年也不知道怎么熬过来的，寝室那仨都直接跑去实习就业了，所以寝室就我一个人，虽说和此时此景迷之相似，但我知道后会有期，而如今呢，聚散随缘，天各一方。毕业酒会上，大家也都把酒言欢，可醉过之后呢，都依依不舍和浓浓的离愁别绪。毕业照拍摄，天公也不作美，大雨倾盆，这天气真是比人还多愁善感。。。<br>初来南昌，我对这个城市不痛不痒，但感觉交通秩序是真差。。。但时至今日，临别在即，却也依依不舍。似乎除了故乡，我只拍过此地的月亮。也许我还没有看透世态炎凉，人事易分，但我真的看够了月圆月缺，烟花易冷。记得读过这样一句话“一个人成年以后。得做好失去的准备。”得之坦然，失之淡然，争是必然，顺其自然吧。<br><img src=\"http://i1.piimg.com/567571/601989ceade3dd16.jpg\"></p>\n<h2 id=\"书写当下\"><a href=\"#书写当下\" class=\"headerlink\" title=\"书写当下\"></a>书写当下</h2><p>“谁校对时间，谁就会忽然变老”。<br>寝室四个我是最后一个走的，倒不是不想提前走，只是我这人喜欢送别人，不喜欢别人送我［无解～］最开始告别了林仔，然后送走i橙和聪哥，最后看着空空荡荡的房间，忽然就放了苏打绿的那首歌《我好想你》“开了灯眼前的模样，偌大的放。。。”呃，其实寝室很小啦。<br>今天我原本打算去小杏岭情人坡埋一个时间囊的，但是奈何学校的草地土质太硬了［衰～］，根本挖不动吖，更别说挖个洞了。也许是许久没有下雨的缘故吧，我只好把它沉到了静湖里(°_°)… 反正以后也一不定能找见不是嘛，就当搁个不求打捞的思念吧，让它替我的回忆留守此地。今天下午我又去重新坐了一下南昌市地铁1号线，从瑶湖师大到老师大的距离就是我们之间的距离吧。<br>明天去火车站的我打算让的士司机再绕一绕这座城市，看看奥体中心，艾溪湖，艾溪桥，老师大，八一广场，老福山，坛子口。。。<br>因为我知道，此去一别，相逢随缘啦。<br><img src=\"http://i1.piimg.com/567571/37655a2af55e22ea.jpg\"></p>\n<h2 id=\"遥寄未来\"><a href=\"#遥寄未来\" class=\"headerlink\" title=\"遥寄未来\"></a>遥寄未来</h2><p>哎。。。生而为人，生来孤独。人这一生什么也留不住，只能同那千变万化的瞬间起舞。不觉窗外已更深雾重，然后自己在这碎碎念，也不知道都写了些啥，反正想到什么就写下什么，这不正如记忆的零碎嘛。好了啦，明天还要早起收拾些东西，打扫下寝室，就早点休息吧，晚安啦，自己。晚安啦，此地。<br>谨以此文寄给未来的自己，希望未来的你过得比从前每一天都好。天天开心，事事顺心！<br>“重逢处飞鸟起落，不是往日你我”<br><img src=\"http://i2.muimg.com/567571/e4c674e70b46ed15.jpg\"></p>\n<p>丙申年 夏<br>于南昌</p>\n","site":{"data":{}},"wordcount":1630,"excerpt":"","more":"<p>“时间是个贪婪的赌徒，从不作弊，每赌必赢” ————波德莱尔《时钟》</p>\n<p>明天就要收拾行李离开寝室，离开师大，离开这座城市了。此去经年，往事如烟。铭记每一天，想念一些人，也深爱这土地。此番一别，重聚是缘。</p>\n<h2 id=\"封缄过往\"><a href=\"#封缄过往\" class=\"headerlink\" title=\"封缄过往\"></a>封缄过往</h2><p>四年时间，既长又短。新生入学第一天的场景还历历在目，而如今已物是人非。依稀记得我当时去学院指定地点报到，迎新的是一个大二的学姐，好像是甘肃的吧，第一次接触北方人，但感觉她和蔼可亲的样子冲淡了我对北方人氏粗狂豪迈的人设。她告诉我关于大学生活的一些注意事项，担心我不熟悉路，还送我到了寝室拿好了钥匙，真是细心学姐一枚，哈哈～ 刚来学校觉得学校好大，然后读着读着就小了，在这临别之际，感觉校园似乎又变大了，大得可以装下每一届毕业生的离愁别绪。<br>大一新生入学，就是军训啦，外加各种社团招新。感觉当时的自己图个热闹，也忙得不亦乐乎。总之大一整学年过得还称心如意。不得不提的就是我们学校的一个可爱又烦人的传统，每年毕业季的时候，毕业生们就会成群结队在每栋异性宿舍楼下唱几首歌，有时还深更半夜在校园里呐喊“我！们！毕！业！啦！”，不知道是无处发泄为数不多的青春，还是得通过嘶吼来缓解离愁别绪。大一我对这种现象的态度是不解，到了大二感觉是烦人，大三觉得也还能接收，而如今大四已经毕业时，才蓦然觉得感同身受。。。不过那一年毕业时那个学姐一个人拿着音响对整个6栋唱了一个多小时的歌情景，真令人记忆犹新吖，真的，有些事情不做，可能一辈子都不会做了吧。<br>大二以后我就开始喜欢上了旅行，和同学一起的，自己一个人去的，反正只要走着就很好。读万卷书，行万里路吧。去过好些地方，但令我向往的还是那些没去过的地方［捂脸～］<br>大三准备找实习，东瞅瞅，西碰碰，最后大四准备考研了［再次捂脸～］虽然高考完了填志愿时就打算了读完大学考研。备考这一年也不知道怎么熬过来的，寝室那仨都直接跑去实习就业了，所以寝室就我一个人，虽说和此时此景迷之相似，但我知道后会有期，而如今呢，聚散随缘，天各一方。毕业酒会上，大家也都把酒言欢，可醉过之后呢，都依依不舍和浓浓的离愁别绪。毕业照拍摄，天公也不作美，大雨倾盆，这天气真是比人还多愁善感。。。<br>初来南昌，我对这个城市不痛不痒，但感觉交通秩序是真差。。。但时至今日，临别在即，却也依依不舍。似乎除了故乡，我只拍过此地的月亮。也许我还没有看透世态炎凉，人事易分，但我真的看够了月圆月缺，烟花易冷。记得读过这样一句话“一个人成年以后。得做好失去的准备。”得之坦然，失之淡然，争是必然，顺其自然吧。<br><img src=\"http://i1.piimg.com/567571/601989ceade3dd16.jpg\"></p>\n<h2 id=\"书写当下\"><a href=\"#书写当下\" class=\"headerlink\" title=\"书写当下\"></a>书写当下</h2><p>“谁校对时间，谁就会忽然变老”。<br>寝室四个我是最后一个走的，倒不是不想提前走，只是我这人喜欢送别人，不喜欢别人送我［无解～］最开始告别了林仔，然后送走i橙和聪哥，最后看着空空荡荡的房间，忽然就放了苏打绿的那首歌《我好想你》“开了灯眼前的模样，偌大的放。。。”呃，其实寝室很小啦。<br>今天我原本打算去小杏岭情人坡埋一个时间囊的，但是奈何学校的草地土质太硬了［衰～］，根本挖不动吖，更别说挖个洞了。也许是许久没有下雨的缘故吧，我只好把它沉到了静湖里(°_°)… 反正以后也一不定能找见不是嘛，就当搁个不求打捞的思念吧，让它替我的回忆留守此地。今天下午我又去重新坐了一下南昌市地铁1号线，从瑶湖师大到老师大的距离就是我们之间的距离吧。<br>明天去火车站的我打算让的士司机再绕一绕这座城市，看看奥体中心，艾溪湖，艾溪桥，老师大，八一广场，老福山，坛子口。。。<br>因为我知道，此去一别，相逢随缘啦。<br><img src=\"http://i1.piimg.com/567571/37655a2af55e22ea.jpg\"></p>\n<h2 id=\"遥寄未来\"><a href=\"#遥寄未来\" class=\"headerlink\" title=\"遥寄未来\"></a>遥寄未来</h2><p>哎。。。生而为人，生来孤独。人这一生什么也留不住，只能同那千变万化的瞬间起舞。不觉窗外已更深雾重，然后自己在这碎碎念，也不知道都写了些啥，反正想到什么就写下什么，这不正如记忆的零碎嘛。好了啦，明天还要早起收拾些东西，打扫下寝室，就早点休息吧，晚安啦，自己。晚安啦，此地。<br>谨以此文寄给未来的自己，希望未来的你过得比从前每一天都好。天天开心，事事顺心！<br>“重逢处飞鸟起落，不是往日你我”<br><img src=\"http://i2.muimg.com/567571/e4c674e70b46ed15.jpg\"></p>\n<p>丙申年 夏<br>于南昌</p>\n"},{"title":"语音特征参数MFCC提取过程详解","date":"2016-09-19T14:00:24.000Z","thumbnail":"http://i1.piimg.com/567571/8d00f04e63e5752f.png","_content":"\n在语音处理领域里，梅尔频率倒谱(mel-frequency cepstrum简称MFC)表示一个语音的短时功率谱，是一个语音的对数功率谱在频率的一个非线性梅尔刻度上进行线性余弦转换所得。\n## MFCC概述\n\n所有的梅尔频率倒谱系数(Mel-frequency cepstral coefficients  简称MFCC)共同的组成一个MFC。MFCCs在Mel标度频率域提取出来的倒谱参数。倒谱和梅尔频率倒谱之间的差别是在MFC中，频带在梅尔刻度上是等间隔的，这比利用线性间隔频带的倒谱更接近于人类的听觉特性。\n\n梅尔倒谱系数（Mel-scale Frequency Cepstral Coefficients，简称MFCC）。根据人耳听觉机理的研究发现，人耳对不同频率的声波有不同的听觉敏感度。从200Hz到5000Hz的语音信号对语音的清晰度影响对大。两个响度不等的声音作用于人耳时，则响度较高的频率成分的存在会影响到对响度较低的频率成分的感受，使其变得不易察觉，这种现象称为掩蔽效应。由于频率较低的声音在内耳蜗基底膜上行波传递的距离大于频率较高的声音，故一般来说，低音容易掩蔽高音，而高音掩蔽低音较困难。在低频处的声音掩蔽的临界带宽较高频要小。所以，人们从低频到高频这一段频带内按临界带宽的大小由密到疏安排一组带通滤波器，对输入信号进行滤波。将每个带通滤波器输出的信号能量作为信号的基本特征，对此特征经过进一步处理后就可以作为语音的输入特征。由于这种特征不依赖于信号的性质，对输入信号不做任何的假设和限制，又利用了听觉模型的研究成果。因此，这种参数比基于声道模型的LPCC相比具有更好的鲁邦性，更符合人耳的听觉特性，而且当信噪比降低时仍然具有较好的识别性能。\n梅尔倒谱系数（Mel-scale Frequency Cepstral Coefficients，简称MFCC）是在Mel标度频率域提取出来的倒谱参数，Mel标度描述了人耳频率的非线性特性，它与频率的关系可用下式近似表示：\n!式中f为频率，单位为Hz。![下图展示了Mel频率与线性频率的关系：](http://i4.buimg.com/567571/30101a853606f79a.png)\n## MFCC的提取过程\n基本流程图如下所示![：](http://i4.buimg.com/567571/b9f554db65843806.png)\n### 预加重\n预加重处理其实是将语音信号通过一个高通滤波器。预加重的目的是提升高频部分，使信号的频谱变得平坦，保持在低频到高频的整个频带中，能用同样的信噪比求频谱。同时，也是为了消除发生过程中声带和嘴唇的效应，来补偿语音信号受到发音系统所抑制的高频部分，也为了突出高频的共振峰。\n\n### 分帧\n先将N个采样点集合成一个观测单位，称为帧。通常情况下N的值为256或512，涵盖的时间约为20~30ms左右。为了避免相邻两帧的变化过大，因此会让两相邻帧之间有一段重叠区域，此重叠区域包含了M个取样点，通常M的值约为N的1/2或1/3。通常语音识别所采用语音信号的采样频率为8KHz或16KHz，以8KHz来说，若帧长度为256个采样点，则对应的时间长度是256/8000×1000=32ms。\n\n### 加窗\n将每一帧乘以汉明窗，以增加帧左端和右端的连续性。假设分帧后的信号为S(n), n=0,1…,N-1, N为帧的大小，那么乘上汉明窗后，![W(n)形式如下：](http://i4.buimg.com/567571/40616a69a003fdb5.png)\n\n不同的a值会产生不同的汉明窗，一般情况下a取0.46\n\n### 快速傅立叶变换(FFT)\n由于信号在时域上的变换通常很难看出信号的特性，所以通常将它转换为频域上的能量分布来观察，不同的能量分布，就能代表不同语音的特性。所以在乘上汉明窗后，每帧还必须再经过快速傅里叶变换以得到在频谱上的能量分布。对分帧加窗后的各帧信号进行快速傅里叶变换得到各帧的频谱。并对语音信号的频谱取模平方得到语音信号的功率谱。![设语音信号的DFT为:](http://i4.buimg.com/567571/7bded251e1eef088.png)式中x(n)为输入的语音信号，N表示傅里叶变换的点数。\n\n### 三角带通滤波器\n三角形带通滤波器组的设计过程如下：假设语音信号的采样频率,帧长N=256，滤波器个数K=22.由此可得语音信号的最大频率为![：](http://i2.muimg.com/567571/f4ae206f2de2033a.png)\n![根据公式：]()http://i4.buimg.com/567571/a2cb6880c19f3df6.png可以求得出最大的Mel频率。\n由于在Mel刻度范围内，各个三角滤波器的中心频率是相等间隔的线性分布。由此，可以计算两个相邻三角滤波器的中心频率的间距为：(http://i1.piimg.com/567571/9b6787110581809b.png)\n因此，各三角形滤波器在mel刻度上的中心频率可以由Mel频率与线性频率的关系式求出。\n\n由上面的中心频率可以计算出对应的线性刻度上的频率。![如下图所示：](http://i2.muimg.com/567571/8b4d169ffeebcbb4.png)\n将功率谱通过一组Mel尺度的三角形滤波器组，定义一个有K个滤波器的滤波器组（滤波器的个数和临界带的个数相近），采用的滤波器为三角滤波器，中心频率为f(m),m=1,2,...,K。K通常取22-26。各 f(m)之间的间隔随着m值的减小而缩小，随着m值的增大而增宽，\n\n每一个三角形滤波器的中心频率c(l) 在Mel频率轴上等间隔分布。设o(l),c(l),h(l) 分别是第l 个三角形滤波器的下限，中心，和上限频率，则相邻三角形滤波器之间的下限，中心，上限频率的关系如下：c(l)=h(l-1)=o(l+1);  如图所示![：](http://i4.buimg.com/567571/47d4ea5baf1ec728.png)\n###  计算每个滤波器组输出的对数能量为:\n(http://i4.buimg.com/567571/f38f2ce76b6f9def.png)\n### 经离散余弦变换（DCT）得到MFCC系数：\n将上述的对数能量带入离散余弦变换，求出L阶的Mel-scale Cepstrum参数。L阶指MFCC系数阶数，通常取12-16。这里M是三角滤波器个数。\n\n### 对数能量\n此外，一帧的音量（即能量），也是语音的重要特征，而且非常容易计算。因此，通常再加上一帧的对数能量（定义：一帧内信号的平方和，再取以10为底的对数值，再乘以10）使得每一帧基本的语音特征就多了一维，包括一个对数能量和剩下的倒频谱参数。\n\n注：若要加入其它语音特征以测试识别率，也可以在此阶段加入，这些常用的其它语音特征包含音高、过零率以及共振峰等。\n\n### 动态差分参数的提取（包括一阶差分和二阶差分）\n标准的倒谱参数MFCC只反映了语音参数的静态特性，语音的动态特性可以用这些静态特征的差分谱来描述。实验证明：把动、静态特征结合起来才能有效提高系统的识别性能。\n### 总结：\n\n因此，MFCC的全部组成其实是由：\n\nN维MFCC参数（N/3 MFCC系数+ N/3 一阶差分参数+ N/3 二阶差分参数）+帧能量（此项可根据需求替换）\n\n## 具体实现\n### MATLAB实现\n''' bash\n% MFCC implement with Matlab % \n[x fs]=wavread('test.wav');\nbank=melbankm(24,256,fs,0,0.4,'t'); %Mel滤波器的阶数为24，FFT变换的长度为256，采样频率为16000Hz\n%归一化Mel滤波器组系数\nbank=full(bank); %full() convert sparse matrix to full matrix \nbank=bank/max(bank(:)); \nfor k=1:12 \n    n=0:23; \n    dctcoef(k,:)=cos((2*n+1)*k*pi/(2*24));\nend  \nw=1+6*sin(pi*[1:12]./12);%归一化倒谱提升窗口\nw=w/max(w);%预加重滤波器  \nxx=double(x);  \nxx=filter([1-0.9375],1,xx);%语音信号分帧  \nxx=enframe(xx,256,80);%对xx 256点分为一帧  \n%计算每帧的MFCC参数  \nfor i=1:size(xx,1)  \n    y=xx(i,:);  \n    s=y'.*hamming(256);  \n    t=abs(fft(s));%FFT快速傅里叶变换  \n    t=t.^2;  \n    c1=dctcoef*log(bank*t(1:129));  \n    c2=c1.*w';  \n    m(i,:)=c2;  \nend  \n%求一阶差分系数  \ndtm=zeros(size(m));  \nfor i=3:size(m,1)-2  \n    dtm(i,:)=-2*m(i-2,:)-m(i-1,:)+m(i+1,:)+2*m(i+2,:);  \nend  \ndtm=dtm/3;  \n%求取二阶差分系数  \ndtmm=zeros(size(dtm));  \nfor i=3:size(dtm,1)-2  \n    dtmm(i,:)=-2*dtm(i-2,:)-dtm(i-1,:)+dtm(i+1,:)+2*dtm(i+2,:);  \nend  \ndtmm=dtmm/3;  \n%合并mfcc参数和一阶差分mfcc参数  \nccc=[m dtm dtmm];  \n%去除首尾两帧，以为这两帧的一阶差分参数为0  \nccc=ccc(3:size(m,1)-2,:);  \nccc;  \nsubplot(2,1,1);  \nccc_1=ccc(:,1);  \nplot(ccc_1);title('MFCC');ylabel('幅值');  \n[h,w]=size(ccc);  \nA=size(ccc);  \nsubplot(2,1,2);  \nplot([1,w],A);  \nxlabel('维数');ylabel('幅值');  \ntitle('维数与幅值的关系'); \n'''\n\n![所得结果为：](http://i1.piimg.com/567571/0f67ecb1f9e4e8a7.png)\n\n### HTK(HTK Speech Recognition Toolkit)工具包提取MFCC：\ncd ~/HTK/htk/bin.win32/下运行如下指令:\n''' bash\n再配置文件夹下运行： HCopy config 8.wav 8.mfcc 其中，涉及mfcc的参数为： TARGETKIND=MFCC_E_D_A -目标是MFCC文件，以及energy(E), delta(D),delta-delta(A) TARGETRATE=100000 -窗间隔为10ms WINDOWSIZE=250000 -窗长为25ms 注：HTK中时间单位为100ns ZMEANSOURCE=T -将来源文件取zero mean,即去掉DC值 USEHAMMING=T -使用hamming window PREEMCOEF=0.97 -预加重系数0.97 NUMCHANS=31 -在MEL刻度下等分成31个频带 USEPOWER=F -不使用c(0)参数 \n'''\n\n### OpenSMILE工具包提取MFCC：\n对于批量提取的wav音频数据的MFCC特征，可以将提取指令写入批处理文件，执行即可。\ncd ~/opensmile/bin/Win32/下运行如下指令:\n''' bash\nSMILExtract_Release -C E:\\speakerData\\opensmile-2.3.0\\config\\MFCC12_E_D_A_Z.conf -I\tE:\\深度学习\\基于声音的场景识别\\音频数据集\\TUT-acoustic-scenes-2016-development.audio\\TUT-acoustic-scenes-2016-development.Audio.All\\audio\\a001_0_30.wav\t-O\tE:\\深度学习\\基于声音的场景识别\\音频数据集\\TUT-acoustic-scenes-2016-development.audio\\TUT-acoustic-scenes-2016-development.Audio.All\\DNNmfcc\\a001_0_30.mfcc\n'''\n\n","source":"_posts/语音特征参数MFCC提取过程详解.md","raw":"---\ntitle: 语音特征参数MFCC提取过程详解\ndate: 2016-09-19 22:00:24\ntags:\ncategories: 分享集\nthumbnail: http://i1.piimg.com/567571/8d00f04e63e5752f.png\n---\n\n在语音处理领域里，梅尔频率倒谱(mel-frequency cepstrum简称MFC)表示一个语音的短时功率谱，是一个语音的对数功率谱在频率的一个非线性梅尔刻度上进行线性余弦转换所得。\n## MFCC概述\n\n所有的梅尔频率倒谱系数(Mel-frequency cepstral coefficients  简称MFCC)共同的组成一个MFC。MFCCs在Mel标度频率域提取出来的倒谱参数。倒谱和梅尔频率倒谱之间的差别是在MFC中，频带在梅尔刻度上是等间隔的，这比利用线性间隔频带的倒谱更接近于人类的听觉特性。\n\n梅尔倒谱系数（Mel-scale Frequency Cepstral Coefficients，简称MFCC）。根据人耳听觉机理的研究发现，人耳对不同频率的声波有不同的听觉敏感度。从200Hz到5000Hz的语音信号对语音的清晰度影响对大。两个响度不等的声音作用于人耳时，则响度较高的频率成分的存在会影响到对响度较低的频率成分的感受，使其变得不易察觉，这种现象称为掩蔽效应。由于频率较低的声音在内耳蜗基底膜上行波传递的距离大于频率较高的声音，故一般来说，低音容易掩蔽高音，而高音掩蔽低音较困难。在低频处的声音掩蔽的临界带宽较高频要小。所以，人们从低频到高频这一段频带内按临界带宽的大小由密到疏安排一组带通滤波器，对输入信号进行滤波。将每个带通滤波器输出的信号能量作为信号的基本特征，对此特征经过进一步处理后就可以作为语音的输入特征。由于这种特征不依赖于信号的性质，对输入信号不做任何的假设和限制，又利用了听觉模型的研究成果。因此，这种参数比基于声道模型的LPCC相比具有更好的鲁邦性，更符合人耳的听觉特性，而且当信噪比降低时仍然具有较好的识别性能。\n梅尔倒谱系数（Mel-scale Frequency Cepstral Coefficients，简称MFCC）是在Mel标度频率域提取出来的倒谱参数，Mel标度描述了人耳频率的非线性特性，它与频率的关系可用下式近似表示：\n!式中f为频率，单位为Hz。![下图展示了Mel频率与线性频率的关系：](http://i4.buimg.com/567571/30101a853606f79a.png)\n## MFCC的提取过程\n基本流程图如下所示![：](http://i4.buimg.com/567571/b9f554db65843806.png)\n### 预加重\n预加重处理其实是将语音信号通过一个高通滤波器。预加重的目的是提升高频部分，使信号的频谱变得平坦，保持在低频到高频的整个频带中，能用同样的信噪比求频谱。同时，也是为了消除发生过程中声带和嘴唇的效应，来补偿语音信号受到发音系统所抑制的高频部分，也为了突出高频的共振峰。\n\n### 分帧\n先将N个采样点集合成一个观测单位，称为帧。通常情况下N的值为256或512，涵盖的时间约为20~30ms左右。为了避免相邻两帧的变化过大，因此会让两相邻帧之间有一段重叠区域，此重叠区域包含了M个取样点，通常M的值约为N的1/2或1/3。通常语音识别所采用语音信号的采样频率为8KHz或16KHz，以8KHz来说，若帧长度为256个采样点，则对应的时间长度是256/8000×1000=32ms。\n\n### 加窗\n将每一帧乘以汉明窗，以增加帧左端和右端的连续性。假设分帧后的信号为S(n), n=0,1…,N-1, N为帧的大小，那么乘上汉明窗后，![W(n)形式如下：](http://i4.buimg.com/567571/40616a69a003fdb5.png)\n\n不同的a值会产生不同的汉明窗，一般情况下a取0.46\n\n### 快速傅立叶变换(FFT)\n由于信号在时域上的变换通常很难看出信号的特性，所以通常将它转换为频域上的能量分布来观察，不同的能量分布，就能代表不同语音的特性。所以在乘上汉明窗后，每帧还必须再经过快速傅里叶变换以得到在频谱上的能量分布。对分帧加窗后的各帧信号进行快速傅里叶变换得到各帧的频谱。并对语音信号的频谱取模平方得到语音信号的功率谱。![设语音信号的DFT为:](http://i4.buimg.com/567571/7bded251e1eef088.png)式中x(n)为输入的语音信号，N表示傅里叶变换的点数。\n\n### 三角带通滤波器\n三角形带通滤波器组的设计过程如下：假设语音信号的采样频率,帧长N=256，滤波器个数K=22.由此可得语音信号的最大频率为![：](http://i2.muimg.com/567571/f4ae206f2de2033a.png)\n![根据公式：]()http://i4.buimg.com/567571/a2cb6880c19f3df6.png可以求得出最大的Mel频率。\n由于在Mel刻度范围内，各个三角滤波器的中心频率是相等间隔的线性分布。由此，可以计算两个相邻三角滤波器的中心频率的间距为：(http://i1.piimg.com/567571/9b6787110581809b.png)\n因此，各三角形滤波器在mel刻度上的中心频率可以由Mel频率与线性频率的关系式求出。\n\n由上面的中心频率可以计算出对应的线性刻度上的频率。![如下图所示：](http://i2.muimg.com/567571/8b4d169ffeebcbb4.png)\n将功率谱通过一组Mel尺度的三角形滤波器组，定义一个有K个滤波器的滤波器组（滤波器的个数和临界带的个数相近），采用的滤波器为三角滤波器，中心频率为f(m),m=1,2,...,K。K通常取22-26。各 f(m)之间的间隔随着m值的减小而缩小，随着m值的增大而增宽，\n\n每一个三角形滤波器的中心频率c(l) 在Mel频率轴上等间隔分布。设o(l),c(l),h(l) 分别是第l 个三角形滤波器的下限，中心，和上限频率，则相邻三角形滤波器之间的下限，中心，上限频率的关系如下：c(l)=h(l-1)=o(l+1);  如图所示![：](http://i4.buimg.com/567571/47d4ea5baf1ec728.png)\n###  计算每个滤波器组输出的对数能量为:\n(http://i4.buimg.com/567571/f38f2ce76b6f9def.png)\n### 经离散余弦变换（DCT）得到MFCC系数：\n将上述的对数能量带入离散余弦变换，求出L阶的Mel-scale Cepstrum参数。L阶指MFCC系数阶数，通常取12-16。这里M是三角滤波器个数。\n\n### 对数能量\n此外，一帧的音量（即能量），也是语音的重要特征，而且非常容易计算。因此，通常再加上一帧的对数能量（定义：一帧内信号的平方和，再取以10为底的对数值，再乘以10）使得每一帧基本的语音特征就多了一维，包括一个对数能量和剩下的倒频谱参数。\n\n注：若要加入其它语音特征以测试识别率，也可以在此阶段加入，这些常用的其它语音特征包含音高、过零率以及共振峰等。\n\n### 动态差分参数的提取（包括一阶差分和二阶差分）\n标准的倒谱参数MFCC只反映了语音参数的静态特性，语音的动态特性可以用这些静态特征的差分谱来描述。实验证明：把动、静态特征结合起来才能有效提高系统的识别性能。\n### 总结：\n\n因此，MFCC的全部组成其实是由：\n\nN维MFCC参数（N/3 MFCC系数+ N/3 一阶差分参数+ N/3 二阶差分参数）+帧能量（此项可根据需求替换）\n\n## 具体实现\n### MATLAB实现\n''' bash\n% MFCC implement with Matlab % \n[x fs]=wavread('test.wav');\nbank=melbankm(24,256,fs,0,0.4,'t'); %Mel滤波器的阶数为24，FFT变换的长度为256，采样频率为16000Hz\n%归一化Mel滤波器组系数\nbank=full(bank); %full() convert sparse matrix to full matrix \nbank=bank/max(bank(:)); \nfor k=1:12 \n    n=0:23; \n    dctcoef(k,:)=cos((2*n+1)*k*pi/(2*24));\nend  \nw=1+6*sin(pi*[1:12]./12);%归一化倒谱提升窗口\nw=w/max(w);%预加重滤波器  \nxx=double(x);  \nxx=filter([1-0.9375],1,xx);%语音信号分帧  \nxx=enframe(xx,256,80);%对xx 256点分为一帧  \n%计算每帧的MFCC参数  \nfor i=1:size(xx,1)  \n    y=xx(i,:);  \n    s=y'.*hamming(256);  \n    t=abs(fft(s));%FFT快速傅里叶变换  \n    t=t.^2;  \n    c1=dctcoef*log(bank*t(1:129));  \n    c2=c1.*w';  \n    m(i,:)=c2;  \nend  \n%求一阶差分系数  \ndtm=zeros(size(m));  \nfor i=3:size(m,1)-2  \n    dtm(i,:)=-2*m(i-2,:)-m(i-1,:)+m(i+1,:)+2*m(i+2,:);  \nend  \ndtm=dtm/3;  \n%求取二阶差分系数  \ndtmm=zeros(size(dtm));  \nfor i=3:size(dtm,1)-2  \n    dtmm(i,:)=-2*dtm(i-2,:)-dtm(i-1,:)+dtm(i+1,:)+2*dtm(i+2,:);  \nend  \ndtmm=dtmm/3;  \n%合并mfcc参数和一阶差分mfcc参数  \nccc=[m dtm dtmm];  \n%去除首尾两帧，以为这两帧的一阶差分参数为0  \nccc=ccc(3:size(m,1)-2,:);  \nccc;  \nsubplot(2,1,1);  \nccc_1=ccc(:,1);  \nplot(ccc_1);title('MFCC');ylabel('幅值');  \n[h,w]=size(ccc);  \nA=size(ccc);  \nsubplot(2,1,2);  \nplot([1,w],A);  \nxlabel('维数');ylabel('幅值');  \ntitle('维数与幅值的关系'); \n'''\n\n![所得结果为：](http://i1.piimg.com/567571/0f67ecb1f9e4e8a7.png)\n\n### HTK(HTK Speech Recognition Toolkit)工具包提取MFCC：\ncd ~/HTK/htk/bin.win32/下运行如下指令:\n''' bash\n再配置文件夹下运行： HCopy config 8.wav 8.mfcc 其中，涉及mfcc的参数为： TARGETKIND=MFCC_E_D_A -目标是MFCC文件，以及energy(E), delta(D),delta-delta(A) TARGETRATE=100000 -窗间隔为10ms WINDOWSIZE=250000 -窗长为25ms 注：HTK中时间单位为100ns ZMEANSOURCE=T -将来源文件取zero mean,即去掉DC值 USEHAMMING=T -使用hamming window PREEMCOEF=0.97 -预加重系数0.97 NUMCHANS=31 -在MEL刻度下等分成31个频带 USEPOWER=F -不使用c(0)参数 \n'''\n\n### OpenSMILE工具包提取MFCC：\n对于批量提取的wav音频数据的MFCC特征，可以将提取指令写入批处理文件，执行即可。\ncd ~/opensmile/bin/Win32/下运行如下指令:\n''' bash\nSMILExtract_Release -C E:\\speakerData\\opensmile-2.3.0\\config\\MFCC12_E_D_A_Z.conf -I\tE:\\深度学习\\基于声音的场景识别\\音频数据集\\TUT-acoustic-scenes-2016-development.audio\\TUT-acoustic-scenes-2016-development.Audio.All\\audio\\a001_0_30.wav\t-O\tE:\\深度学习\\基于声音的场景识别\\音频数据集\\TUT-acoustic-scenes-2016-development.audio\\TUT-acoustic-scenes-2016-development.Audio.All\\DNNmfcc\\a001_0_30.mfcc\n'''\n\n","slug":"语音特征参数MFCC提取过程详解","published":1,"updated":"2021-12-12T14:25:37.085Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3bsl2iu000n5awqfsbebsc2","content":"<p>在语音处理领域里，梅尔频率倒谱(mel-frequency cepstrum简称MFC)表示一个语音的短时功率谱，是一个语音的对数功率谱在频率的一个非线性梅尔刻度上进行线性余弦转换所得。</p>\n<h2 id=\"MFCC概述\"><a href=\"#MFCC概述\" class=\"headerlink\" title=\"MFCC概述\"></a>MFCC概述</h2><p>所有的梅尔频率倒谱系数(Mel-frequency cepstral coefficients  简称MFCC)共同的组成一个MFC。MFCCs在Mel标度频率域提取出来的倒谱参数。倒谱和梅尔频率倒谱之间的差别是在MFC中，频带在梅尔刻度上是等间隔的，这比利用线性间隔频带的倒谱更接近于人类的听觉特性。</p>\n<p>梅尔倒谱系数（Mel-scale Frequency Cepstral Coefficients，简称MFCC）。根据人耳听觉机理的研究发现，人耳对不同频率的声波有不同的听觉敏感度。从200Hz到5000Hz的语音信号对语音的清晰度影响对大。两个响度不等的声音作用于人耳时，则响度较高的频率成分的存在会影响到对响度较低的频率成分的感受，使其变得不易察觉，这种现象称为掩蔽效应。由于频率较低的声音在内耳蜗基底膜上行波传递的距离大于频率较高的声音，故一般来说，低音容易掩蔽高音，而高音掩蔽低音较困难。在低频处的声音掩蔽的临界带宽较高频要小。所以，人们从低频到高频这一段频带内按临界带宽的大小由密到疏安排一组带通滤波器，对输入信号进行滤波。将每个带通滤波器输出的信号能量作为信号的基本特征，对此特征经过进一步处理后就可以作为语音的输入特征。由于这种特征不依赖于信号的性质，对输入信号不做任何的假设和限制，又利用了听觉模型的研究成果。因此，这种参数比基于声道模型的LPCC相比具有更好的鲁邦性，更符合人耳的听觉特性，而且当信噪比降低时仍然具有较好的识别性能。<br>梅尔倒谱系数（Mel-scale Frequency Cepstral Coefficients，简称MFCC）是在Mel标度频率域提取出来的倒谱参数，Mel标度描述了人耳频率的非线性特性，它与频率的关系可用下式近似表示：<br>!式中f为频率，单位为Hz。<img src=\"http://i4.buimg.com/567571/30101a853606f79a.png\" alt=\"下图展示了Mel频率与线性频率的关系：\"></p>\n<h2 id=\"MFCC的提取过程\"><a href=\"#MFCC的提取过程\" class=\"headerlink\" title=\"MFCC的提取过程\"></a>MFCC的提取过程</h2><p>基本流程图如下所示<img src=\"http://i4.buimg.com/567571/b9f554db65843806.png\" alt=\"：\"></p>\n<h3 id=\"预加重\"><a href=\"#预加重\" class=\"headerlink\" title=\"预加重\"></a>预加重</h3><p>预加重处理其实是将语音信号通过一个高通滤波器。预加重的目的是提升高频部分，使信号的频谱变得平坦，保持在低频到高频的整个频带中，能用同样的信噪比求频谱。同时，也是为了消除发生过程中声带和嘴唇的效应，来补偿语音信号受到发音系统所抑制的高频部分，也为了突出高频的共振峰。</p>\n<h3 id=\"分帧\"><a href=\"#分帧\" class=\"headerlink\" title=\"分帧\"></a>分帧</h3><p>先将N个采样点集合成一个观测单位，称为帧。通常情况下N的值为256或512，涵盖的时间约为20~30ms左右。为了避免相邻两帧的变化过大，因此会让两相邻帧之间有一段重叠区域，此重叠区域包含了M个取样点，通常M的值约为N的1&#x2F;2或1&#x2F;3。通常语音识别所采用语音信号的采样频率为8KHz或16KHz，以8KHz来说，若帧长度为256个采样点，则对应的时间长度是256&#x2F;8000×1000&#x3D;32ms。</p>\n<h3 id=\"加窗\"><a href=\"#加窗\" class=\"headerlink\" title=\"加窗\"></a>加窗</h3><p>将每一帧乘以汉明窗，以增加帧左端和右端的连续性。假设分帧后的信号为S(n), n&#x3D;0,1…,N-1, N为帧的大小，那么乘上汉明窗后，<img src=\"http://i4.buimg.com/567571/40616a69a003fdb5.png\" alt=\"W(n)形式如下：\"></p>\n<p>不同的a值会产生不同的汉明窗，一般情况下a取0.46</p>\n<h3 id=\"快速傅立叶变换-FFT\"><a href=\"#快速傅立叶变换-FFT\" class=\"headerlink\" title=\"快速傅立叶变换(FFT)\"></a>快速傅立叶变换(FFT)</h3><p>由于信号在时域上的变换通常很难看出信号的特性，所以通常将它转换为频域上的能量分布来观察，不同的能量分布，就能代表不同语音的特性。所以在乘上汉明窗后，每帧还必须再经过快速傅里叶变换以得到在频谱上的能量分布。对分帧加窗后的各帧信号进行快速傅里叶变换得到各帧的频谱。并对语音信号的频谱取模平方得到语音信号的功率谱。<img src=\"http://i4.buimg.com/567571/7bded251e1eef088.png\" alt=\"设语音信号的DFT为:\">式中x(n)为输入的语音信号，N表示傅里叶变换的点数。</p>\n<h3 id=\"三角带通滤波器\"><a href=\"#三角带通滤波器\" class=\"headerlink\" title=\"三角带通滤波器\"></a>三角带通滤波器</h3><p>三角形带通滤波器组的设计过程如下：假设语音信号的采样频率,帧长N&#x3D;256，滤波器个数K&#x3D;22.由此可得语音信号的最大频率为<img src=\"http://i2.muimg.com/567571/f4ae206f2de2033a.png\" alt=\"：\"><br><img src=\"/\" alt=\"根据公式：\"><a href=\"http://i4.buimg.com/567571/a2cb6880c19f3df6.png%E5%8F%AF%E4%BB%A5%E6%B1%82%E5%BE%97%E5%87%BA%E6%9C%80%E5%A4%A7%E7%9A%84Mel%E9%A2%91%E7%8E%87%E3%80%82\">http://i4.buimg.com/567571/a2cb6880c19f3df6.png可以求得出最大的Mel频率。</a><br>由于在Mel刻度范围内，各个三角滤波器的中心频率是相等间隔的线性分布。由此，可以计算两个相邻三角滤波器的中心频率的间距为：(<a href=\"http://i1.piimg.com/567571/9b6787110581809b.png\">http://i1.piimg.com/567571/9b6787110581809b.png</a>)<br>因此，各三角形滤波器在mel刻度上的中心频率可以由Mel频率与线性频率的关系式求出。</p>\n<p>由上面的中心频率可以计算出对应的线性刻度上的频率。<img src=\"http://i2.muimg.com/567571/8b4d169ffeebcbb4.png\" alt=\"如下图所示：\"><br>将功率谱通过一组Mel尺度的三角形滤波器组，定义一个有K个滤波器的滤波器组（滤波器的个数和临界带的个数相近），采用的滤波器为三角滤波器，中心频率为f(m),m&#x3D;1,2,…,K。K通常取22-26。各 f(m)之间的间隔随着m值的减小而缩小，随着m值的增大而增宽，</p>\n<p>每一个三角形滤波器的中心频率c(l) 在Mel频率轴上等间隔分布。设o(l),c(l),h(l) 分别是第l 个三角形滤波器的下限，中心，和上限频率，则相邻三角形滤波器之间的下限，中心，上限频率的关系如下：c(l)&#x3D;h(l-1)&#x3D;o(l+1);  如图所示<img src=\"http://i4.buimg.com/567571/47d4ea5baf1ec728.png\" alt=\"：\"></p>\n<h3 id=\"计算每个滤波器组输出的对数能量为\"><a href=\"#计算每个滤波器组输出的对数能量为\" class=\"headerlink\" title=\"计算每个滤波器组输出的对数能量为:\"></a>计算每个滤波器组输出的对数能量为:</h3><p>(<a href=\"http://i4.buimg.com/567571/f38f2ce76b6f9def.png\">http://i4.buimg.com/567571/f38f2ce76b6f9def.png</a>)</p>\n<h3 id=\"经离散余弦变换（DCT）得到MFCC系数：\"><a href=\"#经离散余弦变换（DCT）得到MFCC系数：\" class=\"headerlink\" title=\"经离散余弦变换（DCT）得到MFCC系数：\"></a>经离散余弦变换（DCT）得到MFCC系数：</h3><p>将上述的对数能量带入离散余弦变换，求出L阶的Mel-scale Cepstrum参数。L阶指MFCC系数阶数，通常取12-16。这里M是三角滤波器个数。</p>\n<h3 id=\"对数能量\"><a href=\"#对数能量\" class=\"headerlink\" title=\"对数能量\"></a>对数能量</h3><p>此外，一帧的音量（即能量），也是语音的重要特征，而且非常容易计算。因此，通常再加上一帧的对数能量（定义：一帧内信号的平方和，再取以10为底的对数值，再乘以10）使得每一帧基本的语音特征就多了一维，包括一个对数能量和剩下的倒频谱参数。</p>\n<p>注：若要加入其它语音特征以测试识别率，也可以在此阶段加入，这些常用的其它语音特征包含音高、过零率以及共振峰等。</p>\n<h3 id=\"动态差分参数的提取（包括一阶差分和二阶差分）\"><a href=\"#动态差分参数的提取（包括一阶差分和二阶差分）\" class=\"headerlink\" title=\"动态差分参数的提取（包括一阶差分和二阶差分）\"></a>动态差分参数的提取（包括一阶差分和二阶差分）</h3><p>标准的倒谱参数MFCC只反映了语音参数的静态特性，语音的动态特性可以用这些静态特征的差分谱来描述。实验证明：把动、静态特征结合起来才能有效提高系统的识别性能。</p>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>因此，MFCC的全部组成其实是由：</p>\n<p>N维MFCC参数（N&#x2F;3 MFCC系数+ N&#x2F;3 一阶差分参数+ N&#x2F;3 二阶差分参数）+帧能量（此项可根据需求替换）</p>\n<h2 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h2><h3 id=\"MATLAB实现\"><a href=\"#MATLAB实现\" class=\"headerlink\" title=\"MATLAB实现\"></a>MATLAB实现</h3><p>‘’’ bash<br>% MFCC implement with Matlab %<br>[x fs]&#x3D;wavread(‘test.wav’);<br>bank&#x3D;melbankm(24,256,fs,0,0.4,’t’); %Mel滤波器的阶数为24，FFT变换的长度为256，采样频率为16000Hz<br>%归一化Mel滤波器组系数<br>bank&#x3D;full(bank); %full() convert sparse matrix to full matrix<br>bank&#x3D;bank&#x2F;max(bank(:));<br>for k&#x3D;1:12<br>    n&#x3D;0:23;<br>    dctcoef(k,:)&#x3D;cos((2<em>n+1)<em>k</em>pi&#x2F;(2</em>24));<br>end<br>w&#x3D;1+6<em>sin(pi</em>[1:12].&#x2F;12);%归一化倒谱提升窗口<br>w&#x3D;w&#x2F;max(w);%预加重滤波器<br>xx&#x3D;double(x);<br>xx&#x3D;filter([1-0.9375],1,xx);%语音信号分帧<br>xx&#x3D;enframe(xx,256,80);%对xx 256点分为一帧<br>%计算每帧的MFCC参数<br>for i&#x3D;1:size(xx,1)<br>    y&#x3D;xx(i,:);<br>    s&#x3D;y’.<em>hamming(256);<br>    t&#x3D;abs(fft(s));%FFT快速傅里叶变换<br>    t&#x3D;t.^2;<br>    c1&#x3D;dctcoef</em>log(bank<em>t(1:129));<br>    c2&#x3D;c1.<em>w’;<br>    m(i,:)&#x3D;c2;<br>end<br>%求一阶差分系数<br>dtm&#x3D;zeros(size(m));<br>for i&#x3D;3:size(m,1)-2<br>    dtm(i,:)&#x3D;-2</em>m(i-2,:)-m(i-1,:)+m(i+1,:)+2</em>m(i+2,:);<br>end<br>dtm&#x3D;dtm&#x2F;3;<br>%求取二阶差分系数<br>dtmm&#x3D;zeros(size(dtm));<br>for i&#x3D;3:size(dtm,1)-2<br>    dtmm(i,:)&#x3D;-2<em>dtm(i-2,:)-dtm(i-1,:)+dtm(i+1,:)+2</em>dtm(i+2,:);<br>end<br>dtmm&#x3D;dtmm&#x2F;3;<br>%合并mfcc参数和一阶差分mfcc参数<br>ccc&#x3D;[m dtm dtmm];<br>%去除首尾两帧，以为这两帧的一阶差分参数为0<br>ccc&#x3D;ccc(3:size(m,1)-2,:);<br>ccc;<br>subplot(2,1,1);<br>ccc_1&#x3D;ccc(:,1);<br>plot(ccc_1);title(‘MFCC’);ylabel(‘幅值’);<br>[h,w]&#x3D;size(ccc);<br>A&#x3D;size(ccc);<br>subplot(2,1,2);<br>plot([1,w],A);<br>xlabel(‘维数’);ylabel(‘幅值’);<br>title(‘维数与幅值的关系’);<br>‘’’</p>\n<p><img src=\"http://i1.piimg.com/567571/0f67ecb1f9e4e8a7.png\" alt=\"所得结果为：\"></p>\n<h3 id=\"HTK-HTK-Speech-Recognition-Toolkit-工具包提取MFCC：\"><a href=\"#HTK-HTK-Speech-Recognition-Toolkit-工具包提取MFCC：\" class=\"headerlink\" title=\"HTK(HTK Speech Recognition Toolkit)工具包提取MFCC：\"></a>HTK(HTK Speech Recognition Toolkit)工具包提取MFCC：</h3><p>cd ~&#x2F;HTK&#x2F;htk&#x2F;bin.win32&#x2F;下运行如下指令:<br>‘’’ bash<br>再配置文件夹下运行： HCopy config 8.wav 8.mfcc 其中，涉及mfcc的参数为： TARGETKIND&#x3D;MFCC_E_D_A -目标是MFCC文件，以及energy(E), delta(D),delta-delta(A) TARGETRATE&#x3D;100000 -窗间隔为10ms WINDOWSIZE&#x3D;250000 -窗长为25ms 注：HTK中时间单位为100ns ZMEANSOURCE&#x3D;T -将来源文件取zero mean,即去掉DC值 USEHAMMING&#x3D;T -使用hamming window PREEMCOEF&#x3D;0.97 -预加重系数0.97 NUMCHANS&#x3D;31 -在MEL刻度下等分成31个频带 USEPOWER&#x3D;F -不使用c(0)参数<br>‘’’</p>\n<h3 id=\"OpenSMILE工具包提取MFCC：\"><a href=\"#OpenSMILE工具包提取MFCC：\" class=\"headerlink\" title=\"OpenSMILE工具包提取MFCC：\"></a>OpenSMILE工具包提取MFCC：</h3><p>对于批量提取的wav音频数据的MFCC特征，可以将提取指令写入批处理文件，执行即可。<br>cd ~&#x2F;opensmile&#x2F;bin&#x2F;Win32&#x2F;下运行如下指令:<br>‘’’ bash<br>SMILExtract_Release -C E:\\speakerData\\opensmile-2.3.0\\config\\MFCC12_E_D_A_Z.conf -I\tE:\\深度学习\\基于声音的场景识别\\音频数据集\\TUT-acoustic-scenes-2016-development.audio\\TUT-acoustic-scenes-2016-development.Audio.All\\audio\\a001_0_30.wav\t-O\tE:\\深度学习\\基于声音的场景识别\\音频数据集\\TUT-acoustic-scenes-2016-development.audio\\TUT-acoustic-scenes-2016-development.Audio.All\\DNNmfcc\\a001_0_30.mfcc<br>‘’’</p>\n","site":{"data":{}},"wordcount":4784,"excerpt":"","more":"<p>在语音处理领域里，梅尔频率倒谱(mel-frequency cepstrum简称MFC)表示一个语音的短时功率谱，是一个语音的对数功率谱在频率的一个非线性梅尔刻度上进行线性余弦转换所得。</p>\n<h2 id=\"MFCC概述\"><a href=\"#MFCC概述\" class=\"headerlink\" title=\"MFCC概述\"></a>MFCC概述</h2><p>所有的梅尔频率倒谱系数(Mel-frequency cepstral coefficients  简称MFCC)共同的组成一个MFC。MFCCs在Mel标度频率域提取出来的倒谱参数。倒谱和梅尔频率倒谱之间的差别是在MFC中，频带在梅尔刻度上是等间隔的，这比利用线性间隔频带的倒谱更接近于人类的听觉特性。</p>\n<p>梅尔倒谱系数（Mel-scale Frequency Cepstral Coefficients，简称MFCC）。根据人耳听觉机理的研究发现，人耳对不同频率的声波有不同的听觉敏感度。从200Hz到5000Hz的语音信号对语音的清晰度影响对大。两个响度不等的声音作用于人耳时，则响度较高的频率成分的存在会影响到对响度较低的频率成分的感受，使其变得不易察觉，这种现象称为掩蔽效应。由于频率较低的声音在内耳蜗基底膜上行波传递的距离大于频率较高的声音，故一般来说，低音容易掩蔽高音，而高音掩蔽低音较困难。在低频处的声音掩蔽的临界带宽较高频要小。所以，人们从低频到高频这一段频带内按临界带宽的大小由密到疏安排一组带通滤波器，对输入信号进行滤波。将每个带通滤波器输出的信号能量作为信号的基本特征，对此特征经过进一步处理后就可以作为语音的输入特征。由于这种特征不依赖于信号的性质，对输入信号不做任何的假设和限制，又利用了听觉模型的研究成果。因此，这种参数比基于声道模型的LPCC相比具有更好的鲁邦性，更符合人耳的听觉特性，而且当信噪比降低时仍然具有较好的识别性能。<br>梅尔倒谱系数（Mel-scale Frequency Cepstral Coefficients，简称MFCC）是在Mel标度频率域提取出来的倒谱参数，Mel标度描述了人耳频率的非线性特性，它与频率的关系可用下式近似表示：<br>!式中f为频率，单位为Hz。<img src=\"http://i4.buimg.com/567571/30101a853606f79a.png\" alt=\"下图展示了Mel频率与线性频率的关系：\"></p>\n<h2 id=\"MFCC的提取过程\"><a href=\"#MFCC的提取过程\" class=\"headerlink\" title=\"MFCC的提取过程\"></a>MFCC的提取过程</h2><p>基本流程图如下所示<img src=\"http://i4.buimg.com/567571/b9f554db65843806.png\" alt=\"：\"></p>\n<h3 id=\"预加重\"><a href=\"#预加重\" class=\"headerlink\" title=\"预加重\"></a>预加重</h3><p>预加重处理其实是将语音信号通过一个高通滤波器。预加重的目的是提升高频部分，使信号的频谱变得平坦，保持在低频到高频的整个频带中，能用同样的信噪比求频谱。同时，也是为了消除发生过程中声带和嘴唇的效应，来补偿语音信号受到发音系统所抑制的高频部分，也为了突出高频的共振峰。</p>\n<h3 id=\"分帧\"><a href=\"#分帧\" class=\"headerlink\" title=\"分帧\"></a>分帧</h3><p>先将N个采样点集合成一个观测单位，称为帧。通常情况下N的值为256或512，涵盖的时间约为20~30ms左右。为了避免相邻两帧的变化过大，因此会让两相邻帧之间有一段重叠区域，此重叠区域包含了M个取样点，通常M的值约为N的1&#x2F;2或1&#x2F;3。通常语音识别所采用语音信号的采样频率为8KHz或16KHz，以8KHz来说，若帧长度为256个采样点，则对应的时间长度是256&#x2F;8000×1000&#x3D;32ms。</p>\n<h3 id=\"加窗\"><a href=\"#加窗\" class=\"headerlink\" title=\"加窗\"></a>加窗</h3><p>将每一帧乘以汉明窗，以增加帧左端和右端的连续性。假设分帧后的信号为S(n), n&#x3D;0,1…,N-1, N为帧的大小，那么乘上汉明窗后，<img src=\"http://i4.buimg.com/567571/40616a69a003fdb5.png\" alt=\"W(n)形式如下：\"></p>\n<p>不同的a值会产生不同的汉明窗，一般情况下a取0.46</p>\n<h3 id=\"快速傅立叶变换-FFT\"><a href=\"#快速傅立叶变换-FFT\" class=\"headerlink\" title=\"快速傅立叶变换(FFT)\"></a>快速傅立叶变换(FFT)</h3><p>由于信号在时域上的变换通常很难看出信号的特性，所以通常将它转换为频域上的能量分布来观察，不同的能量分布，就能代表不同语音的特性。所以在乘上汉明窗后，每帧还必须再经过快速傅里叶变换以得到在频谱上的能量分布。对分帧加窗后的各帧信号进行快速傅里叶变换得到各帧的频谱。并对语音信号的频谱取模平方得到语音信号的功率谱。<img src=\"http://i4.buimg.com/567571/7bded251e1eef088.png\" alt=\"设语音信号的DFT为:\">式中x(n)为输入的语音信号，N表示傅里叶变换的点数。</p>\n<h3 id=\"三角带通滤波器\"><a href=\"#三角带通滤波器\" class=\"headerlink\" title=\"三角带通滤波器\"></a>三角带通滤波器</h3><p>三角形带通滤波器组的设计过程如下：假设语音信号的采样频率,帧长N&#x3D;256，滤波器个数K&#x3D;22.由此可得语音信号的最大频率为<img src=\"http://i2.muimg.com/567571/f4ae206f2de2033a.png\" alt=\"：\"><br><img src=\"/\" alt=\"根据公式：\"><a href=\"http://i4.buimg.com/567571/a2cb6880c19f3df6.png%E5%8F%AF%E4%BB%A5%E6%B1%82%E5%BE%97%E5%87%BA%E6%9C%80%E5%A4%A7%E7%9A%84Mel%E9%A2%91%E7%8E%87%E3%80%82\">http://i4.buimg.com/567571/a2cb6880c19f3df6.png可以求得出最大的Mel频率。</a><br>由于在Mel刻度范围内，各个三角滤波器的中心频率是相等间隔的线性分布。由此，可以计算两个相邻三角滤波器的中心频率的间距为：(<a href=\"http://i1.piimg.com/567571/9b6787110581809b.png\">http://i1.piimg.com/567571/9b6787110581809b.png</a>)<br>因此，各三角形滤波器在mel刻度上的中心频率可以由Mel频率与线性频率的关系式求出。</p>\n<p>由上面的中心频率可以计算出对应的线性刻度上的频率。<img src=\"http://i2.muimg.com/567571/8b4d169ffeebcbb4.png\" alt=\"如下图所示：\"><br>将功率谱通过一组Mel尺度的三角形滤波器组，定义一个有K个滤波器的滤波器组（滤波器的个数和临界带的个数相近），采用的滤波器为三角滤波器，中心频率为f(m),m&#x3D;1,2,…,K。K通常取22-26。各 f(m)之间的间隔随着m值的减小而缩小，随着m值的增大而增宽，</p>\n<p>每一个三角形滤波器的中心频率c(l) 在Mel频率轴上等间隔分布。设o(l),c(l),h(l) 分别是第l 个三角形滤波器的下限，中心，和上限频率，则相邻三角形滤波器之间的下限，中心，上限频率的关系如下：c(l)&#x3D;h(l-1)&#x3D;o(l+1);  如图所示<img src=\"http://i4.buimg.com/567571/47d4ea5baf1ec728.png\" alt=\"：\"></p>\n<h3 id=\"计算每个滤波器组输出的对数能量为\"><a href=\"#计算每个滤波器组输出的对数能量为\" class=\"headerlink\" title=\"计算每个滤波器组输出的对数能量为:\"></a>计算每个滤波器组输出的对数能量为:</h3><p>(<a href=\"http://i4.buimg.com/567571/f38f2ce76b6f9def.png\">http://i4.buimg.com/567571/f38f2ce76b6f9def.png</a>)</p>\n<h3 id=\"经离散余弦变换（DCT）得到MFCC系数：\"><a href=\"#经离散余弦变换（DCT）得到MFCC系数：\" class=\"headerlink\" title=\"经离散余弦变换（DCT）得到MFCC系数：\"></a>经离散余弦变换（DCT）得到MFCC系数：</h3><p>将上述的对数能量带入离散余弦变换，求出L阶的Mel-scale Cepstrum参数。L阶指MFCC系数阶数，通常取12-16。这里M是三角滤波器个数。</p>\n<h3 id=\"对数能量\"><a href=\"#对数能量\" class=\"headerlink\" title=\"对数能量\"></a>对数能量</h3><p>此外，一帧的音量（即能量），也是语音的重要特征，而且非常容易计算。因此，通常再加上一帧的对数能量（定义：一帧内信号的平方和，再取以10为底的对数值，再乘以10）使得每一帧基本的语音特征就多了一维，包括一个对数能量和剩下的倒频谱参数。</p>\n<p>注：若要加入其它语音特征以测试识别率，也可以在此阶段加入，这些常用的其它语音特征包含音高、过零率以及共振峰等。</p>\n<h3 id=\"动态差分参数的提取（包括一阶差分和二阶差分）\"><a href=\"#动态差分参数的提取（包括一阶差分和二阶差分）\" class=\"headerlink\" title=\"动态差分参数的提取（包括一阶差分和二阶差分）\"></a>动态差分参数的提取（包括一阶差分和二阶差分）</h3><p>标准的倒谱参数MFCC只反映了语音参数的静态特性，语音的动态特性可以用这些静态特征的差分谱来描述。实验证明：把动、静态特征结合起来才能有效提高系统的识别性能。</p>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>因此，MFCC的全部组成其实是由：</p>\n<p>N维MFCC参数（N&#x2F;3 MFCC系数+ N&#x2F;3 一阶差分参数+ N&#x2F;3 二阶差分参数）+帧能量（此项可根据需求替换）</p>\n<h2 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h2><h3 id=\"MATLAB实现\"><a href=\"#MATLAB实现\" class=\"headerlink\" title=\"MATLAB实现\"></a>MATLAB实现</h3><p>‘’’ bash<br>% MFCC implement with Matlab %<br>[x fs]&#x3D;wavread(‘test.wav’);<br>bank&#x3D;melbankm(24,256,fs,0,0.4,’t’); %Mel滤波器的阶数为24，FFT变换的长度为256，采样频率为16000Hz<br>%归一化Mel滤波器组系数<br>bank&#x3D;full(bank); %full() convert sparse matrix to full matrix<br>bank&#x3D;bank&#x2F;max(bank(:));<br>for k&#x3D;1:12<br>    n&#x3D;0:23;<br>    dctcoef(k,:)&#x3D;cos((2<em>n+1)<em>k</em>pi&#x2F;(2</em>24));<br>end<br>w&#x3D;1+6<em>sin(pi</em>[1:12].&#x2F;12);%归一化倒谱提升窗口<br>w&#x3D;w&#x2F;max(w);%预加重滤波器<br>xx&#x3D;double(x);<br>xx&#x3D;filter([1-0.9375],1,xx);%语音信号分帧<br>xx&#x3D;enframe(xx,256,80);%对xx 256点分为一帧<br>%计算每帧的MFCC参数<br>for i&#x3D;1:size(xx,1)<br>    y&#x3D;xx(i,:);<br>    s&#x3D;y’.<em>hamming(256);<br>    t&#x3D;abs(fft(s));%FFT快速傅里叶变换<br>    t&#x3D;t.^2;<br>    c1&#x3D;dctcoef</em>log(bank<em>t(1:129));<br>    c2&#x3D;c1.<em>w’;<br>    m(i,:)&#x3D;c2;<br>end<br>%求一阶差分系数<br>dtm&#x3D;zeros(size(m));<br>for i&#x3D;3:size(m,1)-2<br>    dtm(i,:)&#x3D;-2</em>m(i-2,:)-m(i-1,:)+m(i+1,:)+2</em>m(i+2,:);<br>end<br>dtm&#x3D;dtm&#x2F;3;<br>%求取二阶差分系数<br>dtmm&#x3D;zeros(size(dtm));<br>for i&#x3D;3:size(dtm,1)-2<br>    dtmm(i,:)&#x3D;-2<em>dtm(i-2,:)-dtm(i-1,:)+dtm(i+1,:)+2</em>dtm(i+2,:);<br>end<br>dtmm&#x3D;dtmm&#x2F;3;<br>%合并mfcc参数和一阶差分mfcc参数<br>ccc&#x3D;[m dtm dtmm];<br>%去除首尾两帧，以为这两帧的一阶差分参数为0<br>ccc&#x3D;ccc(3:size(m,1)-2,:);<br>ccc;<br>subplot(2,1,1);<br>ccc_1&#x3D;ccc(:,1);<br>plot(ccc_1);title(‘MFCC’);ylabel(‘幅值’);<br>[h,w]&#x3D;size(ccc);<br>A&#x3D;size(ccc);<br>subplot(2,1,2);<br>plot([1,w],A);<br>xlabel(‘维数’);ylabel(‘幅值’);<br>title(‘维数与幅值的关系’);<br>‘’’</p>\n<p><img src=\"http://i1.piimg.com/567571/0f67ecb1f9e4e8a7.png\" alt=\"所得结果为：\"></p>\n<h3 id=\"HTK-HTK-Speech-Recognition-Toolkit-工具包提取MFCC：\"><a href=\"#HTK-HTK-Speech-Recognition-Toolkit-工具包提取MFCC：\" class=\"headerlink\" title=\"HTK(HTK Speech Recognition Toolkit)工具包提取MFCC：\"></a>HTK(HTK Speech Recognition Toolkit)工具包提取MFCC：</h3><p>cd ~&#x2F;HTK&#x2F;htk&#x2F;bin.win32&#x2F;下运行如下指令:<br>‘’’ bash<br>再配置文件夹下运行： HCopy config 8.wav 8.mfcc 其中，涉及mfcc的参数为： TARGETKIND&#x3D;MFCC_E_D_A -目标是MFCC文件，以及energy(E), delta(D),delta-delta(A) TARGETRATE&#x3D;100000 -窗间隔为10ms WINDOWSIZE&#x3D;250000 -窗长为25ms 注：HTK中时间单位为100ns ZMEANSOURCE&#x3D;T -将来源文件取zero mean,即去掉DC值 USEHAMMING&#x3D;T -使用hamming window PREEMCOEF&#x3D;0.97 -预加重系数0.97 NUMCHANS&#x3D;31 -在MEL刻度下等分成31个频带 USEPOWER&#x3D;F -不使用c(0)参数<br>‘’’</p>\n<h3 id=\"OpenSMILE工具包提取MFCC：\"><a href=\"#OpenSMILE工具包提取MFCC：\" class=\"headerlink\" title=\"OpenSMILE工具包提取MFCC：\"></a>OpenSMILE工具包提取MFCC：</h3><p>对于批量提取的wav音频数据的MFCC特征，可以将提取指令写入批处理文件，执行即可。<br>cd ~&#x2F;opensmile&#x2F;bin&#x2F;Win32&#x2F;下运行如下指令:<br>‘’’ bash<br>SMILExtract_Release -C E:\\speakerData\\opensmile-2.3.0\\config\\MFCC12_E_D_A_Z.conf -I\tE:\\深度学习\\基于声音的场景识别\\音频数据集\\TUT-acoustic-scenes-2016-development.audio\\TUT-acoustic-scenes-2016-development.Audio.All\\audio\\a001_0_30.wav\t-O\tE:\\深度学习\\基于声音的场景识别\\音频数据集\\TUT-acoustic-scenes-2016-development.audio\\TUT-acoustic-scenes-2016-development.Audio.All\\DNNmfcc\\a001_0_30.mfcc<br>‘’’</p>\n"},{"title":"进击的Tensorflow","date":"2017-04-25T14:07:47.000Z","thumbnail":null,"_content":"\n开源人工智能神器——TensorFlow\n\n# TensorFlow安装\n## 编译源码安装TensorFlow\n参加官网[https://www.tensorflow.org/install/install_sources](https://www.tensorflow.org/install/install_sources)\n\n本教程基于ubuntu16.04系统,安装前默认以下模块均已安装完成：python3.5,cuda8.0,cudnn 5.1.10 \n\n### install GNU coreutils\n``` bash\n$ sudo apt-get install coreutils\n``` \n### 安装bazel\n\n参见官网 [https://bazel.build/versions/master/docs/install.html](https://bazel.build/versions/master/docs/install.html)\n\n第一步\n``` bash\nsudo add-apt-repository ppa:webupd8team.java\nsudo apt-get update\nsudo apt-get install oracle-java8-installer\n``` \n\n第二步\n``` bash\necho \"deb [arch=amd64] http://storage.googleapis.com/bazel-apt stable jdk1.8\" | sudo tee /etc/apt/sources.list.d/bazel.list\ncurl https://bazel.build/bazel-release.pub.gpg | sudo apt-key add -\n``` \n\n\n第三步\n``` bash\nsudo apt-get update && sudo apt-get install bazel\nsudo apt-get upgrade bazel\n``` \n\n### Configure the installation\n\n下载tensorflow,进入目录进行配置\n``` bash\ngit clone --recurse-submodules https://github.com/tensorflow/tensorflow\ncd tensorflow\n./configure\n``` \n\n按照提示做完即可，别填错自己的Python路径，gcc路径和cuda以及cudnn路径，不然后面编译可能会失败。\n\n### build a pip package with gpu\n``` bash\n$ bazel build --config=opt --config=cuda //tensorflow/tools/pip_package:build_pip_package\n``` \n\n\n## 使用安装包安装TensorFlow\n\n在安装必不可少的python-pip和python-dev\n\n在这个窗口中输入命令：\n``` bash\n$ sudo apt-get install python-pip python-dev\n``` \n### 安装TensorFlow CPU版本\n安装完成之后，此时就可以安装TensorFlow CPU版本了了，命令如下：\n``` bash\nsudo pip install --upgrade https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-1.0.0-cp27-none-linux_x86_64.whl\n``` \n\n\n### 安装TensorFlow GPU版本\n命令如下：\n``` bash\nsudo pip install --upgrade https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-1.0.0-cp27-none-linux_x86_64.whl\n``` \n\n安装成功显示如下：\n![](http://i2.muimg.com/567571/b3c444e41485ce6f.png)\n\n运行如下代码测试是否成功安装TensorFlow：\n![](http://i2.muimg.com/567571/1146e7725996c190.png)\n\n# TensorFlow相关资源：\n\n## TensorFlow 中文社区\n[http://www.tensorfly.cn/](http://www.tensorfly.cn/)\n\n## TensorFlow 白皮书\n\n在这份白皮书里，你可以找到关于 TensorFlow 编程模型的更多详情和 TensorFlow 的实现原理。\n\nTensorFlow: Large-scale machine learning on heterogeneous systems [http://download.tensorflow.org/paper/whitepaper2015.pdf](http://download.tensorflow.org/paper/whitepaper2015.pdf)\n\n## TensorFlow使用样例\n[https://github.com/aymericdamien/TensorFlow-Examples](https://github.com/aymericdamien/TensorFlow-Examples)\n\n##更多机器学习资源\n[http://www.tensorfly.cn/tfdoc/mltools.html](http://www.tensorfly.cn/tfdoc/mltools.html)\n\n# 注意事项\n\n(1) 如果需要 GPU，那么首先安装 CUDA 和 cuDNN。 \n(2) GTX1080为 Pascal 架构，需要安装 CUDA 8.0 + cuDNN 5.1.5 才能正常运行。 \n(3) TensorFlow 从 0.8.0rc 开始支持多机多卡分布式计算，而更早的版本只支持单计算节点。 \n","source":"_posts/进击的Tensorflow.md","raw":"---\ntitle: 进击的Tensorflow\ndate: 2017-04-25 22:07:47\ntags:\ncategories: 分享集\nthumbnail: # http://i2.muimg.com/567571/8a8c33b8e8f2438c.png\n---\n\n开源人工智能神器——TensorFlow\n\n# TensorFlow安装\n## 编译源码安装TensorFlow\n参加官网[https://www.tensorflow.org/install/install_sources](https://www.tensorflow.org/install/install_sources)\n\n本教程基于ubuntu16.04系统,安装前默认以下模块均已安装完成：python3.5,cuda8.0,cudnn 5.1.10 \n\n### install GNU coreutils\n``` bash\n$ sudo apt-get install coreutils\n``` \n### 安装bazel\n\n参见官网 [https://bazel.build/versions/master/docs/install.html](https://bazel.build/versions/master/docs/install.html)\n\n第一步\n``` bash\nsudo add-apt-repository ppa:webupd8team.java\nsudo apt-get update\nsudo apt-get install oracle-java8-installer\n``` \n\n第二步\n``` bash\necho \"deb [arch=amd64] http://storage.googleapis.com/bazel-apt stable jdk1.8\" | sudo tee /etc/apt/sources.list.d/bazel.list\ncurl https://bazel.build/bazel-release.pub.gpg | sudo apt-key add -\n``` \n\n\n第三步\n``` bash\nsudo apt-get update && sudo apt-get install bazel\nsudo apt-get upgrade bazel\n``` \n\n### Configure the installation\n\n下载tensorflow,进入目录进行配置\n``` bash\ngit clone --recurse-submodules https://github.com/tensorflow/tensorflow\ncd tensorflow\n./configure\n``` \n\n按照提示做完即可，别填错自己的Python路径，gcc路径和cuda以及cudnn路径，不然后面编译可能会失败。\n\n### build a pip package with gpu\n``` bash\n$ bazel build --config=opt --config=cuda //tensorflow/tools/pip_package:build_pip_package\n``` \n\n\n## 使用安装包安装TensorFlow\n\n在安装必不可少的python-pip和python-dev\n\n在这个窗口中输入命令：\n``` bash\n$ sudo apt-get install python-pip python-dev\n``` \n### 安装TensorFlow CPU版本\n安装完成之后，此时就可以安装TensorFlow CPU版本了了，命令如下：\n``` bash\nsudo pip install --upgrade https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-1.0.0-cp27-none-linux_x86_64.whl\n``` \n\n\n### 安装TensorFlow GPU版本\n命令如下：\n``` bash\nsudo pip install --upgrade https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-1.0.0-cp27-none-linux_x86_64.whl\n``` \n\n安装成功显示如下：\n![](http://i2.muimg.com/567571/b3c444e41485ce6f.png)\n\n运行如下代码测试是否成功安装TensorFlow：\n![](http://i2.muimg.com/567571/1146e7725996c190.png)\n\n# TensorFlow相关资源：\n\n## TensorFlow 中文社区\n[http://www.tensorfly.cn/](http://www.tensorfly.cn/)\n\n## TensorFlow 白皮书\n\n在这份白皮书里，你可以找到关于 TensorFlow 编程模型的更多详情和 TensorFlow 的实现原理。\n\nTensorFlow: Large-scale machine learning on heterogeneous systems [http://download.tensorflow.org/paper/whitepaper2015.pdf](http://download.tensorflow.org/paper/whitepaper2015.pdf)\n\n## TensorFlow使用样例\n[https://github.com/aymericdamien/TensorFlow-Examples](https://github.com/aymericdamien/TensorFlow-Examples)\n\n##更多机器学习资源\n[http://www.tensorfly.cn/tfdoc/mltools.html](http://www.tensorfly.cn/tfdoc/mltools.html)\n\n# 注意事项\n\n(1) 如果需要 GPU，那么首先安装 CUDA 和 cuDNN。 \n(2) GTX1080为 Pascal 架构，需要安装 CUDA 8.0 + cuDNN 5.1.5 才能正常运行。 \n(3) TensorFlow 从 0.8.0rc 开始支持多机多卡分布式计算，而更早的版本只支持单计算节点。 \n","slug":"进击的Tensorflow","published":1,"updated":"2021-12-12T14:25:36.657Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3bsl2iw000p5awq4zdu9tsh","content":"<p>开源人工智能神器——TensorFlow</p>\n<h1 id=\"TensorFlow安装\"><a href=\"#TensorFlow安装\" class=\"headerlink\" title=\"TensorFlow安装\"></a>TensorFlow安装</h1><h2 id=\"编译源码安装TensorFlow\"><a href=\"#编译源码安装TensorFlow\" class=\"headerlink\" title=\"编译源码安装TensorFlow\"></a>编译源码安装TensorFlow</h2><p>参加官网<a href=\"https://www.tensorflow.org/install/install_sources\">https://www.tensorflow.org/install/install_sources</a></p>\n<p>本教程基于ubuntu16.04系统,安装前默认以下模块均已安装完成：python3.5,cuda8.0,cudnn 5.1.10 </p>\n<h3 id=\"install-GNU-coreutils\"><a href=\"#install-GNU-coreutils\" class=\"headerlink\" title=\"install GNU coreutils\"></a>install GNU coreutils</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ sudo apt-get install coreutils<br></code></pre></td></tr></table></figure>\n<h3 id=\"安装bazel\"><a href=\"#安装bazel\" class=\"headerlink\" title=\"安装bazel\"></a>安装bazel</h3><p>参见官网 <a href=\"https://bazel.build/versions/master/docs/install.html\">https://bazel.build/versions/master/docs/install.html</a></p>\n<p>第一步</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">sudo add-apt-repository ppa:webupd8team.java<br>sudo apt-get update<br>sudo apt-get install oracle-java8-installer<br></code></pre></td></tr></table></figure>\n\n<p>第二步</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;deb [arch=amd64] http://storage.googleapis.com/bazel-apt stable jdk1.8&quot;</span> | sudo <span class=\"hljs-built_in\">tee</span> /etc/apt/sources.list.d/bazel.list<br>curl https://bazel.build/bazel-release.pub.gpg | sudo apt-key add -<br></code></pre></td></tr></table></figure>\n\n\n<p>第三步</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">sudo apt-get update &amp;&amp; sudo apt-get install bazel<br>sudo apt-get upgrade bazel<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Configure-the-installation\"><a href=\"#Configure-the-installation\" class=\"headerlink\" title=\"Configure the installation\"></a>Configure the installation</h3><p>下载tensorflow,进入目录进行配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">clone</span> --recurse-submodules https://github.com/tensorflow/tensorflow<br><span class=\"hljs-built_in\">cd</span> tensorflow<br>./configure<br></code></pre></td></tr></table></figure>\n\n<p>按照提示做完即可，别填错自己的Python路径，gcc路径和cuda以及cudnn路径，不然后面编译可能会失败。</p>\n<h3 id=\"build-a-pip-package-with-gpu\"><a href=\"#build-a-pip-package-with-gpu\" class=\"headerlink\" title=\"build a pip package with gpu\"></a>build a pip package with gpu</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ bazel build --config=opt --config=cuda //tensorflow/tools/pip_package:build_pip_package<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"使用安装包安装TensorFlow\"><a href=\"#使用安装包安装TensorFlow\" class=\"headerlink\" title=\"使用安装包安装TensorFlow\"></a>使用安装包安装TensorFlow</h2><p>在安装必不可少的python-pip和python-dev</p>\n<p>在这个窗口中输入命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ sudo apt-get install python-pip python-dev<br></code></pre></td></tr></table></figure>\n<h3 id=\"安装TensorFlow-CPU版本\"><a href=\"#安装TensorFlow-CPU版本\" class=\"headerlink\" title=\"安装TensorFlow CPU版本\"></a>安装TensorFlow CPU版本</h3><p>安装完成之后，此时就可以安装TensorFlow CPU版本了了，命令如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">sudo pip install --upgrade https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-1.0.0-cp27-none-linux_x86_64.whl<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"安装TensorFlow-GPU版本\"><a href=\"#安装TensorFlow-GPU版本\" class=\"headerlink\" title=\"安装TensorFlow GPU版本\"></a>安装TensorFlow GPU版本</h3><p>命令如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">sudo pip install --upgrade https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-1.0.0-cp27-none-linux_x86_64.whl<br></code></pre></td></tr></table></figure>\n\n<p>安装成功显示如下：<br><img src=\"http://i2.muimg.com/567571/b3c444e41485ce6f.png\"></p>\n<p>运行如下代码测试是否成功安装TensorFlow：<br><img src=\"http://i2.muimg.com/567571/1146e7725996c190.png\"></p>\n<h1 id=\"TensorFlow相关资源：\"><a href=\"#TensorFlow相关资源：\" class=\"headerlink\" title=\"TensorFlow相关资源：\"></a>TensorFlow相关资源：</h1><h2 id=\"TensorFlow-中文社区\"><a href=\"#TensorFlow-中文社区\" class=\"headerlink\" title=\"TensorFlow 中文社区\"></a>TensorFlow 中文社区</h2><p><a href=\"http://www.tensorfly.cn/\">http://www.tensorfly.cn/</a></p>\n<h2 id=\"TensorFlow-白皮书\"><a href=\"#TensorFlow-白皮书\" class=\"headerlink\" title=\"TensorFlow 白皮书\"></a>TensorFlow 白皮书</h2><p>在这份白皮书里，你可以找到关于 TensorFlow 编程模型的更多详情和 TensorFlow 的实现原理。</p>\n<p>TensorFlow: Large-scale machine learning on heterogeneous systems <a href=\"http://download.tensorflow.org/paper/whitepaper2015.pdf\">http://download.tensorflow.org/paper/whitepaper2015.pdf</a></p>\n<h2 id=\"TensorFlow使用样例\"><a href=\"#TensorFlow使用样例\" class=\"headerlink\" title=\"TensorFlow使用样例\"></a>TensorFlow使用样例</h2><p><a href=\"https://github.com/aymericdamien/TensorFlow-Examples\">https://github.com/aymericdamien/TensorFlow-Examples</a></p>\n<p>##更多机器学习资源<br><a href=\"http://www.tensorfly.cn/tfdoc/mltools.html\">http://www.tensorfly.cn/tfdoc/mltools.html</a></p>\n<h1 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h1><p>(1) 如果需要 GPU，那么首先安装 CUDA 和 cuDNN。<br>(2) GTX1080为 Pascal 架构，需要安装 CUDA 8.0 + cuDNN 5.1.5 才能正常运行。<br>(3) TensorFlow 从 0.8.0rc 开始支持多机多卡分布式计算，而更早的版本只支持单计算节点。 </p>\n","site":{"data":{}},"wordcount":1879,"excerpt":"","more":"<p>开源人工智能神器——TensorFlow</p>\n<h1 id=\"TensorFlow安装\"><a href=\"#TensorFlow安装\" class=\"headerlink\" title=\"TensorFlow安装\"></a>TensorFlow安装</h1><h2 id=\"编译源码安装TensorFlow\"><a href=\"#编译源码安装TensorFlow\" class=\"headerlink\" title=\"编译源码安装TensorFlow\"></a>编译源码安装TensorFlow</h2><p>参加官网<a href=\"https://www.tensorflow.org/install/install_sources\">https://www.tensorflow.org/install/install_sources</a></p>\n<p>本教程基于ubuntu16.04系统,安装前默认以下模块均已安装完成：python3.5,cuda8.0,cudnn 5.1.10 </p>\n<h3 id=\"install-GNU-coreutils\"><a href=\"#install-GNU-coreutils\" class=\"headerlink\" title=\"install GNU coreutils\"></a>install GNU coreutils</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ sudo apt-get install coreutils<br></code></pre></td></tr></table></figure>\n<h3 id=\"安装bazel\"><a href=\"#安装bazel\" class=\"headerlink\" title=\"安装bazel\"></a>安装bazel</h3><p>参见官网 <a href=\"https://bazel.build/versions/master/docs/install.html\">https://bazel.build/versions/master/docs/install.html</a></p>\n<p>第一步</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">sudo add-apt-repository ppa:webupd8team.java<br>sudo apt-get update<br>sudo apt-get install oracle-java8-installer<br></code></pre></td></tr></table></figure>\n\n<p>第二步</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;deb [arch=amd64] http://storage.googleapis.com/bazel-apt stable jdk1.8&quot;</span> | sudo <span class=\"hljs-built_in\">tee</span> /etc/apt/sources.list.d/bazel.list<br>curl https://bazel.build/bazel-release.pub.gpg | sudo apt-key add -<br></code></pre></td></tr></table></figure>\n\n\n<p>第三步</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">sudo apt-get update &amp;&amp; sudo apt-get install bazel<br>sudo apt-get upgrade bazel<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Configure-the-installation\"><a href=\"#Configure-the-installation\" class=\"headerlink\" title=\"Configure the installation\"></a>Configure the installation</h3><p>下载tensorflow,进入目录进行配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">clone</span> --recurse-submodules https://github.com/tensorflow/tensorflow<br><span class=\"hljs-built_in\">cd</span> tensorflow<br>./configure<br></code></pre></td></tr></table></figure>\n\n<p>按照提示做完即可，别填错自己的Python路径，gcc路径和cuda以及cudnn路径，不然后面编译可能会失败。</p>\n<h3 id=\"build-a-pip-package-with-gpu\"><a href=\"#build-a-pip-package-with-gpu\" class=\"headerlink\" title=\"build a pip package with gpu\"></a>build a pip package with gpu</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ bazel build --config=opt --config=cuda //tensorflow/tools/pip_package:build_pip_package<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"使用安装包安装TensorFlow\"><a href=\"#使用安装包安装TensorFlow\" class=\"headerlink\" title=\"使用安装包安装TensorFlow\"></a>使用安装包安装TensorFlow</h2><p>在安装必不可少的python-pip和python-dev</p>\n<p>在这个窗口中输入命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ sudo apt-get install python-pip python-dev<br></code></pre></td></tr></table></figure>\n<h3 id=\"安装TensorFlow-CPU版本\"><a href=\"#安装TensorFlow-CPU版本\" class=\"headerlink\" title=\"安装TensorFlow CPU版本\"></a>安装TensorFlow CPU版本</h3><p>安装完成之后，此时就可以安装TensorFlow CPU版本了了，命令如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">sudo pip install --upgrade https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-1.0.0-cp27-none-linux_x86_64.whl<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"安装TensorFlow-GPU版本\"><a href=\"#安装TensorFlow-GPU版本\" class=\"headerlink\" title=\"安装TensorFlow GPU版本\"></a>安装TensorFlow GPU版本</h3><p>命令如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">sudo pip install --upgrade https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-1.0.0-cp27-none-linux_x86_64.whl<br></code></pre></td></tr></table></figure>\n\n<p>安装成功显示如下：<br><img src=\"http://i2.muimg.com/567571/b3c444e41485ce6f.png\"></p>\n<p>运行如下代码测试是否成功安装TensorFlow：<br><img src=\"http://i2.muimg.com/567571/1146e7725996c190.png\"></p>\n<h1 id=\"TensorFlow相关资源：\"><a href=\"#TensorFlow相关资源：\" class=\"headerlink\" title=\"TensorFlow相关资源：\"></a>TensorFlow相关资源：</h1><h2 id=\"TensorFlow-中文社区\"><a href=\"#TensorFlow-中文社区\" class=\"headerlink\" title=\"TensorFlow 中文社区\"></a>TensorFlow 中文社区</h2><p><a href=\"http://www.tensorfly.cn/\">http://www.tensorfly.cn/</a></p>\n<h2 id=\"TensorFlow-白皮书\"><a href=\"#TensorFlow-白皮书\" class=\"headerlink\" title=\"TensorFlow 白皮书\"></a>TensorFlow 白皮书</h2><p>在这份白皮书里，你可以找到关于 TensorFlow 编程模型的更多详情和 TensorFlow 的实现原理。</p>\n<p>TensorFlow: Large-scale machine learning on heterogeneous systems <a href=\"http://download.tensorflow.org/paper/whitepaper2015.pdf\">http://download.tensorflow.org/paper/whitepaper2015.pdf</a></p>\n<h2 id=\"TensorFlow使用样例\"><a href=\"#TensorFlow使用样例\" class=\"headerlink\" title=\"TensorFlow使用样例\"></a>TensorFlow使用样例</h2><p><a href=\"https://github.com/aymericdamien/TensorFlow-Examples\">https://github.com/aymericdamien/TensorFlow-Examples</a></p>\n<p>##更多机器学习资源<br><a href=\"http://www.tensorfly.cn/tfdoc/mltools.html\">http://www.tensorfly.cn/tfdoc/mltools.html</a></p>\n<h1 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h1><p>(1) 如果需要 GPU，那么首先安装 CUDA 和 cuDNN。<br>(2) GTX1080为 Pascal 架构，需要安装 CUDA 8.0 + cuDNN 5.1.5 才能正常运行。<br>(3) TensorFlow 从 0.8.0rc 开始支持多机多卡分布式计算，而更早的版本只支持单计算节点。 </p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl3bsl2i500015awq96uf9d2e","category_id":"cl3bsl2ic00045awq4y5k45wg","_id":"cl3bsl2ik000c5awqa166gup0"},{"post_id":"cl3bsl2ii000a5awq11xn4t5n","category_id":"cl3bsl2ic00045awq4y5k45wg","_id":"cl3bsl2io000g5awq1ggs473v"},{"post_id":"cl3bsl2ia00035awq2dv2g3lw","category_id":"cl3bsl2ii00095awqhvo038u8","_id":"cl3bsl2iq000j5awq95v0fgmh"},{"post_id":"cl3bsl2ij000b5awq21bf86ya","category_id":"cl3bsl2ii00095awqhvo038u8","_id":"cl3bsl2is000l5awq3tf19p8p"},{"post_id":"cl3bsl2im000e5awq5ew10asi","category_id":"cl3bsl2ii00095awqhvo038u8","_id":"cl3bsl2iv000o5awqey0ne55r"},{"post_id":"cl3bsl2ie00065awqh3401u48","category_id":"cl3bsl2ii00095awqhvo038u8","_id":"cl3bsl2iw000q5awqhkp57f8s"},{"post_id":"cl3bsl2in000f5awqdrwu6hmj","category_id":"cl3bsl2ii00095awqhvo038u8","_id":"cl3bsl2ix000s5awqdjsxeu35"},{"post_id":"cl3bsl2ig00075awqev4b8yvh","category_id":"cl3bsl2ii00095awqhvo038u8","_id":"cl3bsl2iy000t5awqdednfdcw"},{"post_id":"cl3bsl2ir000k5awq2cm7gry7","category_id":"cl3bsl2ic00045awq4y5k45wg","_id":"cl3bsl2iy000v5awq552f3yyj"},{"post_id":"cl3bsl2ih00085awq6uctcs5p","category_id":"cl3bsl2ii00095awqhvo038u8","_id":"cl3bsl2iz000w5awqcx4vc82s"},{"post_id":"cl3bsl2ip000i5awq0od22zyn","category_id":"cl3bsl2ix000r5awqgirq0ga8","_id":"cl3bsl2iz000y5awqa6pz81zo"},{"post_id":"cl3bsl2iu000n5awqfsbebsc2","category_id":"cl3bsl2iy000u5awq8suggwxb","_id":"cl3bsl2iz000z5awq7nwy3v9c"},{"post_id":"cl3bsl2iw000p5awq4zdu9tsh","category_id":"cl3bsl2iy000u5awq8suggwxb","_id":"cl3bsl2j000105awqbgn13zf1"}],"PostTag":[],"Tag":[]}}